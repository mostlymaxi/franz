Time	Sum	Command
10	443265	> __fish_on_interactive
7	7	-> functions -e __fish_on_interactive
110	443248	-> __fish_config_interactive
591	597	--> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_config_interactive.fish
6	6	---> function __fish_config_interactive -d "Initializations that should be performed when entering interactive mode"...
1	6	--> if not set -q __fish_initialized...
5	5	---> not set -q __fish_initialized
4	4	--> set -g __fish_active_key_bindings
4	4	--> function __init_uvar -d "Sets a universal variable if it's not already set"...
1	8	--> if test $__fish_initialized -lt 3400...
7	7	---> test $__fish_initialized -lt 3400
7	32	--> if not set -q FISH_UNIT_TESTS_RUNNING...
4	4	---> not set -q FISH_UNIT_TESTS_RUNNING
7	7	---> set -l script $__fish_data_dir/tools/create_manpage_completions.py
2	14	---> if not test -d $__fish_user_data_dir/generated_completions...
12	12	----> not test -d $__fish_user_data_dir/generated_completions
7	438456	--> if status --is-interactive...
4	4	---> status --is-interactive
5	5	---> functions -q fish_greeting
26	438440	---> fish_greeting
438414	438414	----> fastfetch
4	49	--> if test -d /etc/init.d...
45	45	---> test -d /etc/init.d
111	111	--> complete -c [ --wraps test
14	14	--> complete -c ! --wraps not
250	444	--> complete -c(builtin -n | string match -rv '(\.|:|source|cd|contains|count|echo|exec|printf|random|realpath|set|\\[|test|for)') --no-files
194	194	---> builtin -n | string match -rv '(\.|:|source|cd|contains|count|echo|exec|printf|random|realpath|set|\\[|test|for)'
10	10	--> function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings...
27	3135	--> __fish_reload_key_bindings
13	26	---> __init_uvar fish_key_bindings fish_default_key_bindings
2	13	----> if not set --query $argv[1]...
11	11	-----> not set --query $argv[1]
1	17	---> if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"...
16	16	----> test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
2	515	---> if not functions -q "$fish_key_bindings"...
138	513	----> not functions -q "$fish_key_bindings"
361	375	-----> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_default_key_bindings.fish
14	14	------> function fish_default_key_bindings -d "emacs-like key binds"...
17	17	---> set -g __fish_active_key_bindings "$fish_key_bindings"
6	6	---> set -g fish_bind_mode default
12	2432	---> if test "$fish_key_bindings" = fish_default_key_bindings...
7	7	----> test "$fish_key_bindings" = fish_default_key_bindings
104	2413	----> fish_default_key_bindings 2>/dev/null
2	16	-----> if contains -- -h $argv...
9	9	------> contains -- -h $argv
5	5	------> contains -- --help $argv
4	67	-----> if not set -q argv[1]...
4	4	------> not set -q argv[1]
49	49	------> bind --erase --all --preset
3	10	------> if test "$fish_key_bindings" != fish_default_key_bindings...
7	7	-------> test "$fish_key_bindings" != fish_default_key_bindings
3	14	-----> if not contains -- -s $argv...
5	5	------> not contains -- -s $argv
6	6	------> set argv -s $argv
142	1973	-----> __fish_shared_key_bindings $argv
627	653	------> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_shared_key_bindings.fish
11	11	-------> function __fish_shared_key_bindings -d "Bindings shared between emacs and vi mode"...
11	11	-------> function __fish_commandline_insert_escaped --description 'Insert the first arg escaped if a second arg is given'...
2	2	-------> function __fish_start_bracketed_paste...
2	2	-------> function __fish_stop_bracketed_paste...
4	29	------> if contains -- -h $argv...
18	18	-------> contains -- -h $argv
7	7	-------> contains -- --help $argv
10	10	------> bind --preset $argv \cy yank
6	6	------> bind --preset $argv \ey yank-pop
17	17	------> bind --preset $argv -k right forward-char
6	6	------> bind --preset $argv -k left backward-char
9	9	------> bind --preset $argv \e\[C forward-char
6	6	------> bind --preset $argv \e\[D backward-char
6	6	------> bind --preset $argv \eOC forward-char
5	5	------> bind --preset $argv \eOD backward-char
6	6	------> bind --preset $argv \e\[1\;5C forward-word
5	5	------> bind --preset $argv \e\[1\;5D backward-word
6	6	------> bind --preset $argv -k ppage beginning-of-history
6	6	------> bind --preset $argv -k npage end-of-history
6	6	------> bind --preset $argv \cx fish_clipboard_copy
5	5	------> bind --preset $argv \cv fish_clipboard_paste
6	6	------> bind --preset $argv \e cancel
5	5	------> bind --preset $argv \t complete
5	5	------> bind --preset $argv \cs pager-toggle-search
6	6	------> bind --preset $argv --key btab complete-and-search
8	8	------> bind --preset $argv -k sdc history-pager-delete or backward-delete-char
7	7	------> bind --preset $argv \e\n "commandline -f expand-abbr; commandline -i \n"
6	6	------> bind --preset $argv \e\r "commandline -f expand-abbr; commandline -i \n"
6	6	------> bind --preset $argv -k down down-or-search
6	6	------> bind --preset $argv -k up up-or-search
6	6	------> bind --preset $argv \e\[A up-or-search
6	6	------> bind --preset $argv \e\[B down-or-search
5	5	------> bind --preset $argv \eOA up-or-search
5	5	------> bind --preset $argv \eOB down-or-search
7	7	------> bind --preset $argv -k sright forward-bigword
6	6	------> bind --preset $argv -k sleft backward-bigword
6	6	------> bind --preset $argv \e\eOC nextd-or-forward-word
5	5	------> bind --preset $argv \e\eOD prevd-or-backward-word
5	5	------> bind --preset $argv \e\e\[C nextd-or-forward-word
5	5	------> bind --preset $argv \e\e\[D prevd-or-backward-word
5	5	------> bind --preset $argv \eO3C nextd-or-forward-word
6	6	------> bind --preset $argv \eO3D prevd-or-backward-word
6	6	------> bind --preset $argv \e\[3C nextd-or-forward-word
6	6	------> bind --preset $argv \e\[3D prevd-or-backward-word
6	6	------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
5	5	------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
6	6	------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
6	6	------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
6	6	------> bind --preset $argv \e\eOA history-token-search-backward
5	5	------> bind --preset $argv \e\eOB history-token-search-forward
5	5	------> bind --preset $argv \e\e\[A history-token-search-backward
6	6	------> bind --preset $argv \e\e\[B history-token-search-forward
6	6	------> bind --preset $argv \eO3A history-token-search-backward
5	5	------> bind --preset $argv \eO3B history-token-search-forward
5	5	------> bind --preset $argv \e\[3A history-token-search-backward
5	5	------> bind --preset $argv \e\[3B history-token-search-forward
6	6	------> bind --preset $argv \e\[1\;3A history-token-search-backward
6	6	------> bind --preset $argv \e\[1\;3B history-token-search-forward
6	6	------> bind --preset $argv \e\[1\;9A history-token-search-backward
6	6	------> bind --preset $argv \e\[1\;9B history-token-search-forward
6	6	------> bind --preset $argv \e. history-token-search-backward
5	5	------> bind --preset $argv \el __fish_list_current_token
7	7	------> bind --preset $argv \eo __fish_preview_current_file
5	5	------> bind --preset $argv \ew __fish_whatis_current_token
5	5	------> bind --preset $argv \cl clear-screen
5	5	------> bind --preset $argv \cc cancel-commandline
5	5	------> bind --preset $argv \cu backward-kill-line
5	5	------> bind --preset $argv \cw backward-kill-path-component
6	6	------> bind --preset $argv \e\[F end-of-line
5	5	------> bind --preset $argv \e\[H beginning-of-line
9	9	------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
5	5	------> bind --preset $argv \cd delete-or-exit
8	8	------> bind --preset $argv \es 'for cmd in sudo doas please; if command -q $cmd; fish_commandline_prepend $cmd; break; end; end'
9	9	------> bind --preset $argv -k f1 __fish_man_page
6	6	------> bind --preset $argv \eh __fish_man_page
11	11	------> bind --preset $argv \ep __fish_paginate
6	6	------> bind --preset $argv \e\# __fish_toggle_comment_commandline
6	6	------> bind --preset $argv \ee edit_command_buffer
6	6	------> bind --preset $argv \ev edit_command_buffer
154	347	------> for mode in (bind --list-modes | string match -v paste)...
166	166	-------> bind --list-modes | string match -v paste
14	14	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
6	6	-------> bind --preset -M $mode \e\[O false
7	7	-------> bind --preset -M $mode \e\[\?1004h false
53	134	------> for mode in (bind --list-modes | string match -v paste)...
65	65	-------> bind --list-modes | string match -v paste
16	16	-------> bind --preset -M $mode -m paste \e\[200~ __fish_start_bracketed_paste
7	7	------> bind --preset -M paste \e\[201~ __fish_stop_bracketed_paste
5	5	------> bind --preset -M paste "" self-insert
7	7	------> bind --preset -M paste \r "commandline -i \n"
8	8	------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
6	6	------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
5	5	------> bind --preset -M paste " " self-insert-notfirst
31	187	------> if not set -l index (contains --index -- -M $argv)...
46	55	-------> not set -l index (contains --index -- -M $argv)
9	9	--------> contains --index -- -M $argv
7	7	-------> bind --preset $argv "" self-insert
7	7	-------> bind --preset $argv " " self-insert expand-abbr
5	5	-------> bind --preset $argv ";" self-insert expand-abbr
6	6	-------> bind --preset $argv "|" self-insert expand-abbr
6	6	-------> bind --preset $argv "&" self-insert expand-abbr
7	7	-------> bind --preset $argv ">" self-insert expand-abbr
6	6	-------> bind --preset $argv "<" self-insert expand-abbr
5	5	-------> bind --preset $argv ")" self-insert expand-abbr
9	9	-------> bind --preset $argv -k nul 'test -n "$(commandline)" && commandline -i " "'
8	8	-------> bind --preset $argv \e\[32\;2u 'commandline -i " "; commandline -f expand-abbr'
5	5	-------> bind --preset $argv \n execute
5	5	-------> bind --preset $argv \r execute
7	7	-------> bind --preset $argv \e\[27\;5\;13~ execute
6	6	-------> bind --preset $argv \e\[13\;5u execute
6	6	-------> bind --preset $argv \e\[27\;2\;13~ execute
6	6	-------> bind --preset $argv \e\[13\;2u execute
7	7	-----> bind --preset $argv \ck kill-line
6	6	-----> bind --preset $argv \eOC forward-char
5	5	-----> bind --preset $argv \eOD backward-char
5	5	-----> bind --preset $argv \e\[C forward-char
5	5	-----> bind --preset $argv \e\[D backward-char
7	7	-----> bind --preset $argv -k right forward-char
5	5	-----> bind --preset $argv -k left backward-char
6	6	-----> bind --preset $argv -k dc delete-char
6	6	-----> bind --preset $argv -k backspace backward-delete-char
5	5	-----> bind --preset $argv \x7f backward-delete-char
6	6	-----> bind --preset $argv \e\[1~ beginning-of-line
5	5	-----> bind --preset $argv \e\[3~ delete-char
6	6	-----> bind --preset $argv \e\[4~ end-of-line
6	6	-----> bind --preset $argv -k home beginning-of-line
6	6	-----> bind --preset $argv -k end end-of-line
5	5	-----> bind --preset $argv \ca beginning-of-line
6	6	-----> bind --preset $argv \ce end-of-line
6	6	-----> bind --preset $argv \ch backward-delete-char
6	6	-----> bind --preset $argv \cp up-or-search
6	6	-----> bind --preset $argv \cn down-or-search
6	6	-----> bind --preset $argv \cf forward-char
5	5	-----> bind --preset $argv \cb backward-char
5	5	-----> bind --preset $argv \ct transpose-chars
6	6	-----> bind --preset $argv \cg cancel
5	5	-----> bind --preset $argv \c_ undo
5	5	-----> bind --preset $argv \cz undo
5	5	-----> bind --preset $argv \e/ redo
5	5	-----> bind --preset $argv \et transpose-words
7	7	-----> bind --preset $argv \eu upcase-word
6	6	-----> bind --preset $argv \ec capitalize-word
6	6	-----> bind --preset $argv \e\x7f backward-kill-word
5	5	-----> bind --preset $argv \e\b backward-kill-word
5	24	-----> if not test "$TERM_PROGRAM" = Apple_Terminal...
8	8	------> not test "$TERM_PROGRAM" = Apple_Terminal
6	6	------> bind --preset $argv \eb backward-word
5	5	------> bind --preset $argv \ef forward-word
6	6	-----> bind --preset $argv \e\< beginning-of-buffer
6	6	-----> bind --preset $argv \e\> end-of-buffer
5	5	-----> bind --preset $argv \ed kill-word
5	5	-----> bind --preset $argv \cr history-pager
7	7	-----> switch "$TERM"...
5	5	-----> set -e -g fish_cursor_selection_mode
2	95	---> if functions --query fish_user_key_bindings >/dev/null...
93	93	----> functions --query fish_user_key_bindings >/dev/null
6	55	--> if not set -q FISH_UNIT_TESTS_RUNNING...
5	5	---> not set -q FISH_UNIT_TESTS_RUNNING
4	4	---> function __fish_enable_bracketed_paste --on-event fish_prompt...
7	7	---> function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit...
5	5	---> status is-interactive
8	28	---> __fish_enable_bracketed_paste
20	20	----> printf "\e[?2004h"
1	4	--> if set -q TMUX...
3	3	---> set -q TMUX
5	36	--> if not set -q fish_handle_reflow...
4	4	---> not set -q fish_handle_reflow
5	27	---> if set -q VTE_VERSION...
3	3	----> set -q VTE_VERSION
8	8	----> string match -q -- 'alacritty*' $TERM
6	6	----> string match -q -- '*kitty' $TERM
5	5	----> set -g fish_handle_reflow 0
8	8	--> function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"...
5	140	--> if not set -q FISH_UNIT_TESTS_RUNNING...
4	4	---> not set -q FISH_UNIT_TESTS_RUNNING
4	16	---> begin...
6	6	----> string match -q -- 'foot*' $TERM
6	6	----> string match -q -- 'xterm-kitty*' $TERM
5	5	---> function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'...
8	110	---> __update_cwd_osc
2	8	----> if status --is-command-substitution...
3	3	-----> status --is-command-substitution
3	3	-----> set -q INSIDE_EMACS
85	94	----> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
9	9	-----> string escape --style=url $PWD
19	19	--> set __fish_initialized 3400
6	6	--> functions -e __fish_config_interactive
71	76	> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_mode_prompt.fish
5	5	-> function fish_mode_prompt --description "Displays the current mode"...
9	213	> fish_mode_prompt
55	204	-> fish_default_mode_prompt
122	127	--> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_default_mode_prompt.fish
5	5	---> function fish_default_mode_prompt --description "Display vi prompt mode"...
6	22	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
11	11	---> test "$fish_key_bindings" = fish_vi_key_bindings
5	5	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
171	177	> source /Users/max/.config/fish/functions/fish_prompt.fish
6	6	-> function fish_prompt --description 'Write out the prompt'...
33	362309	> fish_prompt
10	10	-> set -l last_status $status
50	105	-> set -l normal (set_color normal)
55	55	--> set_color normal
105	120	-> set -l status_color (set_color brgreen)
15	15	--> set_color brgreen
180	215	-> set -l cwd_color (set_color $fish_color_cwd)
35	35	--> set_color $fish_color_cwd
73	90	-> set -l vcs_color (set_color brpurple)
17	17	--> set_color brpurple
8	8	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
4	4	-> set -l suffix '❯'
3	205	-> if functions -q fish_is_root_user...
58	144	--> functions -q fish_is_root_user
80	86	---> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_is_root_user.fish
6	6	----> function fish_is_root_user --description "Check if the user is root"...
10	58	--> fish_is_root_user
2	35	---> if test "$EUID" = 0 2>/dev/null...
33	33	----> test "$EUID" = 0 2>/dev/null
1	9	---> if contains -- $USER root toor Administrator...
8	8	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
206	361484	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
42	638	--> prompt_login
128	136	---> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/prompt_login.fish
8	8	----> function prompt_login --description "display user name for the prompt"...
6	44	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
5	5	----> set -g __fish_machine
6	6	----> set -l debian_chroot $debian_chroot
1	17	----> if test -r /etc/debian_chroot...
16	16	-----> test -r /etc/debian_chroot
1	5	----> if set -q debian_chroot[1]...
4	4	-----> set -q debian_chroot[1]
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
206	400	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
13	13	----> set_color normal
11	11	----> set_color $color_host
53	150	----> prompt_hostname
69	75	-----> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/prompt_hostname.fish
6	6	------> function prompt_hostname --description 'short hostname for the prompt'...
22	22	-----> string replace -r -- "\..*" "" $hostname
8	8	----> set_color normal
50	467	--> prompt_pwd
181	186	---> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/prompt_pwd.fish
5	5	----> function prompt_pwd --description 'short CWD for the prompt'...
10	10	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
13	170	---> for path in $argv...
45	55	----> set -l realhome (string escape --style=regex -- ~)
10	10	-----> string escape --style=regex -- ~
60	81	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	21	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
49	360173	--> fish_vcs_prompt
64	69	---> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_vcs_prompt.fish
5	5	----> function fish_vcs_prompt --description "Print all vcs prompts"...
60	242709	---> fish_git_prompt $argv
1761	121608	----> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_git_prompt.fish
14	14	-----> function __fish_git_prompt_show_upstream --description "Helper function for fish_git_prompt"...
7	119718	-----> if string match -q Darwin -- (uname)...
92	61115	------> string match -q Darwin -- (uname)
61023	61023	-------> uname
170	58596	------> string match -q /usr/bin/git -- (command -s git)
58426	58426	-------> command -s git
10	10	-----> function fish_git_prompt --description "Prompt function for Git"...
2	2	-----> function __fish_git_prompt_informative_status...
11	11	-----> function __fish_git_prompt_operation_branch_bare --description "fish_git_prompt helper, returns the current Git operation and branch"...
2	2	-----> function __fish_git_prompt_set_char...
7	7	-----> function __fish_git_prompt_validate_chars --description "fish_git_prompt helper, checks char variables"...
2	2	-----> function __fish_git_prompt_set_color...
3	3	-----> function __fish_git_prompt_validate_colors --description "fish_git_prompt helper, checks color variables"...
15	15	-----> function __fish_git_prompt_reset -a type -a op -a var --description "Event handler, resets prompt when functionality changes" \
    --on-variable=__fish_git_prompt_{show_informative_status,use_informative_chars}...
39	39	-----> function __fish_git_prompt_reset_color -a type -a op -a var --description "Event handler, resets prompt when any color changes" \
    --on-variable=__fish_git_prompt_color{'',_prefix,_suffix,_bare,_merging,_cleanstate,_invalidstate,_upstream,_flags,_branch,_dirtystate,_stagedstate,_branch_detached,_stashstate,_untrackedfiles} --on-variable=__fish_git_prompt_showcolorhints...
24	24	-----> function __fish_git_prompt_reset_char -a type -a op -a var --description "Event handler, resets prompt when any char changes" \
    --on-variable=__fish_git_prompt_char_{cleanstate,dirtystate,invalidstate,stagedstate,stashstate,stateseparator,untrackedfiles,upstream_ahead,upstream_behind,upstream_diverged,upstream_equal,upstream_prefix}...
13	56437	----> if not command -sq git...
56424	56424	-----> not command -sq git
2	61	----> if functions -q __fish_git_prompt_ready...
59	59	-----> functions -q __fish_git_prompt_ready
125	64523	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
64398	64398	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
4	4	----> return
69	58194	---> fish_hg_prompt $argv
290	377	----> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_hg_prompt.fish
14	14	-----> set -g fish_color_hg_clean green
7	7	-----> set -g fish_color_hg_modified yellow
4	4	-----> set -g fish_color_hg_dirty red
4	4	-----> set -g fish_color_hg_added green
4	4	-----> set -g fish_color_hg_renamed magenta
4	4	-----> set -g fish_color_hg_copied magenta
3	3	-----> set -g fish_color_hg_deleted red
4	4	-----> set -g fish_color_hg_untracked yellow
4	4	-----> set -g fish_color_hg_unmerged red
5	5	-----> set -g fish_prompt_hg_status_added '✚'
5	5	-----> set -g fish_prompt_hg_status_modified '*'
4	4	-----> set -g fish_prompt_hg_status_copied '⇒'
5	5	-----> set -g fish_prompt_hg_status_deleted '✖'
4	4	-----> set -g fish_prompt_hg_status_untracked '?'
4	4	-----> set -g fish_prompt_hg_status_unmerged !
6	6	-----> set -g fish_prompt_hg_status_order added modified copied deleted untracked unmerged
6	6	-----> function fish_hg_prompt --description 'Write out the hg prompt'...
16	57748	----> if not command -sq hg...
57718	57718	-----> not command -sq hg
14	14	-----> return 1
82	59152	---> fish_fossil_prompt $argv
319	328	----> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_fossil_prompt.fish
9	9	-----> function fish_fossil_prompt --description 'Write out the fossil prompt'...
19	58742	----> if not command -sq fossil...
58706	58706	-----> not command -sq fossil
17	17	-----> return 1
17	17	-> echo -n -s $status_color $suffix ' ' $normal
168	172	> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_title.fish
4	4	-> function fish_title...
11	792	> fish_title
8	781	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
9	9	--> set -l ssh
3	3	--> set -q SSH_TTY
10	754	--> if set -q argv[1]...
4	4	---> set -q argv[1]
66	72	---> set -l command (status current-command)
6	6	----> status current-command
2	16	---> if test "$command" = fish...
9	9	----> test "$command" = fish
5	5	----> set command
135	652	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
23	509	----> prompt_pwd -d 1 -D 1
10	10	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	412	-----> for path in $argv...
61	72	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
36	62	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
10	264	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	165	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
49	141	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
44	92	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
48	48	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
58	76	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
60	106	> __fish_disable_bracketed_paste ls
46	46	-> printf "\e[?2004l"
93	2053	> fish_title ls
24	1960	-> if not set -q INSIDE_EMACS...
28	28	--> not set -q INSIDE_EMACS
18	18	--> set -l ssh
10	10	--> set -q SSH_TTY
11	1880	--> if set -q argv[1]...
11	11	---> set -q argv[1]
323	1858	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
38	38	----> string sub -l 20 -- $argv[1]
74	1497	----> prompt_pwd -d 1 -D 1
24	24	-----> set -l options h/help d/dir-length= D/full-length-dirs=
61	61	-----> argparse -n prompt_pwd $options -- $argv
4	16	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
9	9	-----> set -q argv[1]
18	18	-----> set argv $PWD
9	9	-----> set -ql _flag_d
18	18	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
49	1213	-----> for path in $argv...
158	203	------> set -l realhome (string escape --style=regex -- ~)
45	45	-------> string escape --style=regex -- ~
227	298	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
71	71	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
24	663	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
34	34	-------> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-------> set -l full
17	388	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
138	319	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
142	181	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
39	39	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
134	203	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
69	69	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
88	80135	> ls
80047	80047	-> eza -lha $argv
22	52	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
10	47	> fish_mode_prompt
11	37	-> fish_default_mode_prompt
3	26	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
17	17	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
35	209920	> fish_prompt
13	13	-> set -l last_status $status
39	50	-> set -l normal (set_color normal)
11	11	--> set_color normal
41	50	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
36	46	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
37	43	-> set -l vcs_color (set_color brpurple)
6	6	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	89	-> if functions -q fish_is_root_user...
7	7	--> functions -q fish_is_root_user
15	79	--> fish_is_root_user
2	49	---> if test "$EUID" = 0 2>/dev/null...
47	47	----> test "$EUID" = 0 2>/dev/null
1	11	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
155	209548	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	268	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
0	4	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
164	232	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
10	37	----> prompt_hostname
27	27	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
23	223	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
2	2	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
14	143	---> for path in $argv...
36	47	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
40	65	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
14	208902	--> fish_vcs_prompt
34	108514	---> fish_git_prompt $argv
10	50996	----> if not command -sq git...
50986	50986	-----> not command -sq git
2	33	----> if functions -q __fish_git_prompt_ready...
31	31	-----> functions -q __fish_git_prompt_ready
166	57428	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57262	57262	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
4	4	----> return
22	50048	---> fish_hg_prompt $argv
20	50026	----> if not command -sq hg...
49990	49990	-----> not command -sq hg
16	16	-----> return 1
30	50326	---> fish_fossil_prompt $argv
20	50296	----> if not command -sq fossil...
50260	50260	-----> not command -sq fossil
16	16	-----> return 1
19	19	-> echo -n -s $status_color $suffix ' ' $normal
14	728	> fish_title
8	714	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
15	689	--> if set -q argv[1]...
4	4	---> set -q argv[1]
39	45	---> set -l command (status current-command)
6	6	----> status current-command
2	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
5	5	----> set command
72	610	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
25	530	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
29	29	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
27	426	-----> for path in $argv...
40	55	------> set -l realhome (string escape --style=regex -- ~)
15	15	-------> string escape --style=regex -- ~
48	75	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	269	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
13	13	-------> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-------> set -l full
7	151	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
9	9	--------> test $fish_prompt_pwd_full_dirs -gt 0
46	123	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
56	77	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
21	21	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
64	88	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
24	24	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
307	10781	> source /usr/local/Cellar/fish/3.7.1/share/fish/completions/cat.fish
40	10474	-> if cat --version 2>/dev/null >/dev/null...
132	10270	--> cat --version 2>/dev/null >/dev/null
10138	10138	---> bat $argv
49	49	--> complete -c cat -s A -l show-all -d "Escape all unprintables"
16	16	--> complete -c cat -s b -l number-nonblank -d "Number non-blank lines"
15	15	--> complete -c cat -s e -d "Escape unprintables except \\t"
10	10	--> complete -c cat -s E -l show-ends -d "Display \$ at line end"
15	15	--> complete -c cat -s n -l number -d "Enumerate lines"
10	10	--> complete -c cat -s s -l squeeze-blank -d "Never >1 blank line"
8	8	--> complete -c cat -s t -d "Escape unprintables except \\n"
9	9	--> complete -c cat -s T -l show-tabs -d "Escape tab"
8	8	--> complete -c cat -s v -d "Escape unprintables except '\\n' and \\t"
8	8	--> complete -c cat -l help -d "Display help and exit"
16	16	--> complete -c cat -l version -d "Display version and exit"
1013	2088	> source /usr/local/share/fish/vendor_completions.d/bat.fish
21	21	-> set bat bat
7	7	-> function __bat_complete_files -a token...
9	9	-> function __bat_complete_one_language -a comp...
5	5	-> function __bat_complete_list_languages...
2	2	-> function __bat_complete_map_syntax...
2	2	-> function __bat_cache_subcommand...
2	2	-> function __bat_no_excl_args...
2	2	-> function __bat_cache_no_excl...
4	4	-> function __bat_style_opts...
15	15	-> set -l color_opts '
    auto\tdefault
    never\t
    always\t
'
16	16	-> set -l decorations_opts $color_opts
9	9	-> set -l paging_opts $color_opts
13	13	-> set -l pager_opts '
    less\tdefault
    less\ -FR\t
    more\t
    vimpager\t
'
9	9	-> set -l italic_text_opts '
    always\t
    never\tdefault
'
8	8	-> set -l wrap_opts '
    auto\tdefault
    never\t
    character\t
'
13	13	-> set -l tabs_opts '
    0\tpass\ tabs\ through\ directly
    1\t
    2\t
    4\t
    8\t
'
26	26	-> complete -c $bat -l acknowledgements -d "Print acknowledgements" -n __fish_is_first_arg
29	29	-> complete -c $bat -l color -x -a "$color_opts" -d "When to use colored output" -n __bat_no_excl_args
23	23	-> complete -c $bat -l config-dir -f -d "Display location of configuration directory" -n __fish_is_first_arg
17	17	-> complete -c $bat -l config-file -f -d "Display location of configuration file" -n __fish_is_first_arg
29	29	-> complete -c $bat -l decorations -x -a "$decorations_opts" -d "When to use --style decorations" -n __bat_no_excl_args
19	19	-> complete -c $bat -l diagnostic -d "Print diagnostic info for bug reports" -n __fish_is_first_arg
16	16	-> complete -c $bat -s d -l diff -d "Only show lines with Git changes" -n __bat_no_excl_args
23	23	-> complete -c $bat -l diff-context -x -d "Show N context lines around Git changes" -n "__fish_seen_argument -s d -l diff"
20	20	-> complete -c $bat -l file-name -x -d "Specify the display name" -n __bat_no_excl_args
18	18	-> complete -c $bat -s f -l force-colorization -d "Force color and decorations" -n __bat_no_excl_args
16	16	-> complete -c $bat -s h -d "Print a concise overview" -n __fish_is_first_arg
16	16	-> complete -c $bat -l help -f -d "Print all help information" -n __fish_is_first_arg
18	18	-> complete -c $bat -s H -l highlight-line -x -d "Highlight line(s) N[:M]" -n __bat_no_excl_args
16	16	-> complete -c $bat -l ignored-suffix -x -d "Ignore extension" -n __bat_no_excl_args
34	34	-> complete -c $bat -l italic-text -x -a "$italic_text_opts" -d "When to use italic text in the output" -n __bat_no_excl_args
29	29	-> complete -c $bat -s l -l language -x -k -a "(__bat_complete_list_languages)" -d "Set the syntax highlighting language" -n __bat_no_excl_args
20	20	-> complete -c $bat -l lessopen -d "Enable the $LESSOPEN preprocessor" -n __fish_is_first_arg
18	18	-> complete -c $bat -s r -l line-range -x -d "Only print lines [M]:[N] (either optional)" -n __bat_no_excl_args
17	17	-> complete -c $bat -l list-languages -f -d "List syntax highlighting languages" -n __fish_is_first_arg
16	16	-> complete -c $bat -l list-themes -f -d "List syntax highlighting themes" -n __fish_is_first_arg
30	30	-> complete -c $bat -s m -l map-syntax -x -a "(__bat_complete_map_syntax)" -d "Map <glob pattern>:<language syntax>" -n __bat_no_excl_args
19	19	-> complete -c $bat -s n -l number -d "Only show line numbers, no other decorations" -n __bat_no_excl_args
30	30	-> complete -c $bat -l pager -x -a "$pager_opts" -d "Which pager to use" -n __bat_no_excl_args
32	32	-> complete -c $bat -l paging -x -a "$paging_opts" -d "When to use the pager" -n __bat_no_excl_args
20	20	-> complete -c $bat -s p -l plain -d "Disable decorations" -n __bat_no_excl_args
20	20	-> complete -c $bat -o pp -d "Disable decorations and paging" -n __bat_no_excl_args
16	16	-> complete -c $bat -s P -d "Disable paging" -n __bat_no_excl_args
19	19	-> complete -c $bat -s A -l show-all -d "Show non-printable characters" -n __bat_no_excl_args
30	30	-> complete -c $bat -l style -x -k -a "(__fish_complete_list , __bat_style_opts)" -d "Specify which non-content elements to display" -n __bat_no_excl_args
30	30	-> complete -c $bat -l tabs -x -a "$tabs_opts" -d "Set tab width" -n __bat_no_excl_args
25	25	-> complete -c $bat -l terminal-width -x -d "Set terminal <width>, +<offset>, or -<offset>" -n __bat_no_excl_args
34	34	-> complete -c $bat -l theme -x -a "(command $bat --list-themes | command cat)" -d "Set the syntax highlighting theme" -n __bat_no_excl_args
19	19	-> complete -c $bat -s V -l version -f -d "Show version information" -n __fish_is_first_arg
26	26	-> complete -c $bat -l wrap -x -a "$wrap_opts" -d "Text-wrapping mode" -n __bat_no_excl_args
16	16	-> complete -c $bat -l build -f -d "Parse new definitions into cache" -n __bat_cache_no_excl
15	15	-> complete -c $bat -l clear -f -d "Reset definitions to defaults" -n __bat_cache_no_excl
24	24	-> complete -c $bat -l blank -f -d "Create new data instead of appending" -n "__bat_cache_subcommand; and not __fish_seen_argument -l clear"
34	34	-> complete -c $bat -l source -x -a "(__fish_complete_directories)" -d "Load syntaxes and themes from DIR" -n "__bat_cache_subcommand; and not __fish_seen_argument -l clear"
24	24	-> complete -c $bat -l target -x -a "(__fish_complete_directories)" -d "Store cache in DIR" -n __bat_cache_subcommand
17	17	-> complete -c $bat -l acknowledgements -d "Build acknowledgements.bin" -n __bat_cache_no_excl
20	20	-> complete -c $bat -s h -d "Print a concise overview of $bat-cache help" -n __bat_cache_no_excl
18	18	-> complete -c $bat -l help -f -d "Print all $bat-cache help" -n __bat_cache_no_excl
18	565	> __bat_cache_no_excl
14	547	-> __bat_cache_subcommand
140	533	--> __fish_seen_subcommand_from cache
155	168	---> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_seen_subcommand_from.fish
13	13	----> function __fish_seen_subcommand_from...
129	195	---> set -l cmd (commandline -poc)
66	66	----> commandline -poc
14	14	---> set -e cmd[1]
9	9	---> for i in $cmd...
7	7	---> return 1
21	201	> __bat_cache_subcommand
37	180	-> __fish_seen_subcommand_from cache
99	114	--> set -l cmd (commandline -poc)
15	15	---> commandline -poc
12	12	--> set -e cmd[1]
10	10	--> for i in $cmd...
7	7	--> return 1
15	226	> __bat_cache_subcommand
35	211	-> __fish_seen_subcommand_from cache
130	147	--> set -l cmd (commandline -poc)
17	17	---> commandline -poc
12	12	--> set -e cmd[1]
11	11	--> for i in $cmd...
6	6	--> return 1
20	979	> __bat_no_excl_args
13	236	-> not __bat_cache_subcommand
36	223	--> __fish_seen_subcommand_from cache
139	157	---> set -l cmd (commandline -poc)
18	18	----> commandline -poc
14	14	---> set -e cmd[1]
9	9	---> for i in $cmd...
7	7	---> return 1
169	723	-> not __fish_seen_argument \
        -s h -l help \
        -s V -l version \
        -l acknowledgements \
        -l config-dir -l config-file \
        -l diagnostic \
        -l list-languages -l list-themes
324	335	--> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_seen_argument.fish
11	11	---> function __fish_seen_argument --description 'Check whether argument is used'...
64	64	--> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
105	122	--> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
17	17	---> commandline --current-process --tokenize --cut-at-cursor
16	16	--> set --erase tokens[1]
10	10	--> for t in $tokens...
7	7	--> return 1
118	554	> __fish_is_first_arg
141	146	-> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_is_first_arg.fish
5	5	--> function __fish_is_first_arg...
120	133	-> set -l tokens (commandline -poc)
13	13	--> commandline -poc
127	157	-> test (count $tokens) -eq 1
30	30	--> count $tokens
38	226	> __fish_seen_argument -s d -l diff
44	44	-> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
99	119	-> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
20	20	--> commandline --current-process --tokenize --cut-at-cursor
10	10	-> set --erase tokens[1]
9	9	-> for t in $tokens...
6	6	-> return 1
21	151	> __bat_cache_no_excl
10	130	-> __bat_cache_subcommand
24	120	--> __fish_seen_subcommand_from cache
62	78	---> set -l cmd (commandline -poc)
16	16	----> commandline -poc
7	7	---> set -e cmd[1]
7	7	---> for i in $cmd...
4	4	---> return 1
7	77	> __bat_cache_subcommand
16	70	-> __fish_seen_subcommand_from cache
36	43	--> set -l cmd (commandline -poc)
7	7	---> commandline -poc
5	5	--> set -e cmd[1]
3	3	--> for i in $cmd...
3	3	--> return 1
6	70	> __bat_cache_subcommand
16	64	-> __fish_seen_subcommand_from cache
33	39	--> set -l cmd (commandline -poc)
6	6	---> commandline -poc
4	4	--> set -e cmd[1]
3	3	--> for i in $cmd...
2	2	--> return 1
8	214	> __bat_no_excl_args
8	80	-> not __bat_cache_subcommand
16	72	--> __fish_seen_subcommand_from cache
38	44	---> set -l cmd (commandline -poc)
6	6	----> commandline -poc
5	5	---> set -e cmd[1]
4	4	---> for i in $cmd...
3	3	---> return 1
27	126	-> not __fish_seen_argument \
        -s h -l help \
        -s V -l version \
        -l acknowledgements \
        -l config-dir -l config-file \
        -l diagnostic \
        -l list-languages -l list-themes
33	33	--> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
41	50	--> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
9	9	---> commandline --current-process --tokenize --cut-at-cursor
6	6	--> set --erase tokens[1]
6	6	--> for t in $tokens...
4	4	--> return 1
13	100	> __fish_is_first_arg
34	40	-> set -l tokens (commandline -poc)
6	6	--> commandline -poc
36	47	-> test (count $tokens) -eq 1
11	11	--> count $tokens
21	94	> __fish_seen_argument -s d -l diff
19	19	-> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
35	42	-> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
7	7	--> commandline --current-process --tokenize --cut-at-cursor
5	5	-> set --erase tokens[1]
4	4	-> for t in $tokens...
3	3	-> return 1
21	146	> __bat_cache_no_excl
10	125	-> __bat_cache_subcommand
23	115	--> __fish_seen_subcommand_from cache
60	74	---> set -l cmd (commandline -poc)
14	14	----> commandline -poc
7	7	---> set -e cmd[1]
7	7	---> for i in $cmd...
4	4	---> return 1
8	77	> __bat_cache_subcommand
14	69	-> __fish_seen_subcommand_from cache
36	43	--> set -l cmd (commandline -poc)
7	7	---> commandline -poc
5	5	--> set -e cmd[1]
4	4	--> for i in $cmd...
3	3	--> return 1
7	76	> __bat_cache_subcommand
13	69	-> __fish_seen_subcommand_from cache
38	44	--> set -l cmd (commandline -poc)
6	6	---> commandline -poc
5	5	--> set -e cmd[1]
4	4	--> for i in $cmd...
3	3	--> return 1
9	208	> __bat_no_excl_args
8	72	-> not __bat_cache_subcommand
13	64	--> __fish_seen_subcommand_from cache
34	39	---> set -l cmd (commandline -poc)
5	5	----> commandline -poc
5	5	---> set -e cmd[1]
4	4	---> for i in $cmd...
3	3	---> return 1
28	127	-> not __fish_seen_argument \
        -s h -l help \
        -s V -l version \
        -l acknowledgements \
        -l config-dir -l config-file \
        -l diagnostic \
        -l list-languages -l list-themes
37	37	--> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
40	48	--> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
8	8	---> commandline --current-process --tokenize --cut-at-cursor
5	5	--> set --erase tokens[1]
6	6	--> for t in $tokens...
3	3	--> return 1
12	100	> __fish_is_first_arg
34	39	-> set -l tokens (commandline -poc)
5	5	--> commandline -poc
38	49	-> test (count $tokens) -eq 1
11	11	--> count $tokens
20	93	> __fish_seen_argument -s d -l diff
18	18	-> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
35	42	-> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
7	7	--> commandline --current-process --tokenize --cut-at-cursor
5	5	-> set --erase tokens[1]
5	5	-> for t in $tokens...
3	3	-> return 1
25	152	> __bat_cache_no_excl
11	127	-> __bat_cache_subcommand
21	116	--> __fish_seen_subcommand_from cache
61	75	---> set -l cmd (commandline -poc)
14	14	----> commandline -poc
8	8	---> set -e cmd[1]
8	8	---> for i in $cmd...
4	4	---> return 1
8	81	> __bat_cache_subcommand
17	73	-> __fish_seen_subcommand_from cache
37	43	--> set -l cmd (commandline -poc)
6	6	---> commandline -poc
6	6	--> set -e cmd[1]
4	4	--> for i in $cmd...
3	3	--> return 1
7	71	> __bat_cache_subcommand
13	64	-> __fish_seen_subcommand_from cache
34	39	--> set -l cmd (commandline -poc)
5	5	---> commandline -poc
5	5	--> set -e cmd[1]
4	4	--> for i in $cmd...
3	3	--> return 1
8	223	> __bat_no_excl_args
8	79	-> not __bat_cache_subcommand
13	71	--> __fish_seen_subcommand_from cache
40	46	---> set -l cmd (commandline -poc)
6	6	----> commandline -poc
5	5	---> set -e cmd[1]
4	4	---> for i in $cmd...
3	3	---> return 1
28	136	-> not __fish_seen_argument \
        -s h -l help \
        -s V -l version \
        -l acknowledgements \
        -l config-dir -l config-file \
        -l diagnostic \
        -l list-languages -l list-themes
37	37	--> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
45	53	--> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
8	8	---> commandline --current-process --tokenize --cut-at-cursor
6	6	--> set --erase tokens[1]
6	6	--> for t in $tokens...
6	6	--> return 1
13	100	> __fish_is_first_arg
35	40	-> set -l tokens (commandline -poc)
5	5	--> commandline -poc
36	47	-> test (count $tokens) -eq 1
11	11	--> count $tokens
21	160	> __fish_seen_argument -s d -l diff
74	74	-> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
45	52	-> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
7	7	--> commandline --current-process --tokenize --cut-at-cursor
5	5	-> set --erase tokens[1]
5	5	-> for t in $tokens...
3	3	-> return 1
124	3266	> __fish_start_bracketed_paste
236	236	-> set -g __fish_last_bind_mode $fish_bind_mode
467	2906	-> string match -q 'single*' (__fish_tokenizer_state -- (commandline -ct | string collect))
813	2439	--> __fish_tokenizer_state -- (commandline -ct | string collect)
868	890	---> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_tokenizer_state.fish
22	22	----> function __fish_tokenizer_state --description "Print the state of the tokenizer at the end of the given string"...
259	259	---> commandline -ct | string collect
41	41	---> argparse --min-args 1 --max-args 1 i/initial-state= -- $argv
19	19	---> set -l state normal
5	15	---> if set -q _flag_initial_state...
10	10	----> set -q _flag_initial_state
167	262	---> for char in (string split -- "" $argv[1])...
25	25	----> string split -- "" $argv[1]
47	70	----> switch $char...
23	23	-----> switch $state...
140	140	---> echo $state
234	297	> __fish_stop_bracketed_paste
47	47	-> set fish_bind_mode $__fish_last_bind_mode
16	16	-> set -e __fish_paste_quoted
1385	1580	> source /usr/local/Cellar/fish/3.7.1/share/fish/completions/sort.fish
56	56	-> complete -c sort -s b -l ignore-leading-blanks -d "Ignore leading blanks"
12	12	-> complete -c sort -s d -l dictionary-order -d "Consider only blanks and alphanumerics"
7	7	-> complete -c sort -s f -l ignore-case -d "Ignore case"
7	7	-> complete -c sort -s g -l general-numeric-sort -d "Compare general numeric value"
7	7	-> complete -c sort -s i -l ignore-nonprinting -d "Consider only printable"
6	6	-> complete -c sort -s h -l human-numeric-sort -d "Compare human readable numbers [2K 1G]"
6	6	-> complete -c sort -s M -l month-sort -d "Compare month names"
6	6	-> complete -c sort -s n -l numeric-sort -d "Compare string numerical value"
6	6	-> complete -c sort -s R -l random-sort -d "Sort by random hash of keys"
5	5	-> complete -c sort -l random-source -d "Get random bytes from FILE"
6	6	-> complete -c sort -s r -l reverse -d "Reverse results"
6	6	-> complete -c sort -s c -l check -d "Only check if sorted"
6	6	-> complete -c sort -s k -l key -d "Define key"
6	6	-> complete -c sort -s m -l merge -d "Merge sorted files"
6	6	-> complete -c sort -s o -l output -f -d "Write to file"
6	6	-> complete -c sort -s s -l stable -d "Stabilize sort"
7	7	-> complete -c sort -s S -l buffer-size -r -d "Set memory buffer size"
6	6	-> complete -c sort -s t -l field-separator -d "Field separator"
7	7	-> complete -c sort -s T -l temporary-directory -r -d "Set temporary directory"
6	6	-> complete -c sort -s u -l unique -d "Output only first of equal lines"
5	5	-> complete -c sort -s z -l zero-terminated -d "Lines end with 0 byte"
5	5	-> complete -c sort -l help -d "Display help and exit"
5	5	-> complete -c sort -l version -d "Display version and exit"
145	432	> __fish_disable_bracketed_paste 'sort -nk 2 fish.prof'
287	287	-> printf "\e[?2004l"
50	2835	> fish_title sort\ -nk\ 2\ fish.prof
28	2785	-> if not set -q INSIDE_EMACS...
24	24	--> not set -q INSIDE_EMACS
18	18	--> set -l ssh
14	14	--> set -q SSH_TTY
42	2701	--> if set -q argv[1]...
15	15	---> set -q argv[1]
585	2644	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
44	44	----> string sub -l 20 -- $argv[1]
210	2015	----> prompt_pwd -d 1 -D 1
36	36	-----> set -l options h/help d/dir-length= D/full-length-dirs=
89	89	-----> argparse -n prompt_pwd $options -- $argv
6	26	-----> if set -q _flag_help...
20	20	------> set -q _flag_help
15	15	-----> set -q argv[1]
26	26	-----> set argv $PWD
10	10	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
17	17	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
52	1527	-----> for path in $argv...
285	329	------> set -l realhome (string escape --style=regex -- ~)
44	44	-------> string escape --style=regex -- ~
180	264	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
84	84	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
25	882	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
31	31	-------> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-------> set -l full
20	572	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
199	494	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
185	295	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
110	110	----------> math $fish_prompt_pwd_full_dirs - 1
25	25	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
174	240	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
66	66	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
76990	76990	> sort -nk 2 fish.prof
24	57	> __fish_enable_bracketed_paste
33	33	-> printf "\e[?2004h"
12	80	> fish_mode_prompt
37	68	-> fish_default_mode_prompt
6	31	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
25	251403	> fish_prompt
13	13	-> set -l last_status $status
42	76	-> set -l normal (set_color normal)
34	34	--> set_color normal
37	46	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
35	44	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	40	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	149	-> if functions -q fish_is_root_user...
50	50	--> functions -q fish_is_root_user
13	97	--> fish_is_root_user
2	36	---> if test "$EUID" = 0 2>/dev/null...
34	34	----> test "$EUID" = 0 2>/dev/null
2	44	---> if contains -- $USER root toor Administrator...
42	42	----> contains -- $USER root toor Administrator
4	4	---> return 1
6	121	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
88	97	--> set status_color (set_color $fish_color_error)
9	9	---> set_color $fish_color_error
11	11	--> set prompt_status $status_color "[" $last_status "]" $normal
145	250852	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
41	345	--> prompt_login
2	10	---> if not set -q __fish_machine...
8	8	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
175	278	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
44	71	----> prompt_hostname
27	27	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
22	220	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
16	141	---> for path in $argv...
38	51	----> set -l realhome (string escape --style=regex -- ~)
13	13	-----> string escape --style=regex -- ~
36	57	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
45	250142	--> fish_vcs_prompt
115	121659	---> fish_git_prompt $argv
12	54499	----> if not command -sq git...
54487	54487	-----> not command -sq git
5	83	----> if functions -q __fish_git_prompt_ready...
78	78	-----> functions -q __fish_git_prompt_ready
439	66843	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
66404	66404	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
96	96	----> test -n "$repo_info"
23	23	----> return
313	65758	---> fish_hg_prompt $argv
20	65445	----> if not command -sq hg...
65407	65407	-----> not command -sq hg
18	18	-----> return 1
75	62680	---> fish_fossil_prompt $argv
19	62605	----> if not command -sq fossil...
62573	62573	-----> not command -sq fossil
13	13	-----> return 1
19	19	-> echo -n -s $status_color $suffix ' ' $normal
11	603	> fish_title
7	592	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
3	3	--> set -q SSH_TTY
5	568	--> if set -q argv[1]...
4	4	---> set -q argv[1]
42	48	---> set -l command (status current-command)
6	6	----> status current-command
2	16	---> if test "$command" = fish...
9	9	----> test "$command" = fish
5	5	----> set command
63	495	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
25	424	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	329	-----> for path in $argv...
41	52	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
38	66	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
28	28	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	199	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
8	118	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	94	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	58	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
19	19	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	59	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
227	727	> up-or-search
256	277	-> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/up-or-search.fish
21	21	--> function up-or-search -d "Search back or move cursor up 1 line"...
4	18	-> if commandline --search-mode...
14	14	--> commandline --search-mode
2	8	-> if commandline --paging-mode...
6	6	--> commandline --paging-mode
163	177	-> set -l lineno (commandline -L)
14	14	--> commandline -L
10	20	-> switch $lineno...
10	10	--> commandline -f history-search-backward
203	267	> up-or-search
9	64	-> if commandline --search-mode...
44	44	--> commandline --search-mode
7	7	--> commandline -f history-search-backward
4	4	--> return
68	174	> up-or-search
34	106	-> if commandline --search-mode...
45	45	--> commandline --search-mode
18	18	--> commandline -f history-search-backward
9	9	--> return
38	68	> __fish_disable_bracketed_paste 'fish --profile=fish.prof'
30	30	-> printf "\e[?2004l"
26	1179	> fish_title fish\ --profile=fish.prof
16	1153	-> if not set -q INSIDE_EMACS...
13	13	--> not set -q INSIDE_EMACS
11	11	--> set -l ssh
7	7	--> set -q SSH_TTY
17	1106	--> if set -q argv[1]...
5	5	---> set -q argv[1]
157	1084	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
19	19	----> string sub -l 20 -- $argv[1]
47	908	----> prompt_pwd -d 1 -D 1
14	14	-----> set -l options h/help d/dir-length= D/full-length-dirs=
34	34	-----> argparse -n prompt_pwd $options -- $argv
3	11	-----> if set -q _flag_help...
8	8	------> set -q _flag_help
6	6	-----> set -q argv[1]
11	11	-----> set argv $PWD
6	6	-----> set -ql _flag_d
10	10	-----> set -l fish_prompt_pwd_dir_length $_flag_d
5	5	-----> set -q fish_prompt_pwd_dir_length
8	8	-----> set -l fulldirs 0
5	5	-----> set -ql _flag_D
10	10	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
5	5	-----> set -q fish_prompt_pwd_full_dirs
27	736	-----> for path in $argv...
93	113	------> set -l realhome (string escape --style=regex -- ~)
20	20	-------> string escape --style=regex -- ~
117	174	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
57	57	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
15	422	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
18	18	-------> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-------> set -l full
13	248	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
10	10	--------> test $fish_prompt_pwd_full_dirs -gt 0
92	198	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
75	106	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
31	31	----------> math $fish_prompt_pwd_full_dirs - 1
18	18	--------> set tmp $all[1]
9	9	--------> set full $all[2..]
87	133	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
46	46	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
9364043	9364043	> fish --profile=fish.prof
49	110	> __fish_enable_bracketed_paste
61	61	-> printf "\e[?2004h"
29	121	> fish_mode_prompt
22	92	-> fish_default_mode_prompt
12	70	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
43	43	---> test "$fish_key_bindings" = fish_vi_key_bindings
15	15	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
101	217127	> fish_prompt
35	35	-> set -l last_status $status
197	258	-> set -l normal (set_color normal)
61	61	--> set_color normal
255	286	-> set -l status_color (set_color brgreen)
31	31	--> set_color brgreen
163	198	-> set -l cwd_color (set_color $fish_color_cwd)
35	35	--> set_color $fish_color_cwd
126	150	-> set -l vcs_color (set_color brpurple)
24	24	--> set_color brpurple
15	15	-> set -l prompt_status ""
10	10	-> set -q fish_prompt_pwd_dir_length
24	24	-> set -lx fish_prompt_pwd_dir_length 0
12	12	-> set -l suffix '❯'
6	226	-> if functions -q fish_is_root_user...
25	25	--> functions -q fish_is_root_user
30	195	--> fish_is_root_user
4	132	---> if test "$EUID" = 0 2>/dev/null...
128	128	----> test "$EUID" = 0 2>/dev/null
3	25	---> if contains -- $USER root toor Administrator...
22	22	----> contains -- $USER root toor Administrator
8	8	---> return 1
3	19	-> if test $last_status -ne 0...
16	16	--> test $last_status -ne 0
440	215776	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
43	1164	--> prompt_login
4	14	---> if not set -q __fish_machine...
10	10	----> not set -q __fish_machine
2	11	---> if set -q __fish_machine[1]...
9	9	----> set -q __fish_machine[1]
18	18	---> set -l color_host $fish_color_host
2	10	---> if set -q SSH_TTY...
8	8	----> set -q SSH_TTY
807	1068	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
26	26	----> set_color $fish_color_user
32	32	----> set_color normal
29	29	----> set_color $color_host
49	143	----> prompt_hostname
94	94	-----> string replace -r -- "\..*" "" $hostname
31	31	----> set_color normal
67	601	--> prompt_pwd
26	26	---> set -l options h/help d/dir-length= D/full-length-dirs=
35	35	---> argparse -n prompt_pwd $options -- $argv
4	14	---> if set -q _flag_help...
10	10	----> set -q _flag_help
8	8	---> set -q argv[1]
14	14	---> set argv $PWD
7	7	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
17	17	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
8	8	---> set -q fish_prompt_pwd_full_dirs
11	11	---> set -l fish_prompt_pwd_full_dirs 1
35	379	---> for path in $argv...
106	132	----> set -l realhome (string escape --style=regex -- ~)
26	26	-----> string escape --style=regex -- ~
106	167	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
61	61	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	45	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
21	21	-----> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-----> echo $tmp
82	213571	--> fish_vcs_prompt
82	115471	---> fish_git_prompt $argv
11	59371	----> if not command -sq git...
59360	59360	-----> not command -sq git
3	33	----> if functions -q __fish_git_prompt_ready...
30	30	-----> functions -q __fish_git_prompt_ready
133	55965	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
55832	55832	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
4	4	----> return
23	49345	---> fish_hg_prompt $argv
19	49322	----> if not command -sq hg...
49287	49287	-----> not command -sq hg
16	16	-----> return 1
31	48673	---> fish_fossil_prompt $argv
20	48642	----> if not command -sq fossil...
48605	48605	-----> not command -sq fossil
17	17	-----> return 1
17	17	-> echo -n -s $status_color $suffix ' ' $normal
12	760	> fish_title
8	748	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
7	722	--> if set -q argv[1]...
4	4	---> set -q argv[1]
39	50	---> set -l command (status current-command)
11	11	----> status current-command
3	16	---> if test "$command" = fish...
9	9	----> test "$command" = fish
4	4	----> set command
105	645	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
31	531	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
7	7	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
20	423	-----> for path in $argv...
41	52	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
49	83	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
34	34	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
20	268	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
13	13	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
10	144	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
51	116	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	65	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
23	23	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
66	86	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
72	163	> __fish_disable_bracketed_paste ls
91	91	-> printf "\e[?2004l"
32	3305	> fish_title ls
48	3273	-> if not set -q INSIDE_EMACS...
21	21	--> not set -q INSIDE_EMACS
24	24	--> set -l ssh
15	15	--> set -q SSH_TTY
40	3165	--> if set -q argv[1]...
15	15	---> set -q argv[1]
587	3110	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
44	44	----> string sub -l 20 -- $argv[1]
131	2479	----> prompt_pwd -d 1 -D 1
86	86	-----> set -l options h/help d/dir-length= D/full-length-dirs=
110	110	-----> argparse -n prompt_pwd $options -- $argv
7	27	-----> if set -q _flag_help...
20	20	------> set -q _flag_help
15	15	-----> set -q argv[1]
27	27	-----> set argv $PWD
14	14	-----> set -ql _flag_d
28	28	-----> set -l fish_prompt_pwd_dir_length $_flag_d
15	15	-----> set -q fish_prompt_pwd_dir_length
19	19	-----> set -l fulldirs 0
12	12	-----> set -ql _flag_D
24	24	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
14	14	-----> set -q fish_prompt_pwd_full_dirs
71	1957	-----> for path in $argv...
284	332	------> set -l realhome (string escape --style=regex -- ~)
48	48	-------> string escape --style=regex -- ~
313	449	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
136	136	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
39	1105	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
50	50	-------> test "$fish_prompt_pwd_dir_length" -eq 0
21	21	-------> set -l full
50	717	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
25	25	--------> test $fish_prompt_pwd_full_dirs -gt 0
271	596	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
264	325	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
61	61	----------> math $fish_prompt_pwd_full_dirs - 1
30	30	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
212	278	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
66	66	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
88	89351	> ls
89263	89263	-> eza -lha $argv
27	59	> __fish_enable_bracketed_paste
32	32	-> printf "\e[?2004h"
12	56	> fish_mode_prompt
11	44	-> fish_default_mode_prompt
3	33	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
23	23	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
28	216882	> fish_prompt
13	13	-> set -l last_status $status
39	51	-> set -l normal (set_color normal)
12	12	--> set_color normal
43	51	-> set -l status_color (set_color brgreen)
8	8	--> set_color brgreen
35	44	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	40	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
2	76	-> if functions -q fish_is_root_user...
8	8	--> functions -q fish_is_root_user
12	66	--> fish_is_root_user
1	39	---> if test "$EUID" = 0 2>/dev/null...
38	38	----> test "$EUID" = 0 2>/dev/null
1	12	---> if contains -- $USER root toor Administrator...
11	11	----> contains -- $USER root toor Administrator
3	3	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
233	216534	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
16	262	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
155	222	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
6	6	----> set_color normal
7	7	----> set_color $color_host
10	37	----> prompt_hostname
27	27	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
22	211	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
13	132	---> for path in $argv...
36	47	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
35	55	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
16	215828	--> fish_vcs_prompt
31	109899	---> fish_git_prompt $argv
14	50212	----> if not command -sq git...
50198	50198	-----> not command -sq git
2	33	----> if functions -q __fish_git_prompt_ready...
31	31	-----> functions -q __fish_git_prompt_ready
121	59605	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
59484	59484	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
15	15	----> test -n "$repo_info"
3	3	----> return
24	55857	---> fish_hg_prompt $argv
20	55833	----> if not command -sq hg...
55790	55790	-----> not command -sq hg
23	23	-----> return 1
33	50056	---> fish_fossil_prompt $argv
20	50023	----> if not command -sq fossil...
49986	49986	-----> not command -sq fossil
17	17	-----> return 1
17	17	-> echo -n -s $status_color $suffix ' ' $normal
13	916	> fish_title
7	903	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
9	879	--> if set -q argv[1]...
4	4	---> set -q argv[1]
38	48	---> set -l command (status current-command)
10	10	----> status current-command
4	17	---> if test "$command" = fish...
9	9	----> test "$command" = fish
4	4	----> set command
140	801	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
36	653	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	543	-----> for path in $argv...
42	54	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
41	70	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
29	29	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	406	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
14	289	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
179	253	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
48	74	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
26	26	----------> math $fish_prompt_pwd_full_dirs - 1
11	11	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
57	95	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
38	38	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
72	208	> __fish_disable_bracketed_paste 'sort -nk 2 fish.prof'
136	136	-> printf "\e[?2004l"
42	2181	> fish_title sort\ -nk\ 2\ fish.prof
26	2139	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
11	11	--> set -q SSH_TTY
20	2064	--> if set -q argv[1]...
11	11	---> set -q argv[1]
364	2033	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
39	39	----> string sub -l 20 -- $argv[1]
197	1630	----> prompt_pwd -d 1 -D 1
37	37	-----> set -l options h/help d/dir-length= D/full-length-dirs=
70	70	-----> argparse -n prompt_pwd $options -- $argv
4	18	-----> if set -q _flag_help...
14	14	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
45	1195	-----> for path in $argv...
161	201	------> set -l realhome (string escape --style=regex -- ~)
40	40	-------> string escape --style=regex -- ~
134	205	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
71	71	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
30	744	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
12	12	-------> set -l full
21	407	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
115	336	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
121	221	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
100	100	----------> math $fish_prompt_pwd_full_dirs - 1
19	19	--------> set tmp $all[1]
14	14	--------> set full $all[2..]
218	267	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
49	49	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
72143	72143	> sort -nk 2 fish.prof
22	52	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
12	82	> fish_mode_prompt
36	70	-> fish_default_mode_prompt
4	34	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
24	24	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
30	206554	> fish_prompt
15	15	-> set -l last_status $status
41	74	-> set -l normal (set_color normal)
33	33	--> set_color normal
38	47	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
36	45	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	40	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	150	-> if functions -q fish_is_root_user...
50	50	--> functions -q fish_is_root_user
15	98	--> fish_is_root_user
2	45	---> if test "$EUID" = 0 2>/dev/null...
43	43	----> test "$EUID" = 0 2>/dev/null
2	34	---> if contains -- $USER root toor Administrator...
32	32	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
174	206106	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
37	325	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
2	5	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
166	264	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
33	64	----> prompt_hostname
31	31	-----> string replace -r -- "\..*" "" $hostname
8	8	----> set_color normal
20	215	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
15	137	---> for path in $argv...
39	50	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
37	56	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
19	19	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	16	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
55	205392	--> fish_vcs_prompt
50	106676	---> fish_git_prompt $argv
11	50838	----> if not command -sq git...
50827	50827	-----> not command -sq git
3	70	----> if functions -q __fish_git_prompt_ready...
67	67	-----> functions -q __fish_git_prompt_ready
163	55697	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
55534	55534	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
4	4	----> return
64	49285	---> fish_hg_prompt $argv
19	49221	----> if not command -sq hg...
49187	49187	-----> not command -sq hg
15	15	-----> return 1
80	49376	---> fish_fossil_prompt $argv
16	49296	----> if not command -sq fossil...
49266	49266	-----> not command -sq fossil
14	14	-----> return 1
19	19	-> echo -n -s $status_color $suffix ' ' $normal
11	630	> fish_title
9	619	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
4	4	--> set -q SSH_TTY
6	591	--> if set -q argv[1]...
4	4	---> set -q argv[1]
46	52	---> set -l command (status current-command)
6	6	----> status current-command
2	15	---> if test "$command" = fish...
9	9	----> test "$command" = fish
4	4	----> set command
66	514	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
22	440	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
31	343	-----> for path in $argv...
39	49	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
36	66	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
30	30	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	197	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
5	120	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	99	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	59	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
19	19	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
39	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
78	277	> __fish_disable_bracketed_paste __fish_on_interactive
199	199	-> printf "\e[?2004l"
-103154	2609	> fish_title __fish_on_interactive
34	2559	-> if not set -q INSIDE_EMACS...
32	32	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
16	16	--> set -q SSH_TTY
21	2452	--> if set -q argv[1]...
16	16	---> set -q argv[1]
552	2415	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
48	48	----> string sub -l 20 -- $argv[1]
187	1815	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	-----> argparse -n prompt_pwd $options -- $argv
5	17	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
11	11	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
18	18	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
52	1399	-----> for path in $argv...
179	211	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
161	233	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
72	72	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
32	903	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
20	588	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
170	514	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
219	344	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
125	125	----------> math $fish_prompt_pwd_full_dirs - 1
22	22	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
188	241	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
53	53	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
269	102993	-> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_command_not_found.fish
15	15	--> set -l os
2	18	--> if test -r /etc/os-release...
16	16	---> test -r /etc/os-release
7	7	--> function __fish_default_command_not_found_handler...
39	102684	--> if functions -q __fish_command_not_found_handler...
54	54	---> functions -q __fish_command_not_found_handler
23	23	---> contains -- suse $os
4	4	---> contains -- sles $os
8	8	---> test -f /usr/libexec/pk-command-not-found
6	6	---> test -f /usr/lib/command-not-found
6	6	---> test -f /run/current-system/sw/bin/command-not-found
51140	51140	---> type -q command-not-found
51389	51389	---> type -q pkgfile
15	15	---> function fish_command_not_found --on-event fish_command_not_found...
20	211	-> fish_command_not_found __fish_on_interactive
18	191	--> __fish_default_command_not_found_handler $argv
141	173	---> printf (_ "fish: Unknown command: %s\n") (string escape -- $argv[1]) >&2
20	20	----> _ "fish: Unknown command: %s\n"
12	12	----> string escape -- $argv[1]
10	22	> __fish_enable_bracketed_paste
12	12	-> printf "\e[?2004h"
8	59	> fish_mode_prompt
30	51	-> fish_default_mode_prompt
3	21	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
12	12	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
24	212454	> fish_prompt
12	12	-> set -l last_status $status
40	67	-> set -l normal (set_color normal)
27	27	--> set_color normal
37	46	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
34	43	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	40	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
4	4	-> set -l suffix '❯'
3	101	-> if functions -q fish_is_root_user...
30	30	--> functions -q fish_is_root_user
11	68	--> fish_is_root_user
1	44	---> if test "$EUID" = 0 2>/dev/null...
43	43	----> test "$EUID" = 0 2>/dev/null
2	10	---> if contains -- $USER root toor Administrator...
8	8	----> contains -- $USER root toor Administrator
3	3	---> return 1
4	68	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
37	46	--> set status_color (set_color $fish_color_error)
9	9	---> set_color $fish_color_error
11	11	--> set prompt_status $status_color "[" $last_status "]" $normal
131	212019	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
37	301	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	4	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
154	242	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
14	14	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
31	53	----> prompt_hostname
22	22	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
22	205	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
2	2	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
13	129	---> for path in $argv...
35	46	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
36	54	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
18	18	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	16	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
35	211382	--> fish_vcs_prompt
39	109819	---> fish_git_prompt $argv
11	52168	----> if not command -sq git...
52157	52157	-----> not command -sq git
3	70	----> if functions -q __fish_git_prompt_ready...
67	67	-----> functions -q __fish_git_prompt_ready
132	57521	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57389	57389	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
4	4	----> return
60	51109	---> fish_hg_prompt $argv
18	51049	----> if not command -sq hg...
51015	51015	-----> not command -sq hg
16	16	-----> return 1
76	50419	---> fish_fossil_prompt $argv
17	50343	----> if not command -sq fossil...
50313	50313	-----> not command -sq fossil
13	13	-----> return 1
15	15	-> echo -n -s $status_color $suffix ' ' $normal
11	598	> fish_title
8	587	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
4	4	--> set -q SSH_TTY
5	562	--> if set -q argv[1]...
3	3	---> set -q argv[1]
40	45	---> set -l command (status current-command)
5	5	----> status current-command
2	16	---> if test "$command" = fish...
9	9	----> test "$command" = fish
5	5	----> set command
64	493	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
30	421	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
3	6	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	319	-----> for path in $argv...
42	53	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
36	65	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
29	29	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	187	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	110	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	87	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
37	50	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
41	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
150	235	> __fish_enable_bracketed_paste
85	85	-> printf "\e[?2004h"
43	199	> fish_mode_prompt
43	156	-> fish_default_mode_prompt
26	113	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
59	59	---> test "$fish_key_bindings" = fish_vi_key_bindings
28	28	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
184	225990	> fish_prompt
147	147	-> set -l last_status $status
189	239	-> set -l normal (set_color normal)
50	50	--> set_color normal
173	199	-> set -l status_color (set_color brgreen)
26	26	--> set_color brgreen
210	250	-> set -l cwd_color (set_color $fish_color_cwd)
40	40	--> set_color $fish_color_cwd
205	301	-> set -l vcs_color (set_color brpurple)
96	96	--> set_color brpurple
26	26	-> set -l prompt_status ""
13	13	-> set -q fish_prompt_pwd_dir_length
15	15	-> set -lx fish_prompt_pwd_dir_length 0
15	15	-> set -l suffix '❯'
7	238	-> if functions -q fish_is_root_user...
28	28	--> functions -q fish_is_root_user
34	203	--> fish_is_root_user
5	130	---> if test "$EUID" = 0 2>/dev/null...
125	125	----> test "$EUID" = 0 2>/dev/null
3	29	---> if contains -- $USER root toor Administrator...
26	26	----> contains -- $USER root toor Administrator
10	10	---> return 1
12	235	-> if test $last_status -ne 0...
19	19	--> test $last_status -ne 0
140	171	--> set status_color (set_color $fish_color_error)
31	31	---> set_color $fish_color_error
33	33	--> set prompt_status $status_color "[" $last_status "]" $normal
422	224110	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
42	1341	--> prompt_login
5	17	---> if not set -q __fish_machine...
12	12	----> not set -q __fish_machine
4	14	---> if set -q __fish_machine[1]...
10	10	----> set -q __fish_machine[1]
21	21	---> set -l color_host $fish_color_host
2	12	---> if set -q SSH_TTY...
10	10	----> set -q SSH_TTY
892	1235	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
24	24	----> set_color $fish_color_user
35	35	----> set_color normal
121	121	----> set_color $color_host
48	124	----> prompt_hostname
76	76	-----> string replace -r -- "\..*" "" $hostname
39	39	----> set_color normal
78	964	--> prompt_pwd
35	35	---> set -l options h/help d/dir-length= D/full-length-dirs=
47	47	---> argparse -n prompt_pwd $options -- $argv
4	18	---> if set -q _flag_help...
14	14	----> set -q _flag_help
10	10	---> set -q argv[1]
18	18	---> set argv $PWD
8	8	---> set -ql _flag_d
10	10	---> set -q fish_prompt_pwd_dir_length
14	14	---> set -l fulldirs 0
8	8	---> set -ql _flag_D
11	11	---> set -q fish_prompt_pwd_full_dirs
13	13	---> set -l fish_prompt_pwd_full_dirs 1
126	694	---> for path in $argv...
215	260	----> set -l realhome (string escape --style=regex -- ~)
45	45	-----> string escape --style=regex -- ~
183	247	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
64	64	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
15	61	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
26	26	-----> test "$fish_prompt_pwd_dir_length" -eq 0
20	20	-----> echo $tmp
27	221383	--> fish_vcs_prompt
38	121304	---> fish_git_prompt $argv
10	63895	----> if not command -sq git...
63885	63885	-----> not command -sq git
2	25	----> if functions -q __fish_git_prompt_ready...
23	23	-----> functions -q __fish_git_prompt_ready
124	57326	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57202	57202	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
4	4	----> return
22	49789	---> fish_hg_prompt $argv
18	49767	----> if not command -sq hg...
49736	49736	-----> not command -sq hg
13	13	-----> return 1
27	50263	---> fish_fossil_prompt $argv
19	50236	----> if not command -sq fossil...
50201	50201	-----> not command -sq fossil
16	16	-----> return 1
18	18	-> echo -n -s $status_color $suffix ' ' $normal
12	599	> fish_title
7	587	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
7	563	--> if set -q argv[1]...
4	4	---> set -q argv[1]
38	45	---> set -l command (status current-command)
7	7	----> status current-command
4	16	---> if test "$command" = fish...
8	8	----> test "$command" = fish
4	4	----> set command
66	491	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
26	418	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
25	25	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	316	-----> for path in $argv...
39	51	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
38	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	189	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	112	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	89	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	53	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
38	56	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
260	452	> source /usr/local/Cellar/fish/3.7.1/share/fish/completions/fish.fish
48	48	-> complete -c fish -s c -l command -d "Run specified command instead of interactive session" -x -a "(__fish_complete_command)"
18	18	-> complete -c fish -s C -l init-command -d "Run specified command before session" -x -a "(__fish_complete_command)"
7	7	-> complete -c fish -s h -l help -d "Display help and exit"
6	6	-> complete -c fish -s v -l version -d "Display version and exit"
7	7	-> complete -c fish -s N -l no-config -d "Do not read configuration files"
6	6	-> complete -c fish -s n -l no-execute -d "Only parse input, do not execute"
6	6	-> complete -c fish -s i -l interactive -d "Run in interactive mode"
6	6	-> complete -c fish -s l -l login -d "Run as a login shell"
8	8	-> complete -c fish -s p -l profile -d "Output profiling information (excluding startup) to a file" -r
9	9	-> complete -c fish -l profile-startup -d "Output startup profiling information to a file" -r
19	19	-> complete -c fish -s d -l debug -d "Specify debug categories" -x -a "(fish --print-debug-categories | string replace ' ' \t)"
7	7	-> complete -c fish -s o -l debug-output -d "Where to direct debug output to" -rF
6	6	-> complete -c fish -s P -l private -d "Do not persist history"
4	4	-> function __fish_complete_features...
13	13	-> complete -c fish -s f -l features -d "Run with comma-separated feature flags enabled" -a "(__fish_complete_features)" -x
6	6	-> complete -c fish -l print-rusage-self -d "Print stats from getrusage at exit" -f
5	5	-> complete -c fish -l print-debug-categories -d "Print the debug categories fish knows" -f
11	11	-> complete -c fish -k -x -a "(__fish_complete_suffix .fish)"
184	336661	> __fish_describe_command so
185	55660	-> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_describe_command.fish
11	55458	--> if not type -q apropos...
55447	55447	---> not type -q apropos
17	17	--> function __fish_describe_command -d "Command used to find descriptions for commands"...
134	149	-> set -l argv_regex (string escape --style=regex -- "$argv")
15	15	--> string escape --style=regex -- "$argv"
49799	280668	-> __fish_apropos ^$argv 2>/dev/null | awk -v FS=" +- +" '{
		split($1, names, ", ");
		for (name in names)
			if (names[name] ~ /^'"$argv_regex"'.* *\([18]\)/ ) {
				sub( "( |\t)*\\\([18]\\\)", "", names[name] );
				sub( " \\\[.*\\\]", "", names[name] );
				print names[name] "\t" $2;
			}
	}'
210	154122	--> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_apropos.fish
12	49563	---> if not type -q apropos...
49551	49551	----> not type -q apropos
119	50959	---> set -l sysver (uname -sr | string match -r "(Darwin) (\d\d)"\.)
50840	50840	----> uname -sr | string match -r "(Darwin) (\d\d)"\.
22	53390	---> if test $status -eq 0 -a (count $sysver) -eq 3...
64	120	----> test $status -eq 0 -a (count $sysver) -eq 3
56	56	-----> count $sysver
14	14	----> test $sysver[2] = Darwin -a $sysver[3] -ge 19
15	15	----> test -x /usr/libexec/makewhatis
7	7	----> set -l dir
5	53205	----> if test -n "$XDG_CACHE_HOME"...
6	6	-----> test -n "$XDG_CACHE_HOME"
80	53194	-----> set dir (getconf DARWIN_USER_CACHE_DIR)"fish"
53114	53114	------> getconf DARWIN_USER_CACHE_DIR
7	7	----> function __fish_apropos -V dir...
23	23	--> set -l whatis $dir/whatis
6	6	--> set -l max_age 600000
7	7	--> set -l age $max_age
8	178	--> if test -f "$whatis"...
28	28	---> test -f "$whatis"
61	142	---> set age (path mtime -R -- $whatis)
81	81	----> path mtime -R -- $whatis
76422	76422	--> MANPATH="$dir" apropos "$argv"
5	111	--> if test $age -ge $max_age...
106	106	---> test $age -ge $max_age
63	191	> __fish_disable_bracketed_paste 'fish --profile=fish.prof; sort -nk 2 fish.prof'
128	128	-> printf "\e[?2004l"
44	2277	> fish_title fish\ --profile=fish.prof\;\ sort\ -nk\ 2\ fish.prof
25	2233	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
19	2157	--> if set -q argv[1]...
11	11	---> set -q argv[1]
414	2127	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
32	32	----> string sub -l 20 -- $argv[1]
173	1681	----> prompt_pwd -d 1 -D 1
34	34	-----> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
11	11	-----> set -q argv[1]
19	19	-----> set argv $PWD
10	10	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
14	14	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
41	1272	-----> for path in $argv...
113	145	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
158	270	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
112	112	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
32	816	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
34	34	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
16	455	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
146	384	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
133	238	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
105	105	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
221	280	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
59	59	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
3907593	3907593	> fish --profile=fish.prof
71098	71098	> sort -nk 2 fish.prof
26	57	> __fish_enable_bracketed_paste
31	31	-> printf "\e[?2004h"
13	96	> fish_mode_prompt
46	83	-> fish_default_mode_prompt
9	37	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
22	22	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
35	209781	> fish_prompt
13	13	-> set -l last_status $status
57	88	-> set -l normal (set_color normal)
31	31	--> set_color normal
56	74	-> set -l status_color (set_color brgreen)
18	18	--> set_color brgreen
40	52	-> set -l cwd_color (set_color $fish_color_cwd)
12	12	--> set_color $fish_color_cwd
38	45	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
2	164	-> if functions -q fish_is_root_user...
71	71	--> functions -q fish_is_root_user
14	91	--> fish_is_root_user
1	43	---> if test "$EUID" = 0 2>/dev/null...
42	42	----> test "$EUID" = 0 2>/dev/null
3	30	---> if contains -- $USER root toor Administrator...
27	27	----> contains -- $USER root toor Administrator
4	4	---> return 1
2	9	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
160	209264	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
42	338	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
173	271	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
37	65	----> prompt_hostname
28	28	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
22	262	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
2	5	---> if set -q _flag_help...
3	3	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
23	183	---> for path in $argv...
39	50	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
59	78	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
19	19	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	32	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
19	19	-----> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-----> echo $tmp
47	208504	--> fish_vcs_prompt
45	109212	---> fish_git_prompt $argv
11	51960	----> if not command -sq git...
51949	51949	-----> not command -sq git
3	76	----> if functions -q __fish_git_prompt_ready...
73	73	-----> functions -q __fish_git_prompt_ready
125	57111	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56986	56986	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
3	3	----> return
54	49394	---> fish_hg_prompt $argv
20	49340	----> if not command -sq hg...
49305	49305	-----> not command -sq hg
15	15	-----> return 1
97	49851	---> fish_fossil_prompt $argv
20	49754	----> if not command -sq fossil...
49718	49718	-----> not command -sq fossil
16	16	-----> return 1
16	16	-> echo -n -s $status_color $suffix ' ' $normal
15	732	> fish_title
7	717	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
6	692	--> if set -q argv[1]...
4	4	---> set -q argv[1]
44	70	---> set -l command (status current-command)
26	26	----> status current-command
2	16	---> if test "$command" = fish...
9	9	----> test "$command" = fish
5	5	----> set command
120	596	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
10	10	----> string sub -l 20 -- $command
36	466	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
16	354	-----> for path in $argv...
40	52	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
38	70	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
32	32	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	216	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	116	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	93	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	57	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
19	19	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
59	77	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
54	202	> __fish_disable_bracketed_paste ff
148	148	-> printf "\e[?2004l"
34	2072	> fish_title ff
30	2038	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
20	1958	--> if set -q argv[1]...
11	11	---> set -q argv[1]
365	1927	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
34	34	----> string sub -l 20 -- $argv[1]
147	1528	----> prompt_pwd -d 1 -D 1
25	25	-----> set -l options h/help d/dir-length= D/full-length-dirs=
83	83	-----> argparse -n prompt_pwd $options -- $argv
4	29	-----> if set -q _flag_help...
25	25	------> set -q _flag_help
16	16	-----> set -q argv[1]
18	18	-----> set argv $PWD
10	10	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
42	1127	-----> for path in $argv...
139	171	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
144	219	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
75	75	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
42	695	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
19	399	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
119	331	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
119	212	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
93	93	----------> math $fish_prompt_pwd_full_dirs - 1
19	19	--------> set tmp $all[1]
14	14	--------> set full $all[2..]
162	212	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
50	50	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
86	352328	> ff
352242	352242	-> fastfetch $argv
25	54	> __fish_enable_bracketed_paste
29	29	-> printf "\e[?2004h"
13	82	> fish_mode_prompt
37	69	-> fish_default_mode_prompt
4	32	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
22	22	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
33	213204	> fish_prompt
15	15	-> set -l last_status $status
41	72	-> set -l normal (set_color normal)
31	31	--> set_color normal
36	45	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
35	44	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	40	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
7	7	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	191	-> if functions -q fish_is_root_user...
55	55	--> functions -q fish_is_root_user
26	134	--> fish_is_root_user
1	74	---> if test "$EUID" = 0 2>/dev/null...
73	73	----> test "$EUID" = 0 2>/dev/null
2	31	---> if contains -- $USER root toor Administrator...
29	29	----> contains -- $USER root toor Administrator
3	3	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
169	212715	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
39	444	--> prompt_login
3	22	---> if not set -q __fish_machine...
19	19	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
226	367	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
14	14	----> set_color normal
12	12	----> set_color $color_host
58	95	----> prompt_hostname
37	37	-----> string replace -r -- "\..*" "" $hostname
9	9	----> set_color normal
25	335	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
40	244	---> for path in $argv...
44	56	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
88	126	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
38	38	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	22	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
88	211767	--> fish_vcs_prompt
51	109180	---> fish_git_prompt $argv
11	51809	----> if not command -sq git...
51798	51798	-----> not command -sq git
4	75	----> if functions -q __fish_git_prompt_ready...
71	71	-----> functions -q __fish_git_prompt_ready
129	57226	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57097	57097	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
3	3	----> return
56	51954	---> fish_hg_prompt $argv
21	51898	----> if not command -sq hg...
51861	51861	-----> not command -sq hg
16	16	-----> return 1
82	50545	---> fish_fossil_prompt $argv
18	50463	----> if not command -sq fossil...
50429	50429	-----> not command -sq fossil
16	16	-----> return 1
20	20	-> echo -n -s $status_color $suffix ' ' $normal
11	674	> fish_title
8	663	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
6	638	--> if set -q argv[1]...
4	4	---> set -q argv[1]
40	48	---> set -l command (status current-command)
8	8	----> status current-command
2	16	---> if test "$command" = fish...
9	9	----> test "$command" = fish
5	5	----> set command
67	564	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
26	489	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
8	8	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
17	388	-----> for path in $argv...
38	49	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
48	77	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
29	29	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	245	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
16	16	-------> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-------> set -l full
8	149	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
7	7	--------> test $fish_prompt_pwd_full_dirs -gt 0
50	121	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
50	71	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
21	21	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
7	7	--------> set full $all[2..]
45	65	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
288	351	> __fish_disable_bracketed_paste ff
63	63	-> printf "\e[?2004l"
36	2397	> fish_title ff
25	2361	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
39	2286	--> if set -q argv[1]...
79	79	---> set -q argv[1]
420	2168	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
41	41	----> string sub -l 20 -- $argv[1]
101	1707	----> prompt_pwd -d 1 -D 1
41	41	-----> set -l options h/help d/dir-length= D/full-length-dirs=
74	74	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
18	18	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
48	1360	-----> for path in $argv...
134	167	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
205	282	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
77	77	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
30	863	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
34	34	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
24	521	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
223	437	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
175	214	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
39	39	----------> math $fish_prompt_pwd_full_dirs - 1
27	27	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
203	263	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
60	60	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
100	340487	> ff
340387	340387	-> fastfetch $argv
30	61	> __fish_enable_bracketed_paste
31	31	-> printf "\e[?2004h"
12	57	> fish_mode_prompt
12	45	-> fish_default_mode_prompt
5	33	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
38	211040	> fish_prompt
12	12	-> set -l last_status $status
61	71	-> set -l normal (set_color normal)
10	10	--> set_color normal
54	63	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
69	79	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
61	70	-> set -l vcs_color (set_color brpurple)
9	9	--> set_color brpurple
13	13	-> set -l prompt_status ""
6	6	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
5	118	-> if functions -q fish_is_root_user...
18	18	--> functions -q fish_is_root_user
31	95	--> fish_is_root_user
2	47	---> if test "$EUID" = 0 2>/dev/null...
45	45	----> test "$EUID" = 0 2>/dev/null
1	13	---> if contains -- $USER root toor Administrator...
12	12	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	10	-> if test $last_status -ne 0...
9	9	--> test $last_status -ne 0
158	210533	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
21	338	--> prompt_login
2	10	---> if not set -q __fish_machine...
8	8	----> not set -q __fish_machine
1	7	---> if set -q __fish_machine[1]...
6	6	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
209	287	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
13	13	----> set_color $fish_color_user
8	8	----> set_color normal
9	9	----> set_color $color_host
11	39	----> prompt_hostname
28	28	-----> string replace -r -- "\..*" "" $hostname
9	9	----> set_color normal
25	231	--> prompt_pwd
9	9	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
2	2	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
13	146	---> for path in $argv...
38	49	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
38	65	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	19	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
13	209806	--> fish_vcs_prompt
35	109289	---> fish_git_prompt $argv
13	52345	----> if not command -sq git...
52332	52332	-----> not command -sq git
2	41	----> if functions -q __fish_git_prompt_ready...
39	39	-----> functions -q __fish_git_prompt_ready
142	56847	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56705	56705	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
3	3	----> return
22	49827	---> fish_hg_prompt $argv
20	49805	----> if not command -sq hg...
49769	49769	-----> not command -sq hg
16	16	-----> return 1
29	50677	---> fish_fossil_prompt $argv
19	50648	----> if not command -sq fossil...
50614	50614	-----> not command -sq fossil
15	15	-----> return 1
16	16	-> echo -n -s $status_color $suffix ' ' $normal
11	696	> fish_title
8	685	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
10	660	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
4	16	---> if test "$command" = fish...
8	8	----> test "$command" = fish
4	4	----> set command
67	587	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
39	512	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
20	401	-----> for path in $argv...
50	61	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
56	94	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
38	38	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
14	226	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
6	132	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
44	108	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	64	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
22	22	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
47	65	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
75	124	> __fish_disable_bracketed_paste ff
49	49	-> printf "\e[?2004l"
34	1963	> fish_title ff
26	1929	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
15	15	--> set -l ssh
16	16	--> set -q SSH_TTY
20	1850	--> if set -q argv[1]...
10	10	---> set -q argv[1]
365	1820	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
34	34	----> string sub -l 20 -- $argv[1]
79	1421	----> prompt_pwd -d 1 -D 1
24	24	-----> set -l options h/help d/dir-length= D/full-length-dirs=
62	62	-----> argparse -n prompt_pwd $options -- $argv
3	15	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
9	9	-----> set -q argv[1]
17	17	-----> set argv $PWD
9	9	-----> set -ql _flag_d
27	27	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
46	1123	-----> for path in $argv...
180	211	------> set -l realhome (string escape --style=regex -- ~)
31	31	-------> string escape --style=regex -- ~
164	238	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
74	74	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
30	628	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-------> set -l full
17	343	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
117	276	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
121	159	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
38	38	----------> math $fish_prompt_pwd_full_dirs - 1
19	19	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
163	212	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
49	49	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
100	334602	> ff
334502	334502	-> fastfetch $argv
26	57	> __fish_enable_bracketed_paste
31	31	-> printf "\e[?2004h"
13	59	> fish_mode_prompt
13	46	-> fish_default_mode_prompt
4	33	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
23	23	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
28	212853	> fish_prompt
15	15	-> set -l last_status $status
59	70	-> set -l normal (set_color normal)
11	11	--> set_color normal
61	77	-> set -l status_color (set_color brgreen)
16	16	--> set_color brgreen
42	53	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
36	43	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
10	91	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
14	70	--> fish_is_root_user
2	41	---> if test "$EUID" = 0 2>/dev/null...
39	39	----> test "$EUID" = 0 2>/dev/null
2	11	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
146	212430	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	321	--> prompt_login
2	6	---> if not set -q __fish_machine...
4	4	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
205	283	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
7	7	----> set_color normal
9	9	----> set_color $color_host
12	44	----> prompt_hostname
32	32	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
28	222	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
14	134	---> for path in $argv...
36	47	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
36	56	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
15	211741	--> fish_vcs_prompt
24	110708	---> fish_git_prompt $argv
11	52612	----> if not command -sq git...
52601	52601	-----> not command -sq git
3	33	----> if functions -q __fish_git_prompt_ready...
30	30	-----> functions -q __fish_git_prompt_ready
166	58017	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57851	57851	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
4	4	----> return
23	50573	---> fish_hg_prompt $argv
21	50550	----> if not command -sq hg...
50514	50514	-----> not command -sq hg
15	15	-----> return 1
30	50445	---> fish_fossil_prompt $argv
19	50415	----> if not command -sq fossil...
50380	50380	-----> not command -sq fossil
16	16	-----> return 1
18	18	-> echo -n -s $status_color $suffix ' ' $normal
12	616	> fish_title
7	604	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
5	579	--> if set -q argv[1]...
3	3	---> set -q argv[1]
39	46	---> set -l command (status current-command)
7	7	----> status current-command
3	17	---> if test "$command" = fish...
10	10	----> test "$command" = fish
4	4	----> set command
64	508	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
32	435	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	330	-----> for path in $argv...
39	51	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
38	69	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
31	31	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	197	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	119	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	95	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	58	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
20	20	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
59	107	> __fish_disable_bracketed_paste ff
48	48	-> printf "\e[?2004l"
34	2148	> fish_title ff
23	2114	-> if not set -q INSIDE_EMACS...
26	26	--> not set -q INSIDE_EMACS
20	20	--> set -l ssh
14	14	--> set -q SSH_TTY
19	2031	--> if set -q argv[1]...
11	11	---> set -q argv[1]
429	2001	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
104	1541	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
66	66	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
11	11	-----> set -q argv[1]
19	19	-----> set argv $PWD
8	8	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
14	14	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
17	17	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
41	1206	-----> for path in $argv...
112	145	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
130	211	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
81	81	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
33	809	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
27	27	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
18	545	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
116	479	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
332	363	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
31	31	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
12	12	--------> set full $all[2..]
131	191	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
60	60	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
97	349210	> ff
349113	349113	-> fastfetch $argv
26	56	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
12	65	> fish_mode_prompt
14	53	-> fish_default_mode_prompt
6	39	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
12	12	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
27	211541	> fish_prompt
13	13	-> set -l last_status $status
40	52	-> set -l normal (set_color normal)
12	12	--> set_color normal
35	44	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
36	47	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
36	43	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	80	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
13	67	--> fish_is_root_user
1	36	---> if test "$EUID" = 0 2>/dev/null...
35	35	----> test "$EUID" = 0 2>/dev/null
4	14	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
179	211191	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
22	324	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
213	279	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
9	35	----> prompt_hostname
26	26	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
31	291	--> prompt_pwd
14	14	---> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
24	186	---> for path in $argv...
43	56	----> set -l realhome (string escape --style=regex -- ~)
13	13	-----> string escape --style=regex -- ~
55	77	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	29	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
15	15	-----> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-----> echo $tmp
17	210397	--> fish_vcs_prompt
28	109561	---> fish_git_prompt $argv
9	52578	----> if not command -sq git...
52569	52569	-----> not command -sq git
1	30	----> if functions -q __fish_git_prompt_ready...
29	29	-----> functions -q __fish_git_prompt_ready
124	56903	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56779	56779	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
3	3	----> return
22	50559	---> fish_hg_prompt $argv
20	50537	----> if not command -sq hg...
50501	50501	-----> not command -sq hg
16	16	-----> return 1
29	50260	---> fish_fossil_prompt $argv
20	50231	----> if not command -sq fossil...
50195	50195	-----> not command -sq fossil
16	16	-----> return 1
17	17	-> echo -n -s $status_color $suffix ' ' $normal
11	704	> fish_title
9	693	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
7	667	--> if set -q argv[1]...
3	3	---> set -q argv[1]
41	46	---> set -l command (status current-command)
5	5	----> status current-command
3	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
4	4	----> set command
71	596	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
30	518	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	417	-----> for path in $argv...
41	52	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
37	67	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
30	30	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	284	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
13	174	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
53	138	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
63	85	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
22	22	----------> math $fish_prompt_pwd_full_dirs - 1
12	12	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
64	91	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
27	27	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
240	251	> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/cd.fish
11	11	-> function cd --description "Change directory"...
79	132	> source /usr/local/Cellar/fish/3.7.1/share/fish/completions/cd.fish
43	43	-> complete -c cd -a "(__fish_complete_cd)"
10	10	-> complete -c cd -s h -l help -d 'Display help and exit'
745	217680	> source /usr/local/share/fish/vendor_completions.d/fastfetch.fish
10	49737	-> if not type -q fastfetch...
49727	49727	--> not type -q fastfetch
38	38	-> complete -c fastfetch -f
5	5	-> function __fastfetch_complete_bool...
3	3	-> function __fastfetch_complete_color...
6	6	-> function __fastfetch_complete_command...
2	2	-> function __fastfetch_complete_config...
3	3	-> function __fastfetch_complete_logo...
1	1	-> function __fastfetch_complete_structure...
165335	167140	-> echo '
import json, subprocess, sys

def main():
    data: dict[str, list[dict]] = json.loads(subprocess.check_output(["fastfetch", "--help-raw"]))

    for key in data:
        for flag in data[key]:
            if flag.get("pseudo", False):
                continue

            command_prefix = f"""complete -c fastfetch -d "{flag["desc"]}" -l "{flag["long"]}\""""
            if "short" in flag:
                command_prefix += f""" -o {flag["short"]}"""

            if "arg" in flag:
                type: str = flag["arg"]["type"];
                if type == "bool":
                    print(f"{command_prefix} -x -a \"(__fastfetch_complete_bool)\"")
                elif type == "color":
                    print(f"{command_prefix} -x -a \"(__fastfetch_complete_color)\"")
                elif type == "command":
                    print(f"{command_prefix} -x -a \"(__fastfetch_complete_command)\"")
                elif type == "config":
                    print(f"{command_prefix} -x -a \"(__fastfetch_complete_config)\"")
                elif type == "enum":
                    temp: str = " ".join(flag["arg"]["enum"])
                    print(f"{command_prefix} -x -a \"{temp}\"")
                elif type == "logo":
                    print(f"{command_prefix} -x -a \"(__fastfetch_complete_logo)\"")
                elif type == "structure":
                    print(f"{command_prefix} -x -a \"(__fish_complete_list : __fastfetch_complete_structure)\"")
                elif type == "path":
                    print(f"{command_prefix} -r -F")
                else:
                    print(f"{command_prefix} -x")
            else:
                print(f"{command_prefix} -f")

if __name__ == "__main__":
    try:
        main()
    except:
        sys.exit(1)
' | python3 | source
45	45	--> complete -c fastfetch -d "Show this message, or help for a specific command" -l "help" -o h -x -a "(__fastfetch_complete_command)"
15	15	--> complete -c fastfetch -d "Show the full version of fastfetch" -l "version" -o v -f
9	9	--> complete -c fastfetch -d "Show the raw version string (major.minor.patch)" -l "version-raw" -f
8	8	--> complete -c fastfetch -d "List search paths of config files" -l "list-config-paths" -f
7	7	--> complete -c fastfetch -d "List search paths of presets and logos" -l "list-data-paths" -f
7	7	--> complete -c fastfetch -d "List available logos" -l "list-logos" -f
7	7	--> complete -c fastfetch -d "List available modules" -l "list-modules" -f
7	7	--> complete -c fastfetch -d "List presets fastfetch knows about" -l "list-presets" -f
7	7	--> complete -c fastfetch -d "List the supported features fastfetch was compiled with" -l "list-features" -f
7	7	--> complete -c fastfetch -d "Print available logos" -l "print-logos" -f
7	7	--> complete -c fastfetch -d "Print the default structure" -l "print-structure" -f
11	11	--> complete -c fastfetch -d "Set output format" -l "format" -x -a "default json"
17	17	--> complete -c fastfetch -d "Specify the config file or preset to be loaded" -l "config" -o c -x -a "(__fastfetch_complete_config)"
13	13	--> complete -c fastfetch -d "Generate a config file to specified path with options specified in the command line (if any)" -l "gen-config" -r -F
8	8	--> complete -c fastfetch -d "Generate a config file to specified path. Overwrite the existing one" -l "gen-config-force" -r -F
12	12	--> complete -c fastfetch -d "Use separate threads to send HTTP requests" -l "thread" -x -a "(__fastfetch_complete_bool)"
14	14	--> complete -c fastfetch -d "On Bedrock Linux, whether to escape the bedrock jail" -l "escape-bedrock" -x -a "(__fastfetch_complete_bool)"
9	9	--> complete -c fastfetch -d "Set the timeout (ms) for WMI queries" -l "wmi-timeout" -x
8	8	--> complete -c fastfetch -d "Set the timeout (ms) when waiting for child processes" -l "processing-timeout" -x
11	11	--> complete -c fastfetch -d "Set if only DRM should be used to detect displays" -l "ds-force-drm" -x -a "true sysfs-only false"
13	13	--> complete -c fastfetch -d "Whether to detect and display the version of terminal, shell and editor" -l "detect-version" -x -a "(__fastfetch_complete_bool)"
13	13	--> complete -c fastfetch -d "Set the logo source. Use "none" to disable the logo" -l "logo" -o l -x -a "(__fastfetch_complete_logo)"
18	18	--> complete -c fastfetch -d "Set the type of the logo given in "--logo"" -l "logo-type" -x -a "auto builtin small file file-raw data data-raw sixel kitty kitty_direct iterm chafa raw none"
8	8	--> complete -c fastfetch -d "Set the width of the logo (in characters), if it is an image" -l "logo-width" -x
7	7	--> complete -c fastfetch -d "Set the height of the logo (in characters), if it is an image" -l "logo-height" -x
13	13	--> complete -c fastfetch -d "Set if the logo should fill the specified width and height as much as possible without stretching" -l "logo-preserve-aspect-ratio" -x -a "(__fastfetch_complete_bool)"
7	7	--> complete -c fastfetch -d "Set the padding on the left and the right of the logo" -l "logo-padding" -x
8	8	--> complete -c fastfetch -d "Set the padding on the left of the logo" -l "logo-padding-left" -x
7	7	--> complete -c fastfetch -d "Set the padding on the right of the logo" -l "logo-padding-right" -x
7	7	--> complete -c fastfetch -d "Set the padding on the top of the logo" -l "logo-padding-top" -x
13	13	--> complete -c fastfetch -d "Whether to print the remaining logo, if it has more lines than modules to display" -l "logo-print-remaining" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Set the position of the logo should be displayed" -l "logo-position" -x -a "left top right"
11	11	--> complete -c fastfetch -d "If true, regenerate image logo cache" -l "logo-recache" -x -a "(__fastfetch_complete_bool)"
8	8	--> complete -c fastfetch -d "Short for --logo-type file --logo <path>" -l "file" -r -F
7	7	--> complete -c fastfetch -d "Short for --logo-type file-raw --logo <path>" -l "file-raw" -r -F
7	7	--> complete -c fastfetch -d "Short for --logo-type data --logo <data>" -l "data" -x
7	7	--> complete -c fastfetch -d "Short for --logo-type data-raw --logo <data>" -l "data-raw" -x
7	7	--> complete -c fastfetch -d "Short for --logo-type raw --logo <path>" -l "raw" -r -F
8	8	--> complete -c fastfetch -d "Short for --logo-type sixel --logo <path>" -l "sixel" -r -F
7	7	--> complete -c fastfetch -d "Short for --logo-type kitty --logo <path>" -l "kitty" -r -F
8	8	--> complete -c fastfetch -d "Short for --logo-type kitty-direct --logo <path>" -l "kitty-direct" -r -F
7	7	--> complete -c fastfetch -d "Short for --logo-type iterm --logo <path>" -l "iterm" -r -F
7	7	--> complete -c fastfetch -d "Short for --logo-type chafa --logo <path>" -l "chafa" -r -F
13	13	--> complete -c fastfetch -d "Produce character-cell output using foreground colors only" -l "chafa-fg-only" -x -a "(__fastfetch_complete_bool)"
8	8	--> complete -c fastfetch -d "Specify character symbols to employ in final output" -l "chafa-symbols" -x
16	16	--> complete -c fastfetch -d "Determine how colors are used in the output" -l "chafa-canvas-mode" -x -a "TRUECOLOR INDEXED_256 INDEXED_240 INDEXED_16 FGBG_BGFG FGBG INDEXED_8 INDEXED_16_8"
10	10	--> complete -c fastfetch -d "Set color space used for quantization" -l "chafa-color-space" -x -a "RGB DIN99D"
11	11	--> complete -c fastfetch -d "Set output dither mode (No effect with 24-bit color)" -l "chafa-dither-mode" -x -a "NONE ORDERED DIFFUSION"
17	17	--> complete -c fastfetch -d "Set the structure of the fetch" -l "structure" -o s -x -a "(__fish_complete_list : __fastfetch_complete_structure)"
12	12	--> complete -c fastfetch -d "Show time usage (in ms) for individual modules" -l "stat" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Disable colors" -l "pipe" -x -a "(__fastfetch_complete_bool)"
12	12	--> complete -c fastfetch -d "Set the color of the keys" -l "color-keys" -x -a "(__fastfetch_complete_color)"
11	11	--> complete -c fastfetch -d "Set the color of the title" -l "color-title" -x -a "(__fastfetch_complete_color)"
11	11	--> complete -c fastfetch -d "Set the color of module output" -l "color-output" -x -a "(__fastfetch_complete_color)"
12	12	--> complete -c fastfetch -d "Set the color of the key-value separator" -l "color-separator" -x -a "(__fastfetch_complete_color)"
11	11	--> complete -c fastfetch -d "Set the color of both the keys and title" -l "color" -x -a "(__fastfetch_complete_color)"
7	7	--> complete -c fastfetch -d "Align the width of keys to <num> characters" -l "key-width" -x
7	7	--> complete -c fastfetch -d "Set the left padding of keys to <num> characters" -l "key-padding-left" -x
12	12	--> complete -c fastfetch -d "Set whether to show icon before string keys" -l "key-type" -x -a "none string icon both"
15	15	--> complete -c fastfetch -d "Set if the keys, title and ASCII logo should be printed in bright color" -l "bright-color" -x -a "(__fastfetch_complete_bool)"
7	7	--> complete -c fastfetch -d "Set the separator between key and value" -l "separator" -x
11	11	--> complete -c fastfetch -d "Print occurring errors" -l "show-errors" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Whether to disable line wrap during the run" -l "disable-linewrap" -x -a "(__fastfetch_complete_bool)"
12	12	--> complete -c fastfetch -d "Whether to hide the cursor during the run" -l "hide-cursor" -x -a "(__fastfetch_complete_bool)"
7	7	--> complete -c fastfetch -d "Set the percentage output type" -l "percent-type" -x
10	10	--> complete -c fastfetch -d "Set the number of digits to keep after the decimal point when formatting percentage numbers" -l "percent-ndigits" -x
12	12	--> complete -c fastfetch -d "Set color used in green state of percentage bars and numbers" -l "percent-color-green" -x -a "(__fastfetch_complete_color)"
12	12	--> complete -c fastfetch -d "Set color used in yellow state of percentage bars and numbers" -l "percent-color-yellow" -x -a "(__fastfetch_complete_color)"
12	12	--> complete -c fastfetch -d "Set color used in red state of percentage bars and numbers" -l "percent-color-red" -x -a "(__fastfetch_complete_color)"
8	8	--> complete -c fastfetch -d "Set the character to use in elapsed part of percentage bars" -l "bar-char-elapsed" -x
7	7	--> complete -c fastfetch -d "Set the character to use in total part of percentage bars" -l "bar-char-total" -x
7	7	--> complete -c fastfetch -d "Set the string to use at left border of percentage bars" -l "bar-border-left" -x
7	7	--> complete -c fastfetch -d "Set the string to use at right border of percentage bars" -l "bar-border-right" -x
7	7	--> complete -c fastfetch -d "Set the width of percentage bars, in number of characters" -l "bar-width" -x
12	12	--> complete -c fastfetch -d "Set if the stdout application buffer should be disabled" -l "no-buffer" -x -a "(__fastfetch_complete_bool)"
8	8	--> complete -c fastfetch -d "Set the number of digits to keep after the decimal point when formatting sizes" -l "size-ndigits" -x
11	11	--> complete -c fastfetch -d "Set the binary prefix to used when formatting sizes" -l "size-binary-prefix" -x -a "IEC SI JEDEC"
11	11	--> complete -c fastfetch -d "Set the largest binary prefix to use when formatting sizes" -l "size-max-prefix" -x -a "B kB MB GB TB PB EB ZB YB"
8	8	--> complete -c fastfetch -d "Set the number of digits to keep after the decimal point when printing CPU / GPU frequency in GHz" -l "freq-ndigits" -x
9	9	--> complete -c fastfetch -d "Set the unit of the temperature" -l "temp-unit" -x -a "C F K"
7	7	--> complete -c fastfetch -d "Set the number of digits to keep after the decimal point when printing temperature" -l "temp-ndigits" -x
11	11	--> complete -c fastfetch -d "Set color used in green state of temperature values" -l "temp-color-green" -x -a "(__fastfetch_complete_color)"
11	11	--> complete -c fastfetch -d "Set color used in yellow state of temperature values" -l "temp-color-yellow" -x -a "(__fastfetch_complete_color)"
14	14	--> complete -c fastfetch -d "Set color used in red state of temperature values" -l "temp-color-red" -x -a "(__fastfetch_complete_color)"
7	7	--> complete -c fastfetch -d "Vulkan module & fallback for GPU output" -l "lib-vulkan" -r -F
7	7	--> complete -c fastfetch -d "Better display performance and output in wayland sessions" -l "lib-wayland" -r -F
8	8	--> complete -c fastfetch -d "X11 sessions for better display detection and faster WM detection" -l "lib-xcb-randr" -r -F
8	8	--> complete -c fastfetch -d "X11 sessions for better display detection and faster WM detection" -l "lib-xcb" -r -F
8	8	--> complete -c fastfetch -d "X11 sessions for better display detection and faster WM detection" -l "lib-xrandr" -r -F
8	8	--> complete -c fastfetch -d "X11 sessions for better display detection and faster WM detection" -l "lib-x11" -r -F
7	7	--> complete -c fastfetch -d "Used for fast resolution and refresh rate detection" -l "lib-drm" -r -F
7	7	--> complete -c fastfetch -d "Needed for values that are only stored GSettings" -l "lib-gio" -r -F
8	8	--> complete -c fastfetch -d "Needed for values that are only stored in DConf + Fallback for GSettings" -l "lib-dconf" -r -F
7	7	--> complete -c fastfetch -d "Bluetooth, Player & Media detection" -l "lib-dbus" -r -F
7	7	--> complete -c fastfetch -d "Needed for XFWM theme and XFCE Terminal font" -l "lib-xfconf" -r -F
7	7	--> complete -c fastfetch -d "Needed for pkg & rpm package count" -l "lib-sqlite3" -r -F
7	7	--> complete -c fastfetch -d "Slower fallback for rpm package count" -l "lib-rpm" -r -F
7	7	--> complete -c fastfetch -d "Images in terminal using sixel or kitty graphics protocol" -l "lib-imagemagick" -r -F
7	7	--> complete -c fastfetch -d "Libz. Faster image output when using kitty graphics protocol" -l "lib-z" -r -F
7	7	--> complete -c fastfetch -d "Image output as ascii art" -l "lib-chafa" -r -F
7	7	--> complete -c fastfetch -d "Needed by the OpenGL module for gl context creation" -l "lib-egl" -r -F
7	7	--> complete -c fastfetch -d "Needed by the OpenGL module for gl context creation" -l "lib-glx" -r -F
7	7	--> complete -c fastfetch -d "Needed by the OpenGL module for gl context creation" -l "lib-osmesa" -r -F
6	6	--> complete -c fastfetch -d "OpenCL module" -l "lib-opencl" -r -F
7	7	--> complete -c fastfetch -d "Pulseaudio. Used for Sound detection" -l "lib-pulse" -r -F
7	7	--> complete -c fastfetch -d "NetworkManager. Used for Wifi detection" -l "lib-nm" -r -F
6	6	--> complete -c fastfetch -d "Used for Termux font detection" -l "lib-freetype" -r -F
7	7	--> complete -c fastfetch -d "Used for brightness detection of external displays" -l "lib-ddcutil" -r -F
9	9	--> complete -c fastfetch -d "Used for st terminal font detection and systemd version detection" -l "lib-elf" -r -F
11	11	--> complete -c fastfetch -d "Set if the title should use fully qualified domain name" -l "title-fqdn" -x -a "(__fastfetch_complete_bool)"
12	12	--> complete -c fastfetch -d "Set color of the user name (left part)" -l "title-color-user" -x -a "(__fastfetch_complete_color)"
12	12	--> complete -c fastfetch -d "Set color of the @ symbol (middle part)" -l "title-color-at" -x -a "(__fastfetch_complete_color)"
12	12	--> complete -c fastfetch -d "Set color of the host name (right part)" -l "title-color-host" -x -a "(__fastfetch_complete_color)"
7	7	--> complete -c fastfetch -d "Set the string to be printed by the separator line" -l "separator-string" -x
11	11	--> complete -c fastfetch -d "Set the color of the separator line" -l "separator-output-color" -x -a "(__fastfetch_complete_color)"
7	7	--> complete -c fastfetch -d "Set the length of the separator line" -l "separator-length" -x
8	8	--> complete -c fastfetch -d "A colon (semicolon on Windows) separated list of folder paths to be detected" -l "disk-folders" -r -F
11	11	--> complete -c fastfetch -d "Set if regular volume should be printed" -l "disk-show-regular" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Set if external volume should be printed" -l "disk-show-external" -x -a "(__fastfetch_complete_bool)"
14	14	--> complete -c fastfetch -d "Set if hidden volumes should be printed" -l "disk-show-hidden" -x -a "(__fastfetch_complete_bool)"
12	12	--> complete -c fastfetch -d "Set if subvolumes should be printed" -l "disk-show-subvolumes" -x -a "(__fastfetch_complete_bool)"
13	13	--> complete -c fastfetch -d "Set if read only volumes should be printed" -l "disk-show-readonly" -x -a "(__fastfetch_complete_bool)"
20	20	--> complete -c fastfetch -d "Set if unknown (unable to detect sizes) volumes should be printed" -l "disk-show-unknown" -x -a "(__fastfetch_complete_bool)"
13	13	--> complete -c fastfetch -d "Use f_bavail (lpFreeBytesAvailableToCaller for Windows) instead of f_bfree to calculate used bytes" -l "disk-use-available" -x -a "(__fastfetch_complete_bool)"
12	12	--> complete -c fastfetch -d "Detect total bytes instead of current rate" -l "diskio-detect-total" -x -a "(__fastfetch_complete_bool)"
8	8	--> complete -c fastfetch -d "Show disks with given name prefix only" -l "diskio-name-prefix" -x
7	7	--> complete -c fastfetch -d "Show disks with given name prefix only" -l "physicaldisk-name-prefix" -x
12	12	--> complete -c fastfetch -d "Detect and display SSD temperature if supported" -l "physicaldisk-temp" -x -a "(__fastfetch_complete_bool)"
12	12	--> complete -c fastfetch -d "Set if disconnected bluetooth devices should be printed" -l "bluetooth-show-disconnected" -x -a "(__fastfetch_complete_bool)"
8	8	--> complete -c fastfetch -d "A colon separated list of package managers to be disabled when detecting" -l "packages-disabled" -x
17	17	--> complete -c fastfetch -d "Set if all displays should be printed in one line" -l "display-compact-type" -x -a "none original scaled original-with-refresh-rate scaled-with-refresh-rate"
13	13	--> complete -c fastfetch -d "Set if decimal refresh rates should not be rounded into integers when printing" -l "display-precise-refresh-rate" -x -a "(__fastfetch_complete_bool)"
10	10	--> complete -c fastfetch -d "Set the order should be used when printing displays" -l "display-order" -x -a "none asc desc"
7	7	--> complete -c fastfetch -d "Set the sleep times (in ms) when sending DDC/CI requests" -l "brightness-ddcci-sleep" -x
10	10	--> complete -c fastfetch -d "Set what type of sound devices should be printed" -l "sound-type" -x -a "main active all"
13	13	--> complete -c fastfetch -d "Set if "SetupAPI" should be used on Windows to detect battery info" -l "battery-use-setup-api" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Detect and display CPU temperature if supported" -l "cpu-temp" -x -a "(__fastfetch_complete_bool)"
14	14	--> complete -c fastfetch -d "Detect and display CPU frequency of different core types (eg. Pcore and Ecore) if supported" -l "cpu-show-pe-core-count" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Show all CPU caches in one line" -l "cpucache-compact" -x -a "(__fastfetch_complete_bool)"
13	13	--> complete -c fastfetch -d "Display CPU usage per CPU logical core, instead of an average result" -l "cpuusage-separate" -x -a "(__fastfetch_complete_bool)"
12	12	--> complete -c fastfetch -d "Set if DE version should be detected with slow operations" -l "de-slow-version-detection" -x -a "(__fastfetch_complete_bool)"
14	14	--> complete -c fastfetch -d "Detect and display GPU temperature if supported" -l "gpu-temp" -x -a "(__fastfetch_complete_bool)"
13	13	--> complete -c fastfetch -d "Use driver specific method to detect more detailed GPU information (memory usage, core count, etc)" -l "gpu-driver-specific" -x -a "(__fastfetch_complete_bool)"
12	12	--> complete -c fastfetch -d "Force using a specified method to detect GPUs" -l "gpu-detection-method" -x -a "auto pci vulkan opencl opengl"
11	11	--> complete -c fastfetch -d "Specify the type of GPUs should not be printed" -l "gpu-hide-type" -x -a "integrated discrete none"
11	11	--> complete -c fastfetch -d "Detect and display Battery temperature if supported" -l "battery-temp" -x -a "(__fastfetch_complete_bool)"
10	10	--> complete -c fastfetch -d "Set the number of digits to keep after the decimal point when printing load average" -l "loadavg-ndigits" -x
11	11	--> complete -c fastfetch -d "Show load average values in one line" -l "loadavg-compact" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Show IPv4 addresses in local ip module" -l "localip-show-ipv4" -x -a "(__fastfetch_complete_bool)"
12	12	--> complete -c fastfetch -d "Show IPv6 addresses in local ip module" -l "localip-show-ipv6" -x -a "(__fastfetch_complete_bool)"
14	14	--> complete -c fastfetch -d "Show mac addresses in local ip module" -l "localip-show-mac" -x -a "(__fastfetch_complete_bool)"
13	13	--> complete -c fastfetch -d "Show loop back addresses (127.0.0.1) in local ip module" -l "localip-show-loop" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Show network prefix length (/N) in local ip module" -l "localip-show-prefix-len" -x -a "(__fastfetch_complete_bool)"
7	7	--> complete -c fastfetch -d "Show interfaces with given interface name prefix only" -l "localip-name-prefix" -x
12	12	--> complete -c fastfetch -d "Show the interface that is used for default routing only" -l "localip-default-route-only" -x -a "(__fastfetch_complete_bool)"
13	13	--> complete -c fastfetch -d "Show all IPs bound to the same interface. By default only the first IP is shown" -l "localip-show-all-ips" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Show all IPs in one line" -l "localip-compact" -x -a "(__fastfetch_complete_bool)"
10	10	--> complete -c fastfetch -d "Specify the type of DNS servers should be detected" -l "dns-show-type" -x -a "ipv4 ipv6 both"
7	7	--> complete -c fastfetch -d "Show interfaces with given name prefix only" -l "netio-name-prefix" -x
12	12	--> complete -c fastfetch -d "Show the interfac that is used for default routing only" -l "netio-default-route-only" -x -a "(__fastfetch_complete_bool)"
13	13	--> complete -c fastfetch -d "Detect total bytes instead of current rate" -l "netio-detect-total" -x -a "(__fastfetch_complete_bool)"
8	8	--> complete -c fastfetch -d "Time in milliseconds to wait for the public ip server to respond" -l "publicip-timeout" -x
7	7	--> complete -c fastfetch -d "The URL of public IP detection server to be used" -l "publicip-url" -x
13	13	--> complete -c fastfetch -d "Whether to use IPv6 for public IP detection server" -l "publicip-ipv6" -x -a "(__fastfetch_complete_bool)"
7	7	--> complete -c fastfetch -d "Set the location to be used" -l "weather-location" -x
8	8	--> complete -c fastfetch -d "Time in milliseconds to wait for the weather server to respond" -l "weather-timeout" -x
7	7	--> complete -c fastfetch -d "The output weather format to be used" -l "weather-output-format" -x
13	13	--> complete -c fastfetch -d "Set if window manager plugin should be detected on supported platforms" -l "wm-detect-plugin" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Show all active users in one line" -l "users-compact" -x -a "(__fastfetch_complete_bool)"
11	11	--> complete -c fastfetch -d "Show only current user" -l "users-myself-only" -x -a "(__fastfetch_complete_bool)"
9	9	--> complete -c fastfetch -d "The name of the player to use for module Media and Player" -l "player-name" -x
11	11	--> complete -c fastfetch -d "Set the OpenGL context creation library to use" -l "opengl-library" -x -a "auto egl glx osmesa"
7	7	--> complete -c fastfetch -d "Set the shell program to execute the command text" -l "command-shell" -x
7	7	--> complete -c fastfetch -d "Set the module key to display" -l "command-key" -x
7	7	--> complete -c fastfetch -d "Set the command text to be executed" -l "command-text" -x
13	13	--> complete -c fastfetch -d "Set the symbol to be printed by Colors module" -l "colors-symbol" -x -a "block background circle diamond triangle square star"
7	7	--> complete -c fastfetch -d "Set the number of white spaces to print before the symbol" -l "colors-padding-left" -x
7	7	--> complete -c fastfetch -d "Set the block width in spaces" -l "colors-block-width" -x
7	7	--> complete -c fastfetch -d "Set the start range of colors in the blocks to print" -l "colors-block-range-start" -x
7	7	--> complete -c fastfetch -d "Set the end range of colors in the blocks to print" -l "colors-block-range-end" -x
193	462	> __fish_disable_bracketed_paste 'ff --gen-config '
269	269	-> printf "\e[?2004l"
62	3071	> fish_title ff\ --gen-config\ 
35	3009	-> if not set -q INSIDE_EMACS...
33	33	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
16	16	--> set -q SSH_TTY
23	2900	--> if set -q argv[1]...
16	16	---> set -q argv[1]
453	2861	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
46	46	----> string sub -l 20 -- $argv[1]
226	2362	----> prompt_pwd -d 1 -D 1
41	41	-----> set -l options h/help d/dir-length= D/full-length-dirs=
93	93	-----> argparse -n prompt_pwd $options -- $argv
6	23	-----> if set -q _flag_help...
17	17	------> set -q _flag_help
15	15	-----> set -q argv[1]
28	28	-----> set argv $PWD
13	13	-----> set -ql _flag_d
28	28	-----> set -l fish_prompt_pwd_dir_length $_flag_d
14	14	-----> set -q fish_prompt_pwd_dir_length
19	19	-----> set -l fulldirs 0
13	13	-----> set -ql _flag_D
25	25	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
13	13	-----> set -q fish_prompt_pwd_full_dirs
55	1811	-----> for path in $argv...
206	252	------> set -l realhome (string escape --style=regex -- ~)
46	46	-------> string escape --style=regex -- ~
128	190	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
62	62	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
21	1314	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
64	64	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
32	891	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
346	798	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
185	452	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
267	267	----------> math $fish_prompt_pwd_full_dirs - 1
28	28	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
214	325	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
111	111	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
95	84041	> ff --gen-config
83946	83946	-> fastfetch $argv
26	56	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
11	76	> fish_mode_prompt
37	65	-> fish_default_mode_prompt
4	28	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
18	18	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
30	205952	> fish_prompt
14	14	-> set -l last_status $status
46	76	-> set -l normal (set_color normal)
30	30	--> set_color normal
39	48	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
36	45	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
32	39	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	135	-> if functions -q fish_is_root_user...
50	50	--> functions -q fish_is_root_user
14	83	--> fish_is_root_user
2	36	---> if test "$EUID" = 0 2>/dev/null...
34	34	----> test "$EUID" = 0 2>/dev/null
1	29	---> if contains -- $USER root toor Administrator...
28	28	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
147	205516	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
50	344	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
2	5	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
173	270	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
35	64	----> prompt_hostname
29	29	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
20	215	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	4	---> if set -q _flag_help...
3	3	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
15	136	---> for path in $argv...
37	48	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
36	56	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
47	204810	--> fish_vcs_prompt
47	106174	---> fish_git_prompt $argv
13	51242	----> if not command -sq git...
51229	51229	-----> not command -sq git
2	71	----> if functions -q __fish_git_prompt_ready...
69	69	-----> functions -q __fish_git_prompt_ready
137	54792	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
54655	54655	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
6	6	----> return
60	49259	---> fish_hg_prompt $argv
21	49199	----> if not command -sq hg...
49162	49162	-----> not command -sq hg
16	16	-----> return 1
82	49330	---> fish_fossil_prompt $argv
21	49248	----> if not command -sq fossil...
49203	49203	-----> not command -sq fossil
24	24	-----> return 1
22	22	-> echo -n -s $status_color $suffix ' ' $normal
14	627	> fish_title
6	613	-> if not set -q INSIDE_EMACS...
10	10	--> not set -q INSIDE_EMACS
8	8	--> set -l ssh
5	5	--> set -q SSH_TTY
9	584	--> if set -q argv[1]...
3	3	---> set -q argv[1]
40	46	---> set -l command (status current-command)
6	6	----> status current-command
2	16	---> if test "$command" = fish...
9	9	----> test "$command" = fish
5	5	----> set command
76	510	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
25	426	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
26	26	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	324	-----> for path in $argv...
44	56	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
38	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	190	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	114	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	90	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	54	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
18	18	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
38	55	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
84	296	> __fish_complete_cd
187	198	-> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_complete_cd.fish
11	11	--> function __fish_complete_cd -d "Completions for the cd command"...
10	10	-> set -q CDPATH[1]
4	4	-> return 0
26	42	> __fish_complete_cd
12	12	-> set -q CDPATH[1]
4	4	-> return 0
60	105	> __fish_disable_bracketed_paste 'cd .config/fastfetch/'
45	45	-> printf "\e[?2004l"
33	1806	> fish_title cd\ .config/fastfetch/
22	1773	-> if not set -q INSIDE_EMACS...
21	21	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
10	1702	--> if set -q argv[1]...
11	11	---> set -q argv[1]
227	1681	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
32	32	----> string sub -l 20 -- $argv[1]
80	1422	----> prompt_pwd -d 1 -D 1
23	23	-----> set -l options h/help d/dir-length= D/full-length-dirs=
66	66	-----> argparse -n prompt_pwd $options -- $argv
4	16	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
10	10	-----> set -q argv[1]
18	18	-----> set argv $PWD
9	9	-----> set -ql _flag_d
23	23	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
17	17	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
39	1120	-----> for path in $argv...
137	167	------> set -l realhome (string escape --style=regex -- ~)
30	30	-------> string escape --style=regex -- ~
141	211	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
70	70	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
22	703	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
19	411	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
144	334	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
154	190	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
26	26	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
154	229	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
75	75	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
96	1488	> cd .config/fastfetch/
22	22	-> set -l MAX_DIR_HIST 25
10	543	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)...
342	533	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
130	130	---> count $argv
42	42	---> test "$argv[1]" = "--"
19	19	---> echo 1
6	22	-> if status --is-command-substitution...
16	16	--> status --is-command-substitution
26	26	-> set -l previous $PWD
5	24	-> if test "$argv" = -...
19	19	--> test "$argv" = -
138	475	-> builtin cd $argv
45	337	--> __update_cwd_osc VARIABLE SET PWD
7	31	---> if status --is-command-substitution...
13	13	----> status --is-command-substitution
11	11	----> set -q INSIDE_EMACS
224	261	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
37	37	----> string escape --style=url $PWD
38	38	-> set -l cd_status $status
62	227	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"...
54	54	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
13	13	--> set -q dirprev
12	12	--> set -l dirprev
17	17	--> set -q dirprev[$MAX_DIR_HIST]
10	10	--> set -U -q dirprev
18	18	--> set -g -a dirprev $previous
8	8	--> set -U -q dirnext
11	11	--> set -e dirnext
9	9	--> set -U -q __fish_cd_direction
13	13	--> set -g __fish_cd_direction prev
15	15	-> return $cd_status
27	57	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
21	105	> fish_mode_prompt
25	84	-> fish_default_mode_prompt
16	59	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
27	27	---> test "$fish_key_bindings" = fish_vi_key_bindings
16	16	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
65	242369	> fish_prompt
28	28	-> set -l last_status $status
124	147	-> set -l normal (set_color normal)
23	23	--> set_color normal
122	148	-> set -l status_color (set_color brgreen)
26	26	--> set_color brgreen
177	206	-> set -l cwd_color (set_color $fish_color_cwd)
29	29	--> set_color $fish_color_cwd
212	246	-> set -l vcs_color (set_color brpurple)
34	34	--> set_color brpurple
25	25	-> set -l prompt_status ""
14	14	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
14	14	-> set -l suffix '❯'
8	235	-> if functions -q fish_is_root_user...
26	26	--> functions -q fish_is_root_user
37	201	--> fish_is_root_user
8	124	---> if test "$EUID" = 0 2>/dev/null...
116	116	----> test "$EUID" = 0 2>/dev/null
4	30	---> if contains -- $USER root toor Administrator...
26	26	----> contains -- $USER root toor Administrator
10	10	---> return 1
4	22	-> if test $last_status -ne 0...
18	18	--> test $last_status -ne 0
329	241194	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
37	1043	--> prompt_login
5	19	---> if not set -q __fish_machine...
14	14	----> not set -q __fish_machine
3	14	---> if set -q __fish_machine[1]...
11	11	----> set -q __fish_machine[1]
23	23	---> set -l color_host $fish_color_host
4	13	---> if set -q SSH_TTY...
9	9	----> set -q SSH_TTY
700	937	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
30	30	----> set_color $fish_color_user
25	25	----> set_color normal
44	44	----> set_color $color_host
57	111	----> prompt_hostname
54	54	-----> string replace -r -- "\..*" "" $hostname
27	27	----> set_color normal
74	716	--> prompt_pwd
30	30	---> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	---> argparse -n prompt_pwd $options -- $argv
4	27	---> if set -q _flag_help...
23	23	----> set -q _flag_help
10	10	---> set -q argv[1]
74	74	---> set argv $PWD
11	11	---> set -ql _flag_d
9	9	---> set -q fish_prompt_pwd_dir_length
12	12	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
8	8	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
34	377	---> for path in $argv...
120	149	----> set -l realhome (string escape --style=regex -- ~)
29	29	-----> string escape --style=regex -- ~
92	142	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
50	50	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	52	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
23	23	-----> test "$fish_prompt_pwd_dir_length" -eq 0
18	18	-----> echo $tmp
21	239106	--> fish_vcs_prompt
82	239085	---> fish_git_prompt $argv
13	63259	----> if not command -sq git...
63246	63246	-----> not command -sq git
2	30	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
126	57375	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57249	57249	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
57	56476	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	56419	-----> __fish_git_prompt_operation_branch_bare $repo_info
8	8	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	77	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
6	42	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	56200	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	56188	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	56185	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56097	56097	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
7	7	----> set -g __fish_git_prompt_status_order stagedstate invalidstate dirtystate untrackedfiles stashstate
5	4023	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
27	1702	-----> __fish_git_prompt_validate_chars
9	9	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
33	171	------> __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate ''
17	17	-------> set -l user_variable_name "$argv[1]"
6	6	-------> set -l char $argv[2]
2	5	-------> if set -q argv[3]...
3	3	--------> set -q argv[3]
7	7	-------> set -l variable _$user_variable_name
7	7	-------> set -l variable_done "$variable"_done
20	96	-------> if not set -q $variable...
6	6	--------> not set -q $variable
54	70	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
10	10	---------> set -q $user_variable_name
6	6	---------> echo $char
15	139	------> __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
7	7	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l char $argv[2]
1	38	-------> if set -q argv[3]...
4	4	--------> set -q argv[3]
20	33	--------> begin...
7	7	---------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
6	6	---------> contains -- "$__fish_git_prompt_use_informative_chars" yes true 1
7	7	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
4	62	-------> if not set -q $variable...
4	4	--------> not set -q $variable
43	54	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
6	6	---------> set -q $user_variable_name
5	5	---------> echo $char
14	138	------> __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l char $argv[2]
1	37	-------> if set -q argv[3]...
4	4	--------> set -q argv[3]
20	32	--------> begin...
7	7	---------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
5	5	---------> contains -- "$__fish_git_prompt_use_informative_chars" yes true 1
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	65	-------> if not set -q $variable...
5	5	--------> not set -q $variable
47	57	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
6	6	---------> set -q $user_variable_name
4	4	---------> echo $char
12	129	------> __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l char $argv[2]
2	36	-------> if set -q argv[3]...
3	3	--------> set -q argv[3]
20	31	--------> begin...
6	6	---------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
5	5	---------> contains -- "$__fish_git_prompt_use_informative_chars" yes true 1
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
3	60	-------> if not set -q $variable...
5	5	--------> not set -q $variable
42	52	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
6	6	---------> set -q $user_variable_name
4	4	---------> echo $char
16	160	------> __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
7	7	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l char $argv[2]
6	40	-------> if set -q argv[3]...
3	3	--------> set -q argv[3]
20	31	--------> begin...
6	6	---------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
5	5	---------> contains -- "$__fish_git_prompt_use_informative_chars" yes true 1
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
6	81	-------> if not set -q $variable...
5	5	--------> not set -q $variable
56	70	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
9	9	---------> set -q $user_variable_name
5	5	---------> echo $char
22	171	------> __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
11	11	-------> set -l user_variable_name "$argv[1]"
7	7	-------> set -l char $argv[2]
2	42	-------> if set -q argv[3]...
4	4	--------> set -q argv[3]
21	36	--------> begin...
9	9	---------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
6	6	---------> contains -- "$__fish_git_prompt_use_informative_chars" yes true 1
8	8	-------> set -l variable _$user_variable_name
7	7	-------> set -l variable_done "$variable"_done
3	74	-------> if not set -q $variable...
5	5	--------> not set -q $variable
53	66	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
6	6	---------> set -q $user_variable_name
7	7	---------> echo $char
13	139	------> __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
8	8	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
2	38	-------> if set -q argv[3]...
3	3	--------> set -q argv[3]
20	33	--------> begin...
7	7	---------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
6	6	---------> contains -- "$__fish_git_prompt_use_informative_chars" yes true 1
7	7	-------> set -l variable _$user_variable_name
7	7	-------> set -l variable_done "$variable"_done
3	61	-------> if not set -q $variable...
4	4	--------> not set -q $variable
43	54	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
6	6	---------> set -q $user_variable_name
5	5	---------> echo $char
15	136	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
1	35	-------> if set -q argv[3]...
3	3	--------> set -q argv[3]
19	31	--------> begin...
6	6	---------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
6	6	---------> contains -- "$__fish_git_prompt_use_informative_chars" yes true 1
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	63	-------> if not set -q $variable...
8	8	--------> not set -q $variable
43	52	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
5	5	---------> set -q $user_variable_name
4	4	---------> echo $char
13	129	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
7	7	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
1	35	-------> if set -q argv[3]...
3	3	--------> set -q argv[3]
19	31	--------> begin...
6	6	---------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
6	6	---------> contains -- "$__fish_git_prompt_use_informative_chars" yes true 1
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
3	58	-------> if not set -q $variable...
5	5	--------> not set -q $variable
40	50	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
5	5	---------> set -q $user_variable_name
5	5	---------> echo $char
12	115	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
2	5	-------> if set -q argv[3]...
3	3	--------> set -q argv[3]
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
19	75	-------> if not set -q $variable...
4	4	--------> not set -q $variable
42	52	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
6	6	---------> set -q $user_variable_name
4	4	---------> echo $char
14	126	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l char $argv[2]
1	4	-------> if set -q argv[3]...
3	3	--------> set -q argv[3]
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
29	87	-------> if not set -q $variable...
4	4	--------> not set -q $variable
44	54	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
5	5	---------> set -q $user_variable_name
5	5	---------> echo $char
11	113	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
1	4	-------> if set -q argv[3]...
3	3	--------> set -q argv[3]
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
20	76	-------> if not set -q $variable...
4	4	--------> not set -q $variable
42	52	--------> set -g $variable (set -q $user_variable_name; and echo $$user_variable_name; or echo $char)
6	6	---------> set -q $user_variable_name
4	4	---------> echo $char
26	2308	-----> __fish_git_prompt_validate_colors
37	211	------> __fish_git_prompt_set_color __fish_git_prompt_color '' ''
7	7	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l default default_done
65	105	-------> switch (count $argv)...
16	16	--------> count $argv
16	16	--------> set default "$argv[2]"
8	8	--------> set default_done "$argv[3]"
10	10	-------> set -l variable _$user_variable_name
7	7	-------> set -l variable_done "$variable"_done
6	41	-------> if not set -q $variable...
6	6	--------> not set -q $variable
5	29	--------> if test -n "$$user_variable_name"...
7	7	---------> test -n "$$user_variable_name"
7	7	---------> set -g $variable $default
10	10	---------> set -g $variable_done $default_done
14	158	------> __fish_git_prompt_set_color __fish_git_prompt_color_prefix
7	7	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l default default_done
63	87	-------> switch (count $argv)...
10	10	--------> count $argv
8	8	--------> set default $___fish_git_prompt_color
6	6	--------> set default_done $___fish_git_prompt_color_done
7	7	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	32	-------> if not set -q $variable...
5	5	--------> not set -q $variable
3	24	--------> if test -n "$$user_variable_name"...
7	7	---------> test -n "$$user_variable_name"
7	7	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
11	145	------> __fish_git_prompt_set_color __fish_git_prompt_color_suffix
7	7	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l default default_done
61	81	-------> switch (count $argv)...
7	7	--------> count $argv
7	7	--------> set default $___fish_git_prompt_color
6	6	--------> set default_done $___fish_git_prompt_color_done
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	30	-------> if not set -q $variable...
5	5	--------> not set -q $variable
3	22	--------> if test -n "$$user_variable_name"...
6	6	---------> test -n "$$user_variable_name"
7	7	---------> set -g $variable $default
6	6	---------> set -g $variable_done $default_done
11	135	------> __fish_git_prompt_set_color __fish_git_prompt_color_bare
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l default default_done
54	73	-------> switch (count $argv)...
7	7	--------> count $argv
7	7	--------> set default $___fish_git_prompt_color
5	5	--------> set default_done $___fish_git_prompt_color_done
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	29	-------> if not set -q $variable...
4	4	--------> not set -q $variable
3	22	--------> if test -n "$$user_variable_name"...
6	6	---------> test -n "$$user_variable_name"
6	6	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
12	133	------> __fish_git_prompt_set_color __fish_git_prompt_color_merging
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l default default_done
48	66	-------> switch (count $argv)...
7	7	--------> count $argv
6	6	--------> set default $___fish_git_prompt_color
5	5	--------> set default_done $___fish_git_prompt_color_done
6	6	-------> set -l variable _$user_variable_name
9	9	-------> set -l variable_done "$variable"_done
3	30	-------> if not set -q $variable...
5	5	--------> not set -q $variable
4	22	--------> if test -n "$$user_variable_name"...
5	5	---------> test -n "$$user_variable_name"
6	6	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
13	133	------> __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
6	6	-------> set -l user_variable_name "$argv[1]"
3	3	-------> set -l default default_done
51	69	-------> switch (count $argv)...
6	6	--------> count $argv
6	6	--------> set default $___fish_git_prompt_color
6	6	--------> set default_done $___fish_git_prompt_color_done
5	5	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
2	31	-------> if not set -q $variable...
5	5	--------> not set -q $variable
5	24	--------> if test -n "$$user_variable_name"...
5	5	---------> test -n "$$user_variable_name"
6	6	---------> set -g $variable $default
8	8	---------> set -g $variable_done $default_done
12	132	------> __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
6	6	-------> set -l user_variable_name "$argv[1]"
3	3	-------> set -l default default_done
50	68	-------> switch (count $argv)...
7	7	--------> count $argv
6	6	--------> set default $___fish_git_prompt_color
5	5	--------> set default_done $___fish_git_prompt_color_done
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	31	-------> if not set -q $variable...
4	4	--------> not set -q $variable
3	24	--------> if test -n "$$user_variable_name"...
6	6	---------> test -n "$$user_variable_name"
8	8	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
11	129	------> __fish_git_prompt_set_color __fish_git_prompt_color_upstream
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l default default_done
49	68	-------> switch (count $argv)...
7	7	--------> count $argv
6	6	--------> set default $___fish_git_prompt_color
6	6	--------> set default_done $___fish_git_prompt_color_done
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
4	29	-------> if not set -q $variable...
4	4	--------> not set -q $variable
4	21	--------> if test -n "$$user_variable_name"...
5	5	---------> test -n "$$user_variable_name"
6	6	---------> set -g $variable $default
6	6	---------> set -g $variable_done $default_done
8	602	------> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
7	7	-------> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
12	132	-------> __fish_git_prompt_set_color __fish_git_prompt_color_flags
7	7	--------> set -l user_variable_name "$argv[1]"
3	3	--------> set -l default default_done
50	67	--------> switch (count $argv)...
6	6	---------> count $argv
6	6	---------> set default $___fish_git_prompt_color
5	5	---------> set default_done $___fish_git_prompt_color_done
6	6	--------> set -l variable _$user_variable_name
8	8	--------> set -l variable_done "$variable"_done
3	29	--------> if not set -q $variable...
4	4	---------> not set -q $variable
2	22	---------> if test -n "$$user_variable_name"...
6	6	----------> test -n "$$user_variable_name"
7	7	----------> set -g $variable $default
7	7	----------> set -g $variable_done $default_done
13	147	-------> __fish_git_prompt_set_color __fish_git_prompt_color_branch
5	5	--------> set -l user_variable_name "$argv[1]"
4	4	--------> set -l default default_done
53	79	--------> switch (count $argv)...
7	7	---------> count $argv
12	12	---------> set default $___fish_git_prompt_color
7	7	---------> set default_done $___fish_git_prompt_color_done
7	7	--------> set -l variable _$user_variable_name
6	6	--------> set -l variable_done "$variable"_done
4	33	--------> if not set -q $variable...
5	5	---------> not set -q $variable
4	24	---------> if test -n "$$user_variable_name"...
6	6	----------> test -n "$$user_variable_name"
7	7	----------> set -g $variable $default
7	7	----------> set -g $variable_done $default_done
17	153	-------> __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
6	6	--------> set -l user_variable_name "$argv[1]"
4	4	--------> set -l default default_done
55	83	--------> switch (count $argv)...
15	15	---------> count $argv
7	7	---------> set default "$argv[2]"
6	6	---------> set default_done "$argv[3]"
6	6	--------> set -l variable _$user_variable_name
6	6	--------> set -l variable_done "$variable"_done
3	31	--------> if not set -q $variable...
5	5	---------> not set -q $variable
3	23	---------> if test -n "$$user_variable_name"...
6	6	----------> test -n "$$user_variable_name"
7	7	----------> set -g $variable $default
7	7	----------> set -g $variable_done $default_done
16	155	-------> __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
6	6	--------> set -l user_variable_name "$argv[1]"
4	4	--------> set -l default default_done
61	80	--------> switch (count $argv)...
8	8	---------> count $argv
6	6	---------> set default "$argv[2]"
5	5	---------> set default_done "$argv[3]"
8	8	--------> set -l variable _$user_variable_name
6	6	--------> set -l variable_done "$variable"_done
4	35	--------> if not set -q $variable...
7	7	---------> not set -q $variable
3	24	---------> if test -n "$$user_variable_name"...
6	6	----------> test -n "$$user_variable_name"
8	8	----------> set -g $variable $default
7	7	----------> set -g $variable_done $default_done
45	223	------> __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)
13	13	-------> set_color red
7	7	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l default default_done
51	107	-------> switch (count $argv)...
8	8	--------> count $argv
7	7	--------> set default "$argv[2]"
35	41	--------> set default_done (set_color normal)
6	6	---------> set_color normal
7	7	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
4	34	-------> if not set -q $variable...
4	4	--------> not set -q $variable
3	26	--------> if test -n "$$user_variable_name"...
6	6	---------> test -n "$$user_variable_name"
7	7	---------> set -g $variable $default
10	10	---------> set -g $variable_done $default_done
16	138	------> __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l default default_done
51	70	-------> switch (count $argv)...
7	7	--------> count $argv
7	7	--------> set default "$argv[2]"
5	5	--------> set default_done "$argv[3]"
5	5	-------> set -l variable _$user_variable_name
7	7	-------> set -l variable_done "$variable"_done
3	30	-------> if not set -q $variable...
5	5	--------> not set -q $variable
3	22	--------> if test -n "$$user_variable_name"...
6	6	---------> test -n "$$user_variable_name"
7	7	---------> set -g $variable $default
6	6	---------> set -g $variable_done $default_done
17	143	------> __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l default default_done
52	70	-------> switch (count $argv)...
7	7	--------> count $argv
6	6	--------> set default "$argv[2]"
5	5	--------> set default_done "$argv[3]"
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
4	35	-------> if not set -q $variable...
4	4	--------> not set -q $variable
3	27	--------> if test -n "$$user_variable_name"...
5	5	---------> test -n "$$user_variable_name"
13	13	---------> set -g $variable $default
6	6	---------> set -g $variable_done $default_done
4	4	-----> set -g ___fish_git_prompt_init
10	10	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
51349	57273	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5924	5924	-----> read -lz key value
9	42	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	52	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
3	10	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
3	8	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	4	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
62	75	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
5	5	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
2	5	----> if test -n "$c"...
3	3	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
4	4	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
8	581	> fish_title
6	573	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	553	--> if set -q argv[1]...
3	3	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
64	491	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
6	6	----> string sub -l 20 -- $command
22	421	----> prompt_pwd -d 1 -D 1
9	9	-----> set -l options h/help d/dir-length= D/full-length-dirs=
27	27	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	320	-----> for path in $argv...
38	49	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
37	58	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	199	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	116	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	91	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	54	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
44	64	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
73	139	> __fish_disable_bracketed_paste ls
66	66	-> printf "\e[?2004l"
42	2743	> fish_title ls
32	2701	-> if not set -q INSIDE_EMACS...
50	50	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
15	15	--> set -q SSH_TTY
14	2579	--> if set -q argv[1]...
17	17	---> set -q argv[1]
414	2548	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
43	43	----> string sub -l 20 -- $argv[1]
113	2091	----> prompt_pwd -d 1 -D 1
57	57	-----> set -l options h/help d/dir-length= D/full-length-dirs=
63	63	-----> argparse -n prompt_pwd $options -- $argv
4	15	-----> if set -q _flag_help...
11	11	------> set -q _flag_help
9	9	-----> set -q argv[1]
19	19	-----> set argv $PWD
8	8	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
54	1735	-----> for path in $argv...
219	250	------> set -l realhome (string escape --style=regex -- ~)
31	31	-------> string escape --style=regex -- ~
340	511	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
171	171	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
33	920	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
35	35	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
21	574	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
305	499	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
153	194	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
41	41	----------> math $fish_prompt_pwd_full_dirs - 1
23	23	--------> set tmp $all[1]
14	14	--------> set full $all[2..]
200	263	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
63	63	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
174	80126	> ls
79952	79952	-> eza -lha $argv
27	58	> __fish_enable_bracketed_paste
31	31	-> printf "\e[?2004h"
10	54	> fish_mode_prompt
12	44	-> fish_default_mode_prompt
5	32	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
23	222780	> fish_prompt
13	13	-> set -l last_status $status
50	62	-> set -l normal (set_color normal)
12	12	--> set_color normal
38	47	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
39	48	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	40	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
3	77	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
11	64	--> fish_is_root_user
2	38	---> if test "$EUID" = 0 2>/dev/null...
36	36	----> test "$EUID" = 0 2>/dev/null
1	11	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
129	222430	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
15	330	--> prompt_login
2	8	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
2	5	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
211	290	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
6	6	----> set_color normal
7	7	----> set_color $color_host
10	38	----> prompt_hostname
28	28	-----> string replace -r -- "\..*" "" $hostname
18	18	----> set_color normal
26	246	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
17	17	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
6	6	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
16	152	---> for path in $argv...
44	55	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
39	62	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	19	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
11	221725	--> fish_vcs_prompt
109	221714	---> fish_git_prompt $argv
15	51419	----> if not command -sq git...
51404	51404	-----> not command -sq git
2	34	----> if functions -q __fish_git_prompt_ready...
32	32	-----> functions -q __fish_git_prompt_ready
131	56680	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56549	56549	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
55	56605	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	56550	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
6	6	------> set -l total
23	92	------> if test -d $git_dir/rebase-merge...
16	16	-------> test -d $git_dir/rebase-merge
15	53	-------> if test -d $git_dir/rebase-apply...
9	9	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	56311	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56299	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
90	56297	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56207	56207	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
7	7	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
7	7	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
14	14	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50351	56262	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5911	5911	-----> read -lz key value
7	43	----> if not set -q dirty[1]...
20	20	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	70	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
1	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
72	84	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
3	32	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
29	29	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
7	42	----> if test -n "$b"...
8	8	-----> test -n "$b"
9	9	-----> set b "$branch_color$b$branch_done"
4	18	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
8	8	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
8	8	----> set -l format $argv[1]
5	15	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
32	32	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
13	780	> fish_title
9	767	-> if not set -q INSIDE_EMACS...
10	10	--> not set -q INSIDE_EMACS
8	8	--> set -l ssh
4	4	--> set -q SSH_TTY
11	736	--> if set -q argv[1]...
3	3	---> set -q argv[1]
96	111	---> set -l command (status current-command)
15	15	----> status current-command
3	18	---> if test "$command" = fish...
9	9	----> test "$command" = fish
6	6	----> set command
84	593	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
27	500	----> prompt_pwd -d 1 -D 1
11	11	-----> set -l options h/help d/dir-length= D/full-length-dirs=
26	26	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
9	9	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
16	388	-----> for path in $argv...
43	57	------> set -l realhome (string escape --style=regex -- ~)
14	14	-------> string escape --style=regex -- ~
38	62	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	253	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-------> set -l full
8	167	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
8	8	--------> test $fish_prompt_pwd_full_dirs -gt 0
46	139	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
63	93	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
30	30	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	62	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
52	99	> __fish_disable_bracketed_paste nvim
47	47	-> printf "\e[?2004l"
30	2046	> fish_title nvim
22	2016	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
11	1945	--> if set -q argv[1]...
11	11	---> set -q argv[1]
298	1923	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
91	1594	----> prompt_pwd -d 1 -D 1
46	46	-----> set -l options h/help d/dir-length= D/full-length-dirs=
71	71	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
11	11	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
24	24	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
45	1248	-----> for path in $argv...
167	202	------> set -l realhome (string escape --style=regex -- ~)
35	35	-------> string escape --style=regex -- ~
166	254	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
88	88	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
23	747	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-------> set -l full
24	457	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
152	359	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
167	207	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
40	40	----------> math $fish_prompt_pwd_full_dirs - 1
42	42	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
156	224	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
68	68	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
350366824	350366824	> nvim
66	230	> __fish_enable_bracketed_paste
164	164	-> printf "\e[?2004h"
41	224	> fish_mode_prompt
100	183	-> fish_default_mode_prompt
13	83	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
53	53	---> test "$fish_key_bindings" = fish_vi_key_bindings
17	17	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
120	236143	> fish_prompt
66	66	-> set -l last_status $status
232	338	-> set -l normal (set_color normal)
106	106	--> set_color normal
202	248	-> set -l status_color (set_color brgreen)
46	46	--> set_color brgreen
191	238	-> set -l cwd_color (set_color $fish_color_cwd)
47	47	--> set_color $fish_color_cwd
191	347	-> set -l vcs_color (set_color brpurple)
156	156	--> set_color brpurple
24	24	-> set -l prompt_status ""
13	13	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
24	24	-> set -l suffix '❯'
7	444	-> if functions -q fish_is_root_user...
166	166	--> functions -q fish_is_root_user
48	271	--> fish_is_root_user
9	128	---> if test "$EUID" = 0 2>/dev/null...
119	119	----> test "$EUID" = 0 2>/dev/null
7	84	---> if contains -- $USER root toor Administrator...
77	77	----> contains -- $USER root toor Administrator
11	11	---> return 1
3	23	-> if test $last_status -ne 0...
20	20	--> test $last_status -ne 0
435	234232	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
212	1158	--> prompt_login
6	28	---> if not set -q __fish_machine...
22	22	----> not set -q __fish_machine
2	17	---> if set -q __fish_machine[1]...
15	15	----> set -q __fish_machine[1]
24	24	---> set -l color_host $fish_color_host
2	10	---> if set -q SSH_TTY...
8	8	----> set -q SSH_TTY
573	867	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
29	29	----> set_color $fish_color_user
34	34	----> set_color normal
25	25	----> set_color $color_host
133	188	----> prompt_hostname
55	55	-----> string replace -r -- "\..*" "" $hostname
18	18	----> set_color normal
180	787	--> prompt_pwd
32	32	---> set -l options h/help d/dir-length= D/full-length-dirs=
38	38	---> argparse -n prompt_pwd $options -- $argv
4	14	---> if set -q _flag_help...
10	10	----> set -q _flag_help
9	9	---> set -q argv[1]
14	14	---> set argv $PWD
7	7	---> set -ql _flag_d
9	9	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
8	8	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
40	449	---> for path in $argv...
119	146	----> set -l realhome (string escape --style=regex -- ~)
27	27	-----> string escape --style=regex -- ~
122	191	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
69	69	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
31	72	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
23	23	-----> test "$fish_prompt_pwd_dir_length" -eq 0
18	18	-----> echo $tmp
113	231852	--> fish_vcs_prompt
163	231739	---> fish_git_prompt $argv
13	60854	----> if not command -sq git...
60841	60841	-----> not command -sq git
7	75	----> if functions -q __fish_git_prompt_ready...
68	68	-----> functions -q __fish_git_prompt_ready
137	56394	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56257	56257	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
9	9	----> set -l sha $repo_info[5]
59	56781	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	56722	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
3	3	------> set -l total
27	85	------> if test -d $git_dir/rebase-merge...
16	16	-------> test -d $git_dir/rebase-merge
5	42	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	56491	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
5	56479	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
85	56474	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56389	56389	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
12	12	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
3	3	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50771	56828	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6057	6057	-----> read -lz key value
10	49	----> if not set -q dirty[1]...
22	22	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
7	77	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
8	49	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	12	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
5	5	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
21	88	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	27	-----> if test -n "$$i"...
26	26	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
2	13	-----> if test -n "$$i"...
11	11	------> test -n "$$i"
1	13	-----> if test -n "$$i"...
12	12	------> test -n "$$i"
70	84	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
3	32	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
29	29	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
7	39	----> if test -n "$b"...
7	7	-----> test -n "$b"
10	10	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
8	8	----> set -l format $argv[1]
3	14	----> if test -z "$format"...
5	5	-----> test -z "$format"
6	6	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
11	689	> fish_title
8	678	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
7	655	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
66	588	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
25	515	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	420	-----> for path in $argv...
39	50	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
45	66	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
10	291	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
9	191	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
77	161	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
48	84	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
51	77	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
26	26	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
120	180	> __fish_enable_bracketed_paste
60	60	-> printf "\e[?2004h"
40	434	> fish_mode_prompt
35	394	-> fish_default_mode_prompt
36	359	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
97	97	---> test "$fish_key_bindings" = fish_vi_key_bindings
226	226	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
89	239767	> fish_prompt
41	41	-> set -l last_status $status
148	177	-> set -l normal (set_color normal)
29	29	--> set_color normal
157	183	-> set -l status_color (set_color brgreen)
26	26	--> set_color brgreen
276	315	-> set -l cwd_color (set_color $fish_color_cwd)
39	39	--> set_color $fish_color_cwd
197	232	-> set -l vcs_color (set_color brpurple)
35	35	--> set_color brpurple
24	24	-> set -l prompt_status ""
15	15	-> set -q fish_prompt_pwd_dir_length
30	30	-> set -lx fish_prompt_pwd_dir_length 0
14	14	-> set -l suffix '❯'
8	274	-> if functions -q fish_is_root_user...
30	30	--> functions -q fish_is_root_user
37	236	--> fish_is_root_user
10	158	---> if test "$EUID" = 0 2>/dev/null...
148	148	----> test "$EUID" = 0 2>/dev/null
4	31	---> if contains -- $USER root toor Administrator...
27	27	----> contains -- $USER root toor Administrator
10	10	---> return 1
2	22	-> if test $last_status -ne 0...
20	20	--> test $last_status -ne 0
548	238338	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
50	1456	--> prompt_login
3	17	---> if not set -q __fish_machine...
14	14	----> not set -q __fish_machine
3	22	---> if set -q __fish_machine[1]...
19	19	----> set -q __fish_machine[1]
23	23	---> set -l color_host $fish_color_host
3	13	---> if set -q SSH_TTY...
10	10	----> set -q SSH_TTY
923	1331	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
28	28	----> set_color $fish_color_user
35	35	----> set_color normal
52	52	----> set_color $color_host
178	255	----> prompt_hostname
77	77	-----> string replace -r -- "\..*" "" $hostname
38	38	----> set_color normal
94	921	--> prompt_pwd
51	51	---> set -l options h/help d/dir-length= D/full-length-dirs=
55	55	---> argparse -n prompt_pwd $options -- $argv
5	18	---> if set -q _flag_help...
13	13	----> set -q _flag_help
11	11	---> set -q argv[1]
20	20	---> set argv $PWD
9	9	---> set -ql _flag_d
17	17	---> set -q fish_prompt_pwd_dir_length
15	15	---> set -l fulldirs 0
9	9	---> set -ql _flag_D
10	10	---> set -q fish_prompt_pwd_full_dirs
14	14	---> set -l fish_prompt_pwd_full_dirs 1
72	598	---> for path in $argv...
128	164	----> set -l realhome (string escape --style=regex -- ~)
36	36	-----> string escape --style=regex -- ~
207	290	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
83	83	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
16	72	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
32	32	-----> test "$fish_prompt_pwd_dir_length" -eq 0
24	24	-----> echo $tmp
47	235413	--> fish_vcs_prompt
107	235366	---> fish_git_prompt $argv
12	63501	----> if not command -sq git...
63489	63489	-----> not command -sq git
2	30	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
175	56525	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56350	56350	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
6	6	----> set -q repo_info[5]
25	25	----> set -l sha $repo_info[5]
63	57233	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
49	57170	-----> __fish_git_prompt_operation_branch_bare $repo_info
12	12	------> set -l git_dir $argv[1]
7	7	------> set -l inside_gitdir $argv[2]
7	7	------> set -l bare_repo $argv[3]
5	5	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
5	5	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	90	------> if test -d $git_dir/rebase-merge...
15	15	-------> test -d $git_dir/rebase-merge
6	52	-------> if test -d $git_dir/rebase-apply...
14	14	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
13	56918	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	56901	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
96	56898	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56802	56802	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
5	5	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
6	6	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
5	5	----> set -l informative
5	5	----> set -l dirty
4	4	----> set -l untracked
51416	57382	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5966	5966	-----> read -lz key value
6	41	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	47	----> for i in $__fish_git_prompt_status_order...
2	9	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
65	81	----> set b (string replace refs/heads/ '' -- $b)
16	16	-----> string replace refs/heads/ '' -- $b
1	20	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
19	19	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	30	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
0	4	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
11	624	> fish_title
11	613	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
5	585	--> if set -q argv[1]...
3	3	---> set -q argv[1]
42	48	---> set -l command (status current-command)
6	6	----> status current-command
3	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
4	4	----> set command
69	514	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
30	438	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	335	-----> for path in $argv...
46	59	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
41	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	199	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
8	117	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	92	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
41	53	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
12	12	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	61	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
82	162	> __fish_disable_bracketed_paste ff
80	80	-> printf "\e[?2004l"
33	2533	> fish_title ff
25	2500	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
10	10	--> set -q SSH_TTY
20	2426	--> if set -q argv[1]...
11	11	---> set -q argv[1]
361	2395	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
113	2003	----> prompt_pwd -d 1 -D 1
40	40	-----> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
11	11	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
52	1653	-----> for path in $argv...
170	202	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
200	289	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
89	89	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
39	1110	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
38	38	-------> test "$fish_prompt_pwd_dir_length" -eq 0
17	17	-------> set -l full
25	581	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
20	20	--------> test $fish_prompt_pwd_full_dirs -gt 0
251	492	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
190	241	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
51	51	----------> math $fish_prompt_pwd_full_dirs - 1
29	29	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
366	435	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
69	69	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
91	286792	> ff
286701	286701	-> fastfetch $argv
26	56	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
11	60	> fish_mode_prompt
12	49	-> fish_default_mode_prompt
4	37	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
25	25	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
42	224932	> fish_prompt
21	21	-> set -l last_status $status
68	82	-> set -l normal (set_color normal)
14	14	--> set_color normal
61	77	-> set -l status_color (set_color brgreen)
16	16	--> set_color brgreen
42	54	-> set -l cwd_color (set_color $fish_color_cwd)
12	12	--> set_color $fish_color_cwd
38	45	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
10	10	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	98	-> if functions -q fish_is_root_user...
13	13	--> functions -q fish_is_root_user
19	82	--> fish_is_root_user
2	48	---> if test "$EUID" = 0 2>/dev/null...
46	46	----> test "$EUID" = 0 2>/dev/null
3	12	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
3	3	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
176	224469	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
15	338	--> prompt_login
1	10	---> if not set -q __fish_machine...
9	9	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
205	294	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
17	17	----> set_color $fish_color_user
9	9	----> set_color normal
10	10	----> set_color $color_host
16	46	----> prompt_hostname
30	30	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
27	286	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
4	4	---> set -q argv[1]
42	42	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
14	162	---> for path in $argv...
53	64	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
42	64	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	20	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
24	223669	--> fish_vcs_prompt
95	223645	---> fish_git_prompt $argv
11	51579	----> if not command -sq git...
51568	51568	-----> not command -sq git
1	31	----> if functions -q __fish_git_prompt_ready...
30	30	-----> functions -q __fish_git_prompt_ready
142	56910	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56768	56768	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
67	57814	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
45	57747	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
22	78	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
5	43	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	57520	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
6	57507	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	57501	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57412	57412	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
3	6	----> if not set -q ___fish_git_prompt_init...
3	3	-----> not set -q ___fish_git_prompt_init
14	14	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50526	56635	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6109	6109	-----> read -lz key value
7	42	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	73	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	44	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
4	11	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	46	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
72	84	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
4	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
21	21	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
35	35	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	642	> fish_title
7	632	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
6	611	--> if set -q argv[1]...
4	4	---> set -q argv[1]
35	43	---> set -l command (status current-command)
8	8	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
67	546	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
6	6	----> string sub -l 20 -- $command
26	473	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	378	-----> for path in $argv...
56	67	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
56	86	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
30	30	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	210	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	124	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	100	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
43	59	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
45	65	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
120	179	> __fish_enable_bracketed_paste
59	59	-> printf "\e[?2004h"
31	146	> fish_mode_prompt
38	115	-> fish_default_mode_prompt
11	77	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
40	40	---> test "$fish_key_bindings" = fish_vi_key_bindings
26	26	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
168	236733	> fish_prompt
42	42	-> set -l last_status $status
206	236	-> set -l normal (set_color normal)
30	30	--> set_color normal
168	204	-> set -l status_color (set_color brgreen)
36	36	--> set_color brgreen
164	195	-> set -l cwd_color (set_color $fish_color_cwd)
31	31	--> set_color $fish_color_cwd
163	203	-> set -l vcs_color (set_color brpurple)
40	40	--> set_color brpurple
20	20	-> set -l prompt_status ""
12	12	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
15	15	-> set -l suffix '❯'
6	233	-> if functions -q fish_is_root_user...
23	23	--> functions -q fish_is_root_user
30	204	--> fish_is_root_user
6	132	---> if test "$EUID" = 0 2>/dev/null...
126	126	----> test "$EUID" = 0 2>/dev/null
5	31	---> if contains -- $USER root toor Administrator...
26	26	----> contains -- $USER root toor Administrator
11	11	---> return 1
3	23	-> if test $last_status -ne 0...
20	20	--> test $last_status -ne 0
732	235356	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
46	1131	--> prompt_login
3	17	---> if not set -q __fish_machine...
14	14	----> not set -q __fish_machine
4	14	---> if set -q __fish_machine[1]...
10	10	----> set -q __fish_machine[1]
22	22	---> set -l color_host $fish_color_host
3	13	---> if set -q SSH_TTY...
10	10	----> set -q SSH_TTY
800	1019	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
28	28	----> set_color $fish_color_user
36	36	----> set_color normal
30	30	----> set_color $color_host
34	88	----> prompt_hostname
54	54	-----> string replace -r -- "\..*" "" $hostname
37	37	----> set_color normal
104	1007	--> prompt_pwd
62	62	---> set -l options h/help d/dir-length= D/full-length-dirs=
50	50	---> argparse -n prompt_pwd $options -- $argv
6	20	---> if set -q _flag_help...
14	14	----> set -q _flag_help
12	12	---> set -q argv[1]
19	19	---> set argv $PWD
9	9	---> set -ql _flag_d
12	12	---> set -q fish_prompt_pwd_dir_length
15	15	---> set -l fulldirs 0
9	9	---> set -ql _flag_D
10	10	---> set -q fish_prompt_pwd_full_dirs
13	13	---> set -l fish_prompt_pwd_full_dirs 1
55	672	---> for path in $argv...
164	199	----> set -l realhome (string escape --style=regex -- ~)
35	35	-----> string escape --style=regex -- ~
219	337	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
118	118	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
19	81	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
35	35	-----> test "$fish_prompt_pwd_dir_length" -eq 0
27	27	-----> echo $tmp
42	232486	--> fish_vcs_prompt
106	232444	---> fish_git_prompt $argv
13	62547	----> if not command -sq git...
62534	62534	-----> not command -sq git
2	30	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
133	56544	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56411	56411	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
8	8	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
62	56611	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	56549	-----> __fish_git_prompt_operation_branch_bare $repo_info
8	8	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	79	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
4	43	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	12	------> if test -n "$step" -a -n "$total"...
11	11	-------> test -n "$step" -a -n "$total"
8	56324	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56312	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	56310	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56221	56221	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
9	9	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
12	12	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50081	56045	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5964	5964	-----> read -lz key value
7	41	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	72	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	44	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
4	4	----> set -l f ""
17	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
63	79	----> set b (string replace refs/heads/ '' -- $b)
16	16	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
9	35	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	633	> fish_title
7	624	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	604	--> if set -q argv[1]...
4	4	---> set -q argv[1]
35	40	---> set -l command (status current-command)
5	5	----> status current-command
4	13	---> if test "$command" = fish...
5	5	----> test "$command" = fish
4	4	----> set command
66	542	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
29	468	----> prompt_pwd -d 1 -D 1
10	10	-----> set -l options h/help d/dir-length= D/full-length-dirs=
20	20	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	368	-----> for path in $argv...
51	62	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
57	91	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
34	34	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	200	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
6	117	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	94	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	53	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
40	60	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
22	64367	> __fastfetch_complete_config
213	64339	-> for line in (fastfetch --list-presets autocompletion)...
63793	63793	--> fastfetch --list-presets autocompletion
52	52	--> echo -e "$line\tPreset"
7	7	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	-> echo -e "none\tDisable loading config file"
133	376	> __fish_disable_bracketed_paste 'ff -c all.jsonc '
243	243	-> printf "\e[?2004l"
66	2658	> fish_title ff\ -c\ all.jsonc\ 
70	2592	-> if not set -q INSIDE_EMACS...
35	35	--> not set -q INSIDE_EMACS
62	62	--> set -l ssh
49	49	--> set -q SSH_TTY
29	2376	--> if set -q argv[1]...
21	21	---> set -q argv[1]
400	2326	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
38	38	----> string sub -l 20 -- $argv[1]
209	1888	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
11	11	-----> set -q argv[1]
19	19	-----> set argv $PWD
10	10	-----> set -ql _flag_d
21	21	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
17	17	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
56	1443	-----> for path in $argv...
210	245	------> set -l realhome (string escape --style=regex -- ~)
35	35	-------> string escape --style=regex -- ~
189	295	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
106	106	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
25	847	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
30	30	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
33	550	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
166	455	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
188	289	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
101	101	----------> math $fish_prompt_pwd_full_dirs - 1
29	29	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
160	229	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
69	69	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
122	6653975	> ff -c all.jsonc
6653853	6653853	-> fastfetch $argv
43	89	> __fish_enable_bracketed_paste
46	46	-> printf "\e[?2004h"
38	224	> fish_mode_prompt
77	186	-> fish_default_mode_prompt
14	109	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
65	65	---> test "$fish_key_bindings" = fish_vi_key_bindings
30	30	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
135	251343	> fish_prompt
24	24	-> set -l last_status $status
295	450	-> set -l normal (set_color normal)
155	155	--> set_color normal
188	236	-> set -l status_color (set_color brgreen)
48	48	--> set_color brgreen
183	220	-> set -l cwd_color (set_color $fish_color_cwd)
37	37	--> set_color $fish_color_cwd
128	151	-> set -l vcs_color (set_color brpurple)
23	23	--> set_color brpurple
18	18	-> set -l prompt_status ""
8	8	-> set -q fish_prompt_pwd_dir_length
10	10	-> set -lx fish_prompt_pwd_dir_length 0
11	11	-> set -l suffix '❯'
6	313	-> if functions -q fish_is_root_user...
115	115	--> functions -q fish_is_root_user
34	192	--> fish_is_root_user
5	85	---> if test "$EUID" = 0 2>/dev/null...
80	80	----> test "$EUID" = 0 2>/dev/null
6	66	---> if contains -- $USER root toor Administrator...
60	60	----> contains -- $USER root toor Administrator
7	7	---> return 1
2	16	-> if test $last_status -ne 0...
14	14	--> test $last_status -ne 0
313	249739	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
86	817	--> prompt_login
3	14	---> if not set -q __fish_machine...
11	11	----> not set -q __fish_machine
2	10	---> if set -q __fish_machine[1]...
8	8	----> set -q __fish_machine[1]
16	16	---> set -l color_host $fish_color_host
3	9	---> if set -q SSH_TTY...
6	6	----> set -q SSH_TTY
435	682	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
23	23	----> set_color $fish_color_user
21	21	----> set_color normal
23	23	----> set_color $color_host
87	148	----> prompt_hostname
61	61	-----> string replace -r -- "\..*" "" $hostname
32	32	----> set_color normal
77	592	--> prompt_pwd
20	20	---> set -l options h/help d/dir-length= D/full-length-dirs=
29	29	---> argparse -n prompt_pwd $options -- $argv
3	12	---> if set -q _flag_help...
9	9	----> set -q _flag_help
7	7	---> set -q argv[1]
12	12	---> set argv $PWD
6	6	---> set -ql _flag_d
7	7	---> set -q fish_prompt_pwd_dir_length
9	9	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
7	7	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
39	390	---> for path in $argv...
97	120	----> set -l realhome (string escape --style=regex -- ~)
23	23	-----> string escape --style=regex -- ~
120	176	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
56	56	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
12	55	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
26	26	-----> test "$fish_prompt_pwd_dir_length" -eq 0
17	17	-----> echo $tmp
462	248017	--> fish_vcs_prompt
158	247555	---> fish_git_prompt $argv
13	64001	----> if not command -sq git...
63988	63988	-----> not command -sq git
4	92	----> if functions -q __fish_git_prompt_ready...
88	88	-----> functions -q __fish_git_prompt_ready
174	63407	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
63233	63233	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
89	60035	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
38	59946	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
12	12	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
22	77	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	43	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	59720	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	59708	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
101	59706	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
59605	59605	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
5	5	------> echo $bare
7	7	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
12	12	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
3	3	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
52865	59261	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6396	6396	-----> read -lz key value
7	49	----> if not set -q dirty[1]...
20	20	-----> not set -q dirty[1]
22	22	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
21	21	----> contains dirtystate $__fish_git_prompt_status_order
3	18	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
10	10	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
9	9	----> contains untrackedfiles $__fish_git_prompt_status_order
9	79	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	50	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
5	13	------> begin...
8	8	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	17	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
5	5	-------> test "$untracked" = true
5	5	-------> test "$dirty" = true
1	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
7	7	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
13	13	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
22	50	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
63	80	----> set b (string replace refs/heads/ '' -- $b)
17	17	-----> string replace refs/heads/ '' -- $b
3	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	32	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
11	659	> fish_title
8	648	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
6	624	--> if set -q argv[1]...
3	3	---> set -q argv[1]
41	46	---> set -l command (status current-command)
5	5	----> status current-command
2	13	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
69	556	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
25	479	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	381	-----> for path in $argv...
40	51	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
41	70	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
29	29	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	247	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-------> set -l full
7	142	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
44	118	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
53	74	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
21	21	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
50	75	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
25	25	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
29	65123	> __fastfetch_complete_config
243	65089	-> for line in (fastfetch --list-presets autocompletion)...
64516	64516	--> fastfetch --list-presets autocompletion
53	53	--> echo -e "$line\tPreset"
8	8	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	-> echo -e "none\tDisable loading config file"
99	309	> __fish_disable_bracketed_paste 'ff -c archey.jsonc '
210	210	-> printf "\e[?2004l"
60	3505	> fish_title ff\ -c\ archey.jsonc\ 
36	3445	-> if not set -q INSIDE_EMACS...
35	35	--> not set -q INSIDE_EMACS
24	24	--> set -l ssh
17	17	--> set -q SSH_TTY
21	3333	--> if set -q argv[1]...
16	16	---> set -q argv[1]
556	3296	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
72	72	----> string sub -l 20 -- $argv[1]
258	2668	----> prompt_pwd -d 1 -D 1
50	50	-----> set -l options h/help d/dir-length= D/full-length-dirs=
100	100	-----> argparse -n prompt_pwd $options -- $argv
7	26	-----> if set -q _flag_help...
19	19	------> set -q _flag_help
16	16	-----> set -q argv[1]
29	29	-----> set argv $PWD
13	13	-----> set -ql _flag_d
29	29	-----> set -l fish_prompt_pwd_dir_length $_flag_d
15	15	-----> set -q fish_prompt_pwd_dir_length
19	19	-----> set -l fulldirs 0
12	12	-----> set -ql _flag_D
23	23	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
13	13	-----> set -q fish_prompt_pwd_full_dirs
67	2065	-----> for path in $argv...
311	359	------> set -l realhome (string escape --style=regex -- ~)
48	48	-------> string escape --style=regex -- ~
334	445	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
111	111	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
35	1194	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
49	49	-------> test "$fish_prompt_pwd_dir_length" -eq 0
20	20	-------> set -l full
23	783	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
26	26	--------> test $fish_prompt_pwd_full_dirs -gt 0
191	693	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
354	502	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
148	148	----------> math $fish_prompt_pwd_full_dirs - 1
25	25	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
192	307	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
115	115	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
192	1195878	> ff -c archey.jsonc
1195686	1195686	-> fastfetch $argv
64	140	> __fish_enable_bracketed_paste
76	76	-> printf "\e[?2004h"
60	363	> fish_mode_prompt
116	303	-> fish_default_mode_prompt
14	187	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
153	153	---> test "$fish_key_bindings" = fish_vi_key_bindings
20	20	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
117	242038	> fish_prompt
68	68	-> set -l last_status $status
243	366	-> set -l normal (set_color normal)
123	123	--> set_color normal
152	189	-> set -l status_color (set_color brgreen)
37	37	--> set_color brgreen
172	202	-> set -l cwd_color (set_color $fish_color_cwd)
30	30	--> set_color $fish_color_cwd
185	219	-> set -l vcs_color (set_color brpurple)
34	34	--> set_color brpurple
23	23	-> set -l prompt_status ""
13	13	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
16	16	-> set -l suffix '❯'
7	428	-> if functions -q fish_is_root_user...
166	166	--> functions -q fish_is_root_user
50	255	--> fish_is_root_user
6	115	---> if test "$EUID" = 0 2>/dev/null...
109	109	----> test "$EUID" = 0 2>/dev/null
4	79	---> if contains -- $USER root toor Administrator...
75	75	----> contains -- $USER root toor Administrator
11	11	---> return 1
4	23	-> if test $last_status -ne 0...
19	19	--> test $last_status -ne 0
386	240348	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
179	1936	--> prompt_login
12	29	---> if not set -q __fish_machine...
17	17	----> not set -q __fish_machine
2	16	---> if set -q __fish_machine[1]...
14	14	----> set -q __fish_machine[1]
209	209	---> set -l color_host $fish_color_host
5	23	---> if set -q SSH_TTY...
18	18	----> set -q SSH_TTY
1012	1480	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
49	49	----> set_color $fish_color_user
24	24	----> set_color normal
53	53	----> set_color $color_host
176	291	----> prompt_hostname
115	115	-----> string replace -r -- "\..*" "" $hostname
51	51	----> set_color normal
75	769	--> prompt_pwd
32	32	---> set -l options h/help d/dir-length= D/full-length-dirs=
56	56	---> argparse -n prompt_pwd $options -- $argv
4	17	---> if set -q _flag_help...
13	13	----> set -q _flag_help
11	11	---> set -q argv[1]
18	18	---> set argv $PWD
9	9	---> set -ql _flag_d
10	10	---> set -q fish_prompt_pwd_dir_length
14	14	---> set -l fulldirs 0
8	8	---> set -ql _flag_D
10	10	---> set -q fish_prompt_pwd_full_dirs
12	12	---> set -l fish_prompt_pwd_full_dirs 1
52	497	---> for path in $argv...
166	192	----> set -l realhome (string escape --style=regex -- ~)
26	26	-----> string escape --style=regex -- ~
136	198	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
62	62	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
15	55	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
21	21	-----> test "$fish_prompt_pwd_dir_length" -eq 0
19	19	-----> echo $tmp
98	237257	--> fish_vcs_prompt
156	237159	---> fish_git_prompt $argv
10	62940	----> if not command -sq git...
62930	62930	-----> not command -sq git
3	77	----> if functions -q __fish_git_prompt_ready...
74	74	-----> functions -q __fish_git_prompt_ready
139	57479	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57340	57340	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
11	11	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
8	8	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
59	58293	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	58234	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
5	5	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
28	81	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
6	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	58009	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	57997	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
85	57994	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57909	57909	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
5	5	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
51766	57637	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5871	5871	-----> read -lz key value
9	41	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
10	79	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
12	49	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	16	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
20	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
57	70	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
3	30	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
27	27	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	31	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
8	582	> fish_title
8	574	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
5	552	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	43	---> set -l command (status current-command)
5	5	----> status current-command
2	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
5	5	----> set command
63	488	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
27	417	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	319	-----> for path in $argv...
38	49	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
37	58	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	199	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	122	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	100	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
43	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
40	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
153	447	> up-or-search
8	72	-> if commandline --search-mode...
64	64	--> commandline --search-mode
4	11	-> if commandline --paging-mode...
7	7	--> commandline --paging-mode
164	180	-> set -l lineno (commandline -L)
16	16	--> commandline -L
15	31	-> switch $lineno...
16	16	--> commandline -f history-search-backward
26	64546	> __fastfetch_complete_config
219	64514	-> for line in (fastfetch --list-presets autocompletion)...
63988	63988	--> fastfetch --list-presets autocompletion
24	24	--> echo -e "$line\tPreset"
8	8	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	-> echo -e "none\tDisable loading config file"
87	149	> __fish_disable_bracketed_paste 'ff -c neofetch.jsonc '
62	62	-> printf "\e[?2004l"
56	3568	> fish_title ff\ -c\ neofetch.jsonc\ 
36	3512	-> if not set -q INSIDE_EMACS...
33	33	--> not set -q INSIDE_EMACS
24	24	--> set -l ssh
17	17	--> set -q SSH_TTY
22	3402	--> if set -q argv[1]...
16	16	---> set -q argv[1]
563	3364	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
47	47	----> string sub -l 20 -- $argv[1]
139	2754	----> prompt_pwd -d 1 -D 1
48	48	-----> set -l options h/help d/dir-length= D/full-length-dirs=
98	98	-----> argparse -n prompt_pwd $options -- $argv
5	25	-----> if set -q _flag_help...
20	20	------> set -q _flag_help
16	16	-----> set -q argv[1]
28	28	-----> set argv $PWD
13	13	-----> set -ql _flag_d
28	28	-----> set -l fish_prompt_pwd_dir_length $_flag_d
14	14	-----> set -q fish_prompt_pwd_dir_length
19	19	-----> set -l fulldirs 0
12	12	-----> set -ql _flag_D
23	23	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
13	13	-----> set -q fish_prompt_pwd_full_dirs
66	2278	-----> for path in $argv...
212	259	------> set -l realhome (string escape --style=regex -- ~)
47	47	-------> string escape --style=regex -- ~
277	371	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
94	94	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
39	1582	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
52	52	-------> test "$fish_prompt_pwd_dir_length" -eq 0
23	23	-------> set -l full
39	985	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
25	25	--------> test $fish_prompt_pwd_full_dirs -gt 0
353	855	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
412	502	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
90	90	----------> math $fish_prompt_pwd_full_dirs - 1
42	42	--------> set tmp $all[1]
24	24	--------> set full $all[2..]
377	483	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
106	106	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
117	341806	> ff -c neofetch.jsonc
341689	341689	-> fastfetch $argv
41	138	> __fish_enable_bracketed_paste
97	97	-> printf "\e[?2004h"
18	70	> fish_mode_prompt
14	52	-> fish_default_mode_prompt
7	38	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
25	25	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
30	225138	> fish_prompt
13	13	-> set -l last_status $status
44	56	-> set -l normal (set_color normal)
12	12	--> set_color normal
38	48	-> set -l status_color (set_color brgreen)
10	10	--> set_color brgreen
38	49	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
45	52	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	90	-> if functions -q fish_is_root_user...
9	9	--> functions -q fish_is_root_user
14	79	--> fish_is_root_user
1	50	---> if test "$EUID" = 0 2>/dev/null...
49	49	----> test "$EUID" = 0 2>/dev/null
1	11	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
8	15	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
184	224752	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
18	287	--> prompt_login
1	8	---> if not set -q __fish_machine...
7	7	----> not set -q __fish_machine
0	4	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
2	5	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
175	245	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
10	39	----> prompt_hostname
29	29	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
23	286	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
16	207	---> for path in $argv...
80	91	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
61	82	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
12	223995	--> fish_vcs_prompt
102	223983	---> fish_git_prompt $argv
13	51238	----> if not command -sq git...
51225	51225	-----> not command -sq git
5	39	----> if functions -q __fish_git_prompt_ready...
34	34	-----> functions -q __fish_git_prompt_ready
149	57168	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57019	57019	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
63	57290	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
39	57227	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
3	3	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
3	3	------> set -l total
24	81	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
9	45	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
9	57002	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	56989	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
94	56985	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56891	56891	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
12	12	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
5	5	------> echo $bare
9	9	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
9	9	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
51634	57531	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5897	5897	-----> read -lz key value
6	39	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
4	17	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
9	9	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	72	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
8	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
0	6	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
3	3	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
72	84	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
6	41	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
35	35	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
7	43	----> if test -n "$b"...
8	8	-----> test -n "$b"
10	10	-----> set b "$branch_color$b$branch_done"
5	18	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
8	8	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	620	> fish_title
7	610	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	589	--> if set -q argv[1]...
4	4	---> set -q argv[1]
40	45	---> set -l command (status current-command)
5	5	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
66	522	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
23	447	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	354	-----> for path in $argv...
38	51	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
38	61	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	230	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	139	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
45	112	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
52	67	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
47	72	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
25	25	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
89	650	> up-or-search
12	84	-> if commandline --search-mode...
72	72	--> commandline --search-mode
5	17	-> if commandline --paging-mode...
12	12	--> commandline --paging-mode
366	413	-> set -l lineno (commandline -L)
47	47	--> commandline -L
23	47	-> switch $lineno...
24	24	--> commandline -f history-search-backward
28	64333	> __fastfetch_complete_config
259	64299	-> for line in (fastfetch --list-presets autocompletion)...
63730	63730	--> fastfetch --list-presets autocompletion
26	26	--> echo -e "$line\tPreset"
8	8	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
7	7	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
6	6	-> echo -e "none\tDisable loading config file"
62	203	> __fish_disable_bracketed_paste 'ff -c ci.jsonc '
141	141	-> printf "\e[?2004l"
41	2564	> fish_title ff\ -c\ ci.jsonc\ 
39	2523	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
20	2433	--> if set -q argv[1]...
11	11	---> set -q argv[1]
436	2402	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
33	33	----> string sub -l 20 -- $argv[1]
180	1933	----> prompt_pwd -d 1 -D 1
41	41	-----> set -l options h/help d/dir-length= D/full-length-dirs=
65	65	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
46	1517	-----> for path in $argv...
130	161	------> set -l realhome (string escape --style=regex -- ~)
31	31	-------> string escape --style=regex -- ~
187	262	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
75	75	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
33	1048	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
35	35	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
34	662	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
220	565	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
239	345	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
106	106	----------> math $fish_prompt_pwd_full_dirs - 1
29	29	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
229	303	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
74	74	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
222	5684725	> ff -c ci.jsonc
5684503	5684503	-> fastfetch $argv
87	128	> __fish_enable_bracketed_paste
41	41	-> printf "\e[?2004h"
36	169	> fish_mode_prompt
80	133	-> fish_default_mode_prompt
6	53	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
33	33	---> test "$fish_key_bindings" = fish_vi_key_bindings
14	14	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
62	237047	> fish_prompt
25	25	-> set -l last_status $status
206	282	-> set -l normal (set_color normal)
76	76	--> set_color normal
116	139	-> set -l status_color (set_color brgreen)
23	23	--> set_color brgreen
95	117	-> set -l cwd_color (set_color $fish_color_cwd)
22	22	--> set_color $fish_color_cwd
92	112	-> set -l vcs_color (set_color brpurple)
20	20	--> set_color brpurple
14	14	-> set -l prompt_status ""
9	9	-> set -q fish_prompt_pwd_dir_length
8	8	-> set -lx fish_prompt_pwd_dir_length 0
9	9	-> set -l suffix '❯'
4	267	-> if functions -q fish_is_root_user...
97	97	--> functions -q fish_is_root_user
30	166	--> fish_is_root_user
4	76	---> if test "$EUID" = 0 2>/dev/null...
72	72	----> test "$EUID" = 0 2>/dev/null
2	54	---> if contains -- $USER root toor Administrator...
52	52	----> contains -- $USER root toor Administrator
6	6	---> return 1
2	13	-> if test $last_status -ne 0...
11	11	--> test $last_status -ne 0
263	235975	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
68	751	--> prompt_login
2	11	---> if not set -q __fish_machine...
9	9	----> not set -q __fish_machine
2	8	---> if set -q __fish_machine[1]...
6	6	----> set -q __fish_machine[1]
13	13	---> set -l color_host $fish_color_host
2	8	---> if set -q SSH_TTY...
6	6	----> set -q SSH_TTY
419	643	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
18	18	----> set_color $fish_color_user
21	21	----> set_color normal
30	30	----> set_color $color_host
93	140	----> prompt_hostname
47	47	-----> string replace -r -- "\..*" "" $hostname
15	15	----> set_color normal
71	522	--> prompt_pwd
26	26	---> set -l options h/help d/dir-length= D/full-length-dirs=
31	31	---> argparse -n prompt_pwd $options -- $argv
3	10	---> if set -q _flag_help...
7	7	----> set -q _flag_help
7	7	---> set -q argv[1]
11	11	---> set argv $PWD
5	5	---> set -ql _flag_d
5	5	---> set -q fish_prompt_pwd_dir_length
7	7	---> set -l fulldirs 0
5	5	---> set -ql _flag_D
6	6	---> set -q fish_prompt_pwd_full_dirs
7	7	---> set -l fish_prompt_pwd_full_dirs 1
30	331	---> for path in $argv...
103	129	----> set -l realhome (string escape --style=regex -- ~)
26	26	-----> string escape --style=regex -- ~
88	132	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
44	44	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	40	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
18	18	-----> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-----> echo $tmp
74	234439	--> fish_vcs_prompt
140	234365	---> fish_git_prompt $argv
12	58590	----> if not command -sq git...
58578	58578	-----> not command -sq git
3	66	----> if functions -q __fish_git_prompt_ready...
63	63	-----> functions -q __fish_git_prompt_ready
126	60717	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
60591	60591	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
62	57248	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	57186	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
7	7	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	79	------> if test -d $git_dir/rebase-merge...
15	15	-------> test -d $git_dir/rebase-merge
5	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
2	10	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	56960	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	56948	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
90	56945	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56855	56855	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
2	9	----> if not set -q ___fish_git_prompt_init...
7	7	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
5	5	----> set -l dirty
5	5	----> set -l untracked
51115	57010	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5895	5895	-----> read -lz key value
5	39	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
16	16	----> contains dirtystate $__fish_git_prompt_status_order
10	25	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
10	10	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	74	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
6	45	-----> if test "$informative" = true...
7	7	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	16	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
3	9	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	50	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
61	75	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
2	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	32	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
15	15	-> echo -n -s $status_color $suffix ' ' $normal
10	660	> fish_title
8	650	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
11	627	--> if set -q argv[1]...
4	4	---> set -q argv[1]
39	45	---> set -l command (status current-command)
6	6	----> status current-command
3	14	---> if test "$command" = fish...
6	6	----> test "$command" = fish
5	5	----> set command
70	553	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
36	476	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
19	367	-----> for path in $argv...
48	61	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
55	82	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	205	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
4	116	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	95	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	54	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
46	67	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
54	201	> __fish_disable_bracketed_paste ff
147	147	-> printf "\e[?2004l"
34	2076	> fish_title ff
22	2042	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
13	1969	--> if set -q argv[1]...
11	11	---> set -q argv[1]
384	1945	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
36	36	----> string sub -l 20 -- $argv[1]
184	1525	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
69	69	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
17	17	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
40	1102	-----> for path in $argv...
135	168	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
137	201	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
64	64	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
29	693	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
12	12	-------> set -l full
18	402	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
114	334	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
121	220	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
99	99	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
14	14	--------> set full $all[2..]
167	222	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
55	55	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
107	284925	> ff
284818	284818	-> fastfetch $argv
26	61	> __fish_enable_bracketed_paste
35	35	-> printf "\e[?2004h"
15	94	> fish_mode_prompt
43	79	-> fish_default_mode_prompt
5	36	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
23	23	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
30	224804	> fish_prompt
16	16	-> set -l last_status $status
52	91	-> set -l normal (set_color normal)
39	39	--> set_color normal
39	49	-> set -l status_color (set_color brgreen)
10	10	--> set_color brgreen
36	46	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
88	95	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
13	13	-> set -l prompt_status ""
7	7	-> set -q fish_prompt_pwd_dir_length
6	6	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
3	193	-> if functions -q fish_is_root_user...
83	83	--> functions -q fish_is_root_user
21	107	--> fish_is_root_user
2	51	---> if test "$EUID" = 0 2>/dev/null...
49	49	----> test "$EUID" = 0 2>/dev/null
2	31	---> if contains -- $USER root toor Administrator...
29	29	----> contains -- $USER root toor Administrator
4	4	---> return 1
0	8	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
133	224232	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
39	374	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
2	5	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
197	310	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
7	7	----> set_color normal
9	9	----> set_color $color_host
43	75	----> prompt_hostname
32	32	-----> string replace -r -- "\..*" "" $hostname
10	10	----> set_color normal
26	324	--> prompt_pwd
10	10	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
23	236	---> for path in $argv...
53	84	----> set -l realhome (string escape --style=regex -- ~)
31	31	-----> string escape --style=regex -- ~
65	104	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
39	39	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	25	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-----> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-----> echo $tmp
45	223401	--> fish_vcs_prompt
118	223356	---> fish_git_prompt $argv
20	51508	----> if not command -sq git...
51488	51488	-----> not command -sq git
4	84	----> if functions -q __fish_git_prompt_ready...
80	80	-----> functions -q __fish_git_prompt_ready
144	56283	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56139	56139	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
8	8	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
62	57858	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
38	57796	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	81	------> if test -d $git_dir/rebase-merge...
14	14	-------> test -d $git_dir/rebase-merge
6	43	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
8	57573	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	57561	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	57559	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57470	57470	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50975	56933	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5958	5958	-----> read -lz key value
6	43	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
18	18	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
6	17	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	73	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	45	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
5	12	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
2	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
61	73	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	32	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	574	> fish_title
6	564	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
4	543	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	43	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
64	480	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
23	409	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	312	-----> for path in $argv...
36	47	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
38	58	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	195	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
8	118	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	94	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	57	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
19	19	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
40	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
26	63342	> __fastfetch_complete_config
225	63310	-> for line in (fastfetch --list-presets autocompletion)...
62779	62779	--> fastfetch --list-presets autocompletion
25	25	--> echo -e "$line\tPreset"
7	7	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
7	7	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	-> echo -e "none\tDisable loading config file"
31	63131	> __fastfetch_complete_config
260	63094	-> for line in (fastfetch --list-presets autocompletion)...
62525	62525	--> fastfetch --list-presets autocompletion
25	25	--> echo -e "$line\tPreset"
14	14	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	-> echo -e "none\tDisable loading config file"
89	164	> __fish_disable_bracketed_paste 'ff -c examples/2.jsonc '
75	75	-> printf "\e[?2004l"
53	3161	> fish_title ff\ -c\ examples/2.jsonc\ 
31	3108	-> if not set -q INSIDE_EMACS...
35	35	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
15	15	--> set -q SSH_TTY
15	3002	--> if set -q argv[1]...
15	15	---> set -q argv[1]
434	2972	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
47	47	----> string sub -l 20 -- $argv[1]
134	2491	----> prompt_pwd -d 1 -D 1
58	58	-----> set -l options h/help d/dir-length= D/full-length-dirs=
102	102	-----> argparse -n prompt_pwd $options -- $argv
7	26	-----> if set -q _flag_help...
19	19	------> set -q _flag_help
16	16	-----> set -q argv[1]
28	28	-----> set argv $PWD
14	14	-----> set -ql _flag_d
30	30	-----> set -l fish_prompt_pwd_dir_length $_flag_d
14	14	-----> set -q fish_prompt_pwd_dir_length
18	18	-----> set -l fulldirs 0
13	13	-----> set -ql _flag_D
23	23	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
13	13	-----> set -q fish_prompt_pwd_full_dirs
102	2002	-----> for path in $argv...
212	261	------> set -l realhome (string escape --style=regex -- ~)
49	49	-------> string escape --style=regex -- ~
261	373	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
112	112	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
68	1266	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
79	79	-------> test "$fish_prompt_pwd_dir_length" -eq 0
24	24	-------> set -l full
37	817	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
26	26	--------> test $fish_prompt_pwd_full_dirs -gt 0
333	678	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
286	345	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
59	59	----------> math $fish_prompt_pwd_full_dirs - 1
42	42	--------> set tmp $all[1]
34	34	--------> set full $all[2..]
208	278	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
70	70	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
136	1227863	> ff -c examples/2.jsonc
1227727	1227727	-> fastfetch $argv
38	90	> __fish_enable_bracketed_paste
52	52	-> printf "\e[?2004h"
54	164	> fish_mode_prompt
37	110	-> fish_default_mode_prompt
20	73	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
37	37	---> test "$fish_key_bindings" = fish_vi_key_bindings
16	16	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
49	234941	> fish_prompt
20	20	-> set -l last_status $status
58	70	-> set -l normal (set_color normal)
12	12	--> set_color normal
106	120	-> set -l status_color (set_color brgreen)
14	14	--> set_color brgreen
110	142	-> set -l cwd_color (set_color $fish_color_cwd)
32	32	--> set_color $fish_color_cwd
83	95	-> set -l vcs_color (set_color brpurple)
12	12	--> set_color brpurple
13	13	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
6	6	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
4	159	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
19	145	--> fish_is_root_user
4	74	---> if test "$EUID" = 0 2>/dev/null...
70	70	----> test "$EUID" = 0 2>/dev/null
5	44	---> if contains -- $USER root toor Administrator...
39	39	----> contains -- $USER root toor Administrator
8	8	---> return 1
2	16	-> if test $last_status -ne 0...
14	14	--> test $last_status -ne 0
205	234229	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
32	691	--> prompt_login
24	32	---> if not set -q __fish_machine...
8	8	----> not set -q __fish_machine
10	24	---> if set -q __fish_machine[1]...
14	14	----> set -q __fish_machine[1]
13	13	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
436	585	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
18	18	----> set_color $fish_color_user
14	14	----> set_color normal
46	46	----> set_color $color_host
21	60	----> prompt_hostname
39	39	-----> string replace -r -- "\..*" "" $hostname
11	11	----> set_color normal
38	441	--> prompt_pwd
16	16	---> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
4	4	---> set -q argv[1]
9	9	---> set argv $PWD
4	4	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
6	6	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
27	322	---> for path in $argv...
69	82	----> set -l realhome (string escape --style=regex -- ~)
13	13	-----> string escape --style=regex -- ~
79	155	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
76	76	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	58	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
13	13	-----> test "$fish_prompt_pwd_dir_length" -eq 0
40	40	-----> echo $tmp
13	232892	--> fish_vcs_prompt
90	232879	---> fish_git_prompt $argv
12	56628	----> if not command -sq git...
56616	56616	-----> not command -sq git
2	29	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
142	59721	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
59579	59579	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
23	23	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
67	58472	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
38	58405	-----> __fish_git_prompt_operation_branch_bare $repo_info
12	12	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
6	6	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
25	80	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	43	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
10	58180	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	58166	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
111	58164	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58053	58053	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
14	14	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
51152	57319	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6167	6167	-----> read -lz key value
9	47	----> if not set -q dirty[1]...
21	21	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
15	15	----> contains dirtystate $__fish_git_prompt_status_order
5	18	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
9	9	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	76	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
8	47	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
5	12	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
2	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
21	50	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
69	87	----> set b (string replace refs/heads/ '' -- $b)
18	18	-----> string replace refs/heads/ '' -- $b
4	36	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
32	32	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
7	42	----> if test -n "$b"...
8	8	-----> test -n "$b"
9	9	-----> set b "$branch_color$b$branch_done"
3	18	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
9	9	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
0	4	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
8	8	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
26	26	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	680	> fish_title
10	670	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
7	646	--> if set -q argv[1]...
3	3	---> set -q argv[1]
50	56	---> set -l command (status current-command)
6	6	----> status current-command
2	16	---> if test "$command" = fish...
10	10	----> test "$command" = fish
4	4	----> set command
68	564	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
27	489	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
25	25	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
17	389	-----> for path in $argv...
54	66	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
57	86	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
29	29	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	220	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
9	134	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
48	108	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
43	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
45	64	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
255	778	> up-or-search
12	104	-> if commandline --search-mode...
92	92	--> commandline --search-mode
5	19	-> if commandline --paging-mode...
14	14	--> commandline --paging-mode
306	342	-> set -l lineno (commandline -L)
36	36	--> commandline -L
28	58	-> switch $lineno...
30	30	--> commandline -f history-search-backward
87	150	> __fish_disable_bracketed_paste 'ff -c examples/3.jsonc'
63	63	-> printf "\e[?2004l"
53	3551	> fish_title ff\ -c\ examples/3.jsonc
48	3498	-> if not set -q INSIDE_EMACS...
34	34	--> not set -q INSIDE_EMACS
28	28	--> set -l ssh
16	16	--> set -q SSH_TTY
39	3372	--> if set -q argv[1]...
16	16	---> set -q argv[1]
706	3317	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
47	47	----> string sub -l 20 -- $argv[1]
133	2564	----> prompt_pwd -d 1 -D 1
49	49	-----> set -l options h/help d/dir-length= D/full-length-dirs=
102	102	-----> argparse -n prompt_pwd $options -- $argv
7	26	-----> if set -q _flag_help...
19	19	------> set -q _flag_help
16	16	-----> set -q argv[1]
28	28	-----> set argv $PWD
13	13	-----> set -ql _flag_d
33	33	-----> set -l fish_prompt_pwd_dir_length $_flag_d
15	15	-----> set -q fish_prompt_pwd_dir_length
19	19	-----> set -l fulldirs 0
13	13	-----> set -ql _flag_D
26	26	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
14	14	-----> set -q fish_prompt_pwd_full_dirs
60	2077	-----> for path in $argv...
205	255	------> set -l realhome (string escape --style=regex -- ~)
50	50	-------> string escape --style=regex -- ~
213	310	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
97	97	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
37	1452	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
42	42	-------> test "$fish_prompt_pwd_dir_length" -eq 0
19	19	-------> set -l full
48	845	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
24	24	--------> test $fish_prompt_pwd_full_dirs -gt 0
292	704	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
282	412	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
130	130	----------> math $fish_prompt_pwd_full_dirs - 1
45	45	--------> set tmp $all[1]
24	24	--------> set full $all[2..]
375	509	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
134	134	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
107	149407	> ff -c examples/3.jsonc
149300	149300	-> fastfetch $argv
24	58	> __fish_enable_bracketed_paste
34	34	-> printf "\e[?2004h"
12	62	> fish_mode_prompt
17	50	-> fish_default_mode_prompt
4	33	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
23	23	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
29	223475	> fish_prompt
13	13	-> set -l last_status $status
41	52	-> set -l normal (set_color normal)
11	11	--> set_color normal
39	49	-> set -l status_color (set_color brgreen)
10	10	--> set_color brgreen
108	118	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
87	113	-> set -l vcs_color (set_color brpurple)
26	26	--> set_color brpurple
7	7	-> set -l prompt_status ""
7	7	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
5	88	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
14	73	--> fish_is_root_user
2	44	---> if test "$EUID" = 0 2>/dev/null...
42	42	----> test "$EUID" = 0 2>/dev/null
2	11	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
2	10	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
137	222966	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
18	388	--> prompt_login
1	8	---> if not set -q __fish_machine...
7	7	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
234	343	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
13	13	----> set_color $fish_color_user
8	8	----> set_color normal
25	25	----> set_color $color_host
17	54	----> prompt_hostname
37	37	-----> string replace -r -- "\..*" "" $hostname
9	9	----> set_color normal
32	263	--> prompt_pwd
11	11	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
8	8	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
14	166	---> for path in $argv...
48	63	----> set -l realhome (string escape --style=regex -- ~)
15	15	-----> string escape --style=regex -- ~
42	68	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	21	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-----> echo $tmp
11	222178	--> fish_vcs_prompt
99	222167	---> fish_git_prompt $argv
11	50676	----> if not command -sq git...
50665	50665	-----> not command -sq git
2	29	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
133	56767	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56634	56634	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
9	9	----> set -l sha $repo_info[5]
62	57714	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	57652	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	76	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
10	57396	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	57382	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
86	57379	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57293	57293	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
44	44	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
14	14	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50251	56275	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6024	6024	-----> read -lz key value
7	39	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
2	14	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	76	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	48	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	19	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
8	8	-------> test "$dirty" = true
3	9	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
1	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
11	11	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
8	8	----> set -l f ""
17	46	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
61	74	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
1	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	31	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	6	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
59	59	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
11	783	> fish_title
9	772	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
6	747	--> if set -q argv[1]...
3	3	---> set -q argv[1]
41	47	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
67	678	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
49	604	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
2	2	-----> set -q fish_prompt_pwd_full_dirs
17	484	-----> for path in $argv...
52	63	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
56	94	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
38	38	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	310	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
11	211	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
89	181	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
52	92	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
40	40	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
52	77	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
25	25	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
145	588	> up-or-search
14	60	-> if commandline --search-mode...
46	46	--> commandline --search-mode
5	18	-> if commandline --paging-mode...
13	13	--> commandline --paging-mode
279	310	-> set -l lineno (commandline -L)
31	31	--> commandline -L
26	55	-> switch $lineno...
29	29	--> commandline -f history-search-backward
81	136	> __fish_disable_bracketed_paste 'ff -c examples/4.jsonc'
55	55	-> printf "\e[?2004l"
34	1362	> fish_title ff\ -c\ examples/4.jsonc
14	1328	-> if not set -q INSIDE_EMACS...
15	15	--> not set -q INSIDE_EMACS
9	9	--> set -l ssh
6	6	--> set -q SSH_TTY
7	1284	--> if set -q argv[1]...
7	7	---> set -q argv[1]
192	1270	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
19	19	----> string sub -l 20 -- $argv[1]
63	1059	----> prompt_pwd -d 1 -D 1
18	18	-----> set -l options h/help d/dir-length= D/full-length-dirs=
39	39	-----> argparse -n prompt_pwd $options -- $argv
3	10	-----> if set -q _flag_help...
7	7	------> set -q _flag_help
6	6	-----> set -q argv[1]
11	11	-----> set argv $PWD
6	6	-----> set -ql _flag_d
11	11	-----> set -l fish_prompt_pwd_dir_length $_flag_d
6	6	-----> set -q fish_prompt_pwd_dir_length
8	8	-----> set -l fulldirs 0
5	5	-----> set -ql _flag_D
9	9	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
5	5	-----> set -q fish_prompt_pwd_full_dirs
32	862	-----> for path in $argv...
107	158	------> set -l realhome (string escape --style=regex -- ~)
51	51	-------> string escape --style=regex -- ~
93	138	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
45	45	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
16	534	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
17	17	-------> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-------> set -l full
22	289	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
10	10	--------> test $fish_prompt_pwd_full_dirs -gt 0
110	231	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
98	121	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
23	23	----------> math $fish_prompt_pwd_full_dirs - 1
16	16	--------> set tmp $all[1]
10	10	--------> set full $all[2..]
143	204	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
61	61	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
187	125009	> ff -c examples/4.jsonc
124822	124822	-> fastfetch $argv
31	93	> __fish_enable_bracketed_paste
62	62	-> printf "\e[?2004h"
16	86	> fish_mode_prompt
40	70	-> fish_default_mode_prompt
3	30	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
40	223593	> fish_prompt
37	37	-> set -l last_status $status
130	250	-> set -l normal (set_color normal)
120	120	--> set_color normal
158	205	-> set -l status_color (set_color brgreen)
47	47	--> set_color brgreen
95	130	-> set -l cwd_color (set_color $fish_color_cwd)
35	35	--> set_color $fish_color_cwd
77	125	-> set -l vcs_color (set_color brpurple)
48	48	--> set_color brpurple
9	9	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	219	-> if functions -q fish_is_root_user...
98	98	--> functions -q fish_is_root_user
13	119	--> fish_is_root_user
3	36	---> if test "$EUID" = 0 2>/dev/null...
33	33	----> test "$EUID" = 0 2>/dev/null
1	65	---> if contains -- $USER root toor Administrator...
64	64	----> contains -- $USER root toor Administrator
5	5	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
168	222545	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
44	809	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
482	740	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
13	13	----> set_color $fish_color_user
7	7	----> set_color normal
15	15	----> set_color $color_host
159	213	----> prompt_hostname
54	54	-----> string replace -r -- "\..*" "" $hostname
10	10	----> set_color normal
30	373	--> prompt_pwd
15	15	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
2	7	---> if set -q _flag_help...
5	5	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
6	6	---> set -l fish_prompt_pwd_full_dirs 1
24	272	---> for path in $argv...
62	73	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
116	150	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
34	34	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	25	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-----> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-----> echo $tmp
51	221195	--> fish_vcs_prompt
131	221144	---> fish_git_prompt $argv
11	51444	----> if not command -sq git...
51433	51433	-----> not command -sq git
3	69	----> if functions -q __fish_git_prompt_ready...
66	66	-----> functions -q __fish_git_prompt_ready
137	55890	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
55753	55753	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
11	11	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
65	56257	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
37	56192	-----> __fish_git_prompt_operation_branch_bare $repo_info
15	15	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
23	76	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
2	10	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
7	55968	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	55957	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
86	55955	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
55869	55869	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50897	56763	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5866	5866	-----> read -lz key value
8	42	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	75	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
7	45	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	46	----> for i in $__fish_git_prompt_status_order...
2	8	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
80	93	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	30	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
5	5	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
25	25	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
10	578	> fish_title
5	568	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
6	548	--> if set -q argv[1]...
3	3	---> set -q argv[1]
36	42	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
64	484	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
24	413	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	322	-----> for path in $argv...
41	52	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
39	59	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	197	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	116	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	94	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	55	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
42	60	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
106	702	> up-or-search
12	84	-> if commandline --search-mode...
72	72	--> commandline --search-mode
6	18	-> if commandline --paging-mode...
12	12	--> commandline --paging-mode
393	437	-> set -l lineno (commandline -L)
44	44	--> commandline -L
27	57	-> switch $lineno...
30	30	--> commandline -f history-search-backward
89	151	> __fish_disable_bracketed_paste 'ff -c examples/5.jsonc'
62	62	-> printf "\e[?2004l"
56	2510	> fish_title ff\ -c\ examples/5.jsonc
34	2454	-> if not set -q INSIDE_EMACS...
33	33	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
16	16	--> set -q SSH_TTY
22	2346	--> if set -q argv[1]...
16	16	---> set -q argv[1]
546	2308	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
53	53	----> string sub -l 20 -- $argv[1]
122	1709	----> prompt_pwd -d 1 -D 1
48	48	-----> set -l options h/help d/dir-length= D/full-length-dirs=
113	113	-----> argparse -n prompt_pwd $options -- $argv
7	27	-----> if set -q _flag_help...
20	20	------> set -q _flag_help
16	16	-----> set -q argv[1]
29	29	-----> set argv $PWD
14	14	-----> set -ql _flag_d
30	30	-----> set -l fish_prompt_pwd_dir_length $_flag_d
14	14	-----> set -q fish_prompt_pwd_dir_length
29	29	-----> set -l fulldirs 0
38	38	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
46	1206	-----> for path in $argv...
187	219	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
174	266	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
92	92	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
40	675	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
31	31	-------> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-------> set -l full
18	352	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
118	281	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
124	163	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
39	39	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
175	238	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
63	63	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
112	93453	> ff -c examples/5.jsonc
93341	93341	-> fastfetch $argv
25	58	> __fish_enable_bracketed_paste
33	33	-> printf "\e[?2004h"
34	80	> fish_mode_prompt
13	46	-> fish_default_mode_prompt
3	33	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
22	22	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
105	223983	> fish_prompt
51	51	-> set -l last_status $status
166	178	-> set -l normal (set_color normal)
12	12	--> set_color normal
53	68	-> set -l status_color (set_color brgreen)
15	15	--> set_color brgreen
38	50	-> set -l cwd_color (set_color $fish_color_cwd)
12	12	--> set_color $fish_color_cwd
77	84	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
9	9	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
4	83	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
11	68	--> fish_is_root_user
3	40	---> if test "$EUID" = 0 2>/dev/null...
37	37	----> test "$EUID" = 0 2>/dev/null
4	13	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
203	223321	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	399	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
247	361	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
46	46	----> set_color $fish_color_user
7	7	----> set_color normal
11	11	----> set_color $color_host
12	43	----> prompt_hostname
31	31	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
21	264	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
18	184	---> for path in $argv...
54	65	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
61	82	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	19	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
24	222455	--> fish_vcs_prompt
99	222431	---> fish_git_prompt $argv
10	50778	----> if not command -sq git...
50768	50768	-----> not command -sq git
1	32	----> if functions -q __fish_git_prompt_ready...
31	31	-----> functions -q __fish_git_prompt_ready
165	57183	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57018	57018	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
8	8	----> set -l sha $repo_info[5]
62	57548	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
45	57486	-----> __fish_git_prompt_operation_branch_bare $repo_info
14	14	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
7	7	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
30	86	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
4	44	-------> if test -d $git_dir/rebase-apply...
9	9	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
9	57242	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
6	57228	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
95	57222	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57127	57127	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
2	8	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50249	56208	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5959	5959	-----> read -lz key value
8	49	----> if not set -q dirty[1]...
23	23	-----> not set -q dirty[1]
18	18	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
4	16	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
7	74	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	47	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
5	14	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	6	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	5	-----> if test -n "$$i"...
3	3	------> test -n "$$i"
61	73	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
4	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
2	6	----> if test -n "$p"...
4	4	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	638	> fish_title
6	629	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
6	609	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	43	---> set -l command (status current-command)
6	6	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
65	545	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
30	473	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
2	2	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
2	2	-----> set -q fish_prompt_pwd_full_dirs
16	373	-----> for path in $argv...
49	63	------> set -l realhome (string escape --style=regex -- ~)
14	14	-------> string escape --style=regex -- ~
54	84	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
30	30	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	210	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	125	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	99	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	58	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
18	18	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	62	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
131	760	> up-or-search
13	46	-> if commandline --search-mode...
33	33	--> commandline --search-mode
5	17	-> if commandline --paging-mode...
12	12	--> commandline --paging-mode
461	506	-> set -l lineno (commandline -L)
45	45	--> commandline -L
28	60	-> switch $lineno...
32	32	--> commandline -f history-search-backward
26	45	> __fish_disable_bracketed_paste 'ff -c examples/6.jsonc'
19	19	-> printf "\e[?2004l"
12	615	> fish_title ff\ -c\ examples/6.jsonc
9	603	-> if not set -q INSIDE_EMACS...
13	13	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
3	571	--> if set -q argv[1]...
4	4	---> set -q argv[1]
102	564	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
11	11	----> string sub -l 20 -- $argv[1]
33	451	----> prompt_pwd -d 1 -D 1
11	11	-----> set -l options h/help d/dir-length= D/full-length-dirs=
28	28	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	334	-----> for path in $argv...
42	55	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
38	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	203	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
6	118	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	95	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
41	55	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	63	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
107	2219206	> ff -c examples/6.jsonc
2219099	2219099	-> fastfetch $argv
43	158	> __fish_enable_bracketed_paste
115	115	-> printf "\e[?2004h"
38	126	> fish_mode_prompt
26	88	-> fish_default_mode_prompt
7	62	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
41	41	---> test "$fish_key_bindings" = fish_vi_key_bindings
14	14	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
58	233113	> fish_prompt
22	22	-> set -l last_status $status
103	147	-> set -l normal (set_color normal)
44	44	--> set_color normal
127	168	-> set -l status_color (set_color brgreen)
41	41	--> set_color brgreen
97	120	-> set -l cwd_color (set_color $fish_color_cwd)
23	23	--> set_color $fish_color_cwd
67	82	-> set -l vcs_color (set_color brpurple)
15	15	--> set_color brpurple
9	9	-> set -l prompt_status ""
6	6	-> set -q fish_prompt_pwd_dir_length
6	6	-> set -lx fish_prompt_pwd_dir_length 0
7	7	-> set -l suffix '❯'
2	132	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
22	119	--> fish_is_root_user
3	73	---> if test "$EUID" = 0 2>/dev/null...
70	70	----> test "$EUID" = 0 2>/dev/null
3	19	---> if contains -- $USER root toor Administrator...
16	16	----> contains -- $USER root toor Administrator
5	5	---> return 1
1	11	-> if test $last_status -ne 0...
10	10	--> test $last_status -ne 0
327	232333	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
34	770	--> prompt_login
3	10	---> if not set -q __fish_machine...
7	7	----> not set -q __fish_machine
2	9	---> if set -q __fish_machine[1]...
7	7	----> set -q __fish_machine[1]
14	14	---> set -l color_host $fish_color_host
1	6	---> if set -q SSH_TTY...
5	5	----> set -q SSH_TTY
527	697	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
17	17	----> set_color $fish_color_user
20	20	----> set_color normal
24	24	----> set_color $color_host
27	87	----> prompt_hostname
60	60	-----> string replace -r -- "\..*" "" $hostname
22	22	----> set_color normal
114	635	--> prompt_pwd
21	21	---> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	---> argparse -n prompt_pwd $options -- $argv
3	9	---> if set -q _flag_help...
6	6	----> set -q _flag_help
5	5	---> set -q argv[1]
8	8	---> set argv $PWD
4	4	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
6	6	---> set -l fulldirs 0
4	4	---> set -ql _flag_D
24	24	---> set -q fish_prompt_pwd_full_dirs
15	15	---> set -l fish_prompt_pwd_full_dirs 1
39	397	---> for path in $argv...
128	144	----> set -l realhome (string escape --style=regex -- ~)
16	16	-----> string escape --style=regex -- ~
136	188	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
52	52	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	26	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
12	12	-----> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-----> echo $tmp
20	230601	--> fish_vcs_prompt
90	230581	---> fish_git_prompt $argv
12	55421	----> if not command -sq git...
55409	55409	-----> not command -sq git
3	30	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
136	58931	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58795	58795	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
57	57339	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	57282	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
22	75	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	42	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
7	57062	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	57051	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	57049	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56961	56961	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
5	5	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	9	----> if not set -q ___fish_git_prompt_init...
8	8	-----> not set -q ___fish_git_prompt_init
14	14	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
52277	58194	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5917	5917	-----> read -lz key value
7	39	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
7	70	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
0	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	44	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
85	97	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
3	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
25	25	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	605	> fish_title
6	595	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
5	574	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	42	---> set -l command (status current-command)
5	5	----> status current-command
2	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
5	5	----> set command
64	511	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
35	440	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	338	-----> for path in $argv...
43	54	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
36	57	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	212	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
4	134	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
38	112	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	74	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	59	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
357	947	> up-or-search
13	102	-> if commandline --search-mode...
89	89	--> commandline --search-mode
5	18	-> if commandline --paging-mode...
13	13	--> commandline --paging-mode
355	416	-> set -l lineno (commandline -L)
61	61	--> commandline -L
27	54	-> switch $lineno...
27	27	--> commandline -f history-search-backward
27	84	> __fish_disable_bracketed_paste 'ff -c examples/*.jsonc'
57	57	-> printf "\e[?2004l"
15	770	> fish_title ff\ -c\ examples/\*.jsonc
9	755	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
3	727	--> if set -q argv[1]...
4	4	---> set -q argv[1]
105	720	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
13	13	----> string sub -l 20 -- $argv[1]
51	602	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
22	475	-----> for path in $argv...
61	73	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
58	96	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
38	38	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	284	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
12	12	-------> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-------> set -l full
7	189	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
69	164	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
51	95	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
44	44	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
44	68	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
24	24	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
10	21	> __fish_enable_bracketed_paste
11	11	-> printf "\e[?2004h"
8	58	> fish_mode_prompt
31	50	-> fish_default_mode_prompt
3	19	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
11	11	---> test "$fish_key_bindings" = fish_vi_key_bindings
5	5	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
27	225509	> fish_prompt
10	10	-> set -l last_status $status
38	76	-> set -l normal (set_color normal)
38	38	--> set_color normal
39	47	-> set -l status_color (set_color brgreen)
8	8	--> set_color brgreen
34	43	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	39	-> set -l vcs_color (set_color brpurple)
6	6	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	125	-> if functions -q fish_is_root_user...
47	47	--> functions -q fish_is_root_user
12	76	--> fish_is_root_user
2	35	---> if test "$EUID" = 0 2>/dev/null...
33	33	----> test "$EUID" = 0 2>/dev/null
1	26	---> if contains -- $USER root toor Administrator...
25	25	----> contains -- $USER root toor Administrator
3	3	---> return 1
4	75	-> if test $last_status -ne 0...
6	6	--> test $last_status -ne 0
43	52	--> set status_color (set_color $fish_color_error)
9	9	---> set_color $fish_color_error
13	13	--> set prompt_status $status_color "[" $last_status "]" $normal
122	225034	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
41	311	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
0	4	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
2	5	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
160	246	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
38	54	----> prompt_hostname
16	16	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
19	214	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
13	13	---> argparse -n prompt_pwd $options -- $argv
2	5	---> if set -q _flag_help...
3	3	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
13	140	---> for path in $argv...
39	49	----> set -l realhome (string escape --style=regex -- ~)
10	10	-----> string escape --style=regex -- ~
43	61	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
18	18	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
31	224387	--> fish_vcs_prompt
104	224356	---> fish_git_prompt $argv
12	52938	----> if not command -sq git...
52926	52926	-----> not command -sq git
1	73	----> if functions -q __fish_git_prompt_ready...
72	72	-----> functions -q __fish_git_prompt_ready
129	56784	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56655	56655	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
11	11	----> set -l git_dir $repo_info[1]
8	8	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
62	56889	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	56827	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	82	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
9	47	-------> if test -d $git_dir/rebase-apply...
9	9	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	56596	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56584	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
84	56582	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56498	56498	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
7	7	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
2	5	----> if not set -q ___fish_git_prompt_init...
3	3	-----> not set -q ___fish_git_prompt_init
13	13	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
3	3	----> set -l untracked
51124	57001	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5877	5877	-----> read -lz key value
7	39	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
7	18	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
10	74	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
5	45	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	12	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
2	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
1	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
67	79	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
1	20	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
19	19	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
9	565	> fish_title
6	556	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
6	535	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	43	---> set -l command (status current-command)
5	5	----> status current-command
2	13	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
64	470	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
6	6	----> string sub -l 20 -- $command
25	400	----> prompt_pwd -d 1 -D 1
9	9	-----> set -l options h/help d/dir-length= D/full-length-dirs=
25	25	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
2	2	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	301	-----> for path in $argv...
37	47	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
37	59	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	183	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	106	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	84	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
35	48	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
39	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
125	766	> up-or-search
19	65	-> if commandline --search-mode...
46	46	--> commandline --search-mode
8	26	-> if commandline --paging-mode...
18	18	--> commandline --paging-mode
447	486	-> set -l lineno (commandline -L)
39	39	--> commandline -L
34	64	-> switch $lineno...
30	30	--> commandline -f history-search-backward
30	60	> __fish_disable_bracketed_paste ff\ -c\ \'examples/\*.jsonc\'
30	30	-> printf "\e[?2004l"
18	656	> fish_title ff\ -c\ \'examples/\*.jsonc\'
9	638	-> if not set -q INSIDE_EMACS...
10	10	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
4	609	--> if set -q argv[1]...
4	4	---> set -q argv[1]
112	601	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
12	12	----> string sub -l 20 -- $argv[1]
32	477	----> prompt_pwd -d 1 -D 1
13	13	-----> set -l options h/help d/dir-length= D/full-length-dirs=
26	26	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
8	8	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
9	9	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	356	-----> for path in $argv...
46	58	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
42	67	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	217	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	118	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
38	95	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	57	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
53	73	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
85	68630	> ff -c 'examples/*.jsonc'
68545	68545	-> fastfetch $argv
23	54	> __fish_enable_bracketed_paste
31	31	-> printf "\e[?2004h"
10	54	> fish_mode_prompt
10	44	-> fish_default_mode_prompt
6	34	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
22	22	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
27	222332	> fish_prompt
13	13	-> set -l last_status $status
42	54	-> set -l normal (set_color normal)
12	12	--> set_color normal
37	46	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
35	44	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
32	39	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	78	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
12	66	--> fish_is_root_user
2	39	---> if test "$EUID" = 0 2>/dev/null...
37	37	----> test "$EUID" = 0 2>/dev/null
1	11	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
6	78	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
44	53	--> set status_color (set_color $fish_color_error)
9	9	---> set_color $fish_color_error
12	12	--> set prompt_status $status_color "[" $last_status "]" $normal
130	221920	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
19	266	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
153	224	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
11	41	----> prompt_hostname
30	30	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
21	310	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
23	229	---> for path in $argv...
67	78	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
71	105	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
34	34	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	23	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-----> echo $tmp
15	221214	--> fish_vcs_prompt
105	221199	---> fish_git_prompt $argv
11	50713	----> if not command -sq git...
50702	50702	-----> not command -sq git
3	39	----> if functions -q __fish_git_prompt_ready...
36	36	-----> functions -q __fish_git_prompt_ready
135	56152	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56017	56017	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
61	56888	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
36	56827	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
25	77	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
4	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
13	56607	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
6	56590	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
95	56584	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56489	56489	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
12	12	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
5	5	------> echo $bare
9	9	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
5	5	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
3	8	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50752	56689	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5937	5937	-----> read -lz key value
6	40	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
5	17	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	75	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	47	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
5	12	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
5	5	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
2	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
20	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
75	89	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
5	37	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
32	32	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	38	----> if test -n "$b"...
8	8	-----> test -n "$b"
9	9	-----> set b "$branch_color$b$branch_done"
3	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
8	8	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
6	6	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
10	623	> fish_title
7	613	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
6	592	--> if set -q argv[1]...
3	3	---> set -q argv[1]
49	58	---> set -l command (status current-command)
9	9	----> status current-command
2	13	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
68	512	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
27	436	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	339	-----> for path in $argv...
42	53	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
44	66	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	206	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	125	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	101	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
22	22	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	62	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
277	716	> up-or-search
13	54	-> if commandline --search-mode...
41	41	--> commandline --search-mode
5	17	-> if commandline --paging-mode...
12	12	--> commandline --paging-mode
278	306	-> set -l lineno (commandline -L)
28	28	--> commandline -L
26	62	-> switch $lineno...
36	36	--> commandline -f history-search-backward
66	110	> __fish_disable_bracketed_paste 'ff -c "examples/*.jsonc"'
44	44	-> printf "\e[?2004l"
41	1989	> fish_title ff\ -c\ \"examples/\*.jsonc\"
23	1948	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
11	11	--> set -q SSH_TTY
21	1875	--> if set -q argv[1]...
10	10	---> set -q argv[1]
379	1844	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
32	32	----> string sub -l 20 -- $argv[1]
98	1433	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
68	68	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
20	20	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
42	1105	-----> for path in $argv...
161	194	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
155	233	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
78	78	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
32	636	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
18	339	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
116	271	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
119	155	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
14	14	--------> set full $all[2..]
169	224	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
55	55	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
113	82640	> ff -c "examples/*.jsonc"
82527	82527	-> fastfetch $argv
24	56	> __fish_enable_bracketed_paste
32	32	-> printf "\e[?2004h"
11	53	> fish_mode_prompt
13	42	-> fish_default_mode_prompt
4	29	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
26	228876	> fish_prompt
13	13	-> set -l last_status $status
40	52	-> set -l normal (set_color normal)
12	12	--> set_color normal
40	49	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
41	51	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
35	41	-> set -l vcs_color (set_color brpurple)
6	6	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	78	-> if functions -q fish_is_root_user...
9	9	--> functions -q fish_is_root_user
13	66	--> fish_is_root_user
1	36	---> if test "$EUID" = 0 2>/dev/null...
35	35	----> test "$EUID" = 0 2>/dev/null
3	13	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
7	97	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
53	62	--> set status_color (set_color $fish_color_error)
9	9	---> set_color $fish_color_error
21	21	--> set prompt_status $status_color "[" $last_status "]" $normal
145	228437	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
20	334	--> prompt_login
2	15	---> if not set -q __fish_machine...
13	13	----> not set -q __fish_machine
1	6	---> if set -q __fish_machine[1]...
5	5	----> set -q __fish_machine[1]
10	10	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
201	278	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
13	13	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
10	42	----> prompt_hostname
32	32	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
24	224	--> prompt_pwd
11	11	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
15	141	---> for path in $argv...
38	49	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
38	59	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
11	227734	--> fish_vcs_prompt
94	227723	---> fish_git_prompt $argv
11	53035	----> if not command -sq git...
53024	53024	-----> not command -sq git
3	34	----> if functions -q __fish_git_prompt_ready...
31	31	-----> functions -q __fish_git_prompt_ready
191	59125	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58934	58934	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
11	11	----> set -l git_dir $repo_info[1]
8	8	----> set -l inside_gitdir $repo_info[2]
8	8	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
8	8	----> set -l sha $repo_info[5]
70	58053	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
55	57983	-----> __fish_git_prompt_operation_branch_bare $repo_info
14	14	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
28	81	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
6	41	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
12	57736	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	57720	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
138	57717	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57579	57579	---------> command git symbolic-ref HEAD 2>/dev/null
1	20	------> if test true = $inside_gitdir...
19	19	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
5	5	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
11	11	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50735	56789	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6054	6054	-----> read -lz key value
6	40	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
16	16	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
6	6	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
8	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
0	6	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	47	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
65	81	----> set b (string replace refs/heads/ '' -- $b)
16	16	-----> string replace refs/heads/ '' -- $b
1	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
26	26	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	573	> fish_title
7	563	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
5	542	--> if set -q argv[1]...
3	3	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
65	480	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
22	408	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	316	-----> for path in $argv...
38	49	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
38	59	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	195	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	115	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	93	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	57	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
18	18	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	61	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
34	65751	> __fastfetch_complete_config
249	65711	-> for line in (fastfetch --list-presets autocompletion)...
65120	65120	--> fastfetch --list-presets autocompletion
59	59	--> echo -e "$line\tPreset"
9	9	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	-> echo -e "none\tDisable loading config file"
25	62978	> __fastfetch_complete_config
218	62947	-> for line in (fastfetch --list-presets autocompletion)...
62426	62426	--> fastfetch --list-presets autocompletion
24	24	--> echo -e "$line\tPreset"
7	7	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
6	6	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
5	5	--> echo -e "$line\tPreset"
4	4	--> echo -e "$line\tPreset"
6	6	-> echo -e "none\tDisable loading config file"
289	452	> __fish_disable_bracketed_paste 'ff -c examples/7.jsonc '
163	163	-> printf "\e[?2004l"
43	2459	> fish_title ff\ -c\ examples/7.jsonc\ 
25	2416	-> if not set -q INSIDE_EMACS...
24	24	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
19	2339	--> if set -q argv[1]...
11	11	---> set -q argv[1]
356	2309	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
33	33	----> string sub -l 20 -- $argv[1]
176	1920	----> prompt_pwd -d 1 -D 1
35	35	-----> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
10	10	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
45	1512	-----> for path in $argv...
115	147	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
176	240	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
64	64	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
29	1080	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
35	35	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
23	632	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
209	546	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
228	337	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
109	109	----------> math $fish_prompt_pwd_full_dirs - 1
29	29	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
301	369	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
68	68	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
117	530067	> ff -c examples/7.jsonc
529950	529950	-> fastfetch $argv
48	86	> __fish_enable_bracketed_paste
38	38	-> printf "\e[?2004h"
43	192	> fish_mode_prompt
58	149	-> fish_default_mode_prompt
7	91	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
71	71	---> test "$fish_key_bindings" = fish_vi_key_bindings
13	13	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
40	232650	> fish_prompt
14	14	-> set -l last_status $status
72	114	-> set -l normal (set_color normal)
42	42	--> set_color normal
86	103	-> set -l status_color (set_color brgreen)
17	17	--> set_color brgreen
72	89	-> set -l cwd_color (set_color $fish_color_cwd)
17	17	--> set_color $fish_color_cwd
65	79	-> set -l vcs_color (set_color brpurple)
14	14	--> set_color brpurple
11	11	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
3	193	-> if functions -q fish_is_root_user...
63	63	--> functions -q fish_is_root_user
21	127	--> fish_is_root_user
3	46	---> if test "$EUID" = 0 2>/dev/null...
43	43	----> test "$EUID" = 0 2>/dev/null
8	54	---> if contains -- $USER root toor Administrator...
46	46	----> contains -- $USER root toor Administrator
6	6	---> return 1
3	14	-> if test $last_status -ne 0...
11	11	--> test $last_status -ne 0
251	231963	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
67	616	--> prompt_login
2	9	---> if not set -q __fish_machine...
7	7	----> not set -q __fish_machine
2	13	---> if set -q __fish_machine[1]...
11	11	----> set -q __fish_machine[1]
10	10	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
331	513	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
16	16	----> set_color $fish_color_user
26	26	----> set_color normal
21	21	----> set_color $color_host
65	106	----> prompt_hostname
41	41	-----> string replace -r -- "\..*" "" $hostname
13	13	----> set_color normal
36	451	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	---> argparse -n prompt_pwd $options -- $argv
2	7	---> if set -q _flag_help...
5	5	----> set -q _flag_help
5	5	---> set -q argv[1]
54	54	---> set argv $PWD
6	6	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
23	288	---> for path in $argv...
66	79	----> set -l realhome (string escape --style=regex -- ~)
13	13	-----> string escape --style=regex -- ~
81	156	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
75	75	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	30	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
15	15	-----> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-----> echo $tmp
51	230645	--> fish_vcs_prompt
122	230594	---> fish_git_prompt $argv
10	55102	----> if not command -sq git...
55092	55092	-----> not command -sq git
4	70	----> if functions -q __fish_git_prompt_ready...
66	66	-----> functions -q __fish_git_prompt_ready
134	59416	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
59282	59282	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
61	57795	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
44	57734	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
26	79	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
4	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
9	57505	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
6	57492	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
114	57486	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57372	57372	---------> command git symbolic-ref HEAD 2>/dev/null
3	18	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
12	12	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
51478	57521	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6043	6043	-----> read -lz key value
8	45	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
18	18	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	71	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
8	8	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	50	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
53	66	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
21	21	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
8	8	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
0	4	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
8	8	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
30	30	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
14	14	-> echo -n -s $status_color $suffix ' ' $normal
11	647	> fish_title
8	636	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
7	614	--> if set -q argv[1]...
4	4	---> set -q argv[1]
39	45	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
67	545	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
29	471	----> prompt_pwd -d 1 -D 1
11	11	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
7	7	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	363	-----> for path in $argv...
40	51	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
40	62	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	237	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	140	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
46	113	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
53	67	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
53	76	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
23	23	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
297	992	> up-or-search
12	147	-> if commandline --search-mode...
135	135	--> commandline --search-mode
5	23	-> if commandline --paging-mode...
18	18	--> commandline --paging-mode
423	453	-> set -l lineno (commandline -L)
30	30	--> commandline -L
31	72	-> switch $lineno...
41	41	--> commandline -f history-search-backward
58	100	> __fish_disable_bracketed_paste 'ff -c examples/8.jsonc'
42	42	-> printf "\e[?2004l"
91	2463	> fish_title ff\ -c\ examples/8.jsonc
36	2372	-> if not set -q INSIDE_EMACS...
40	40	--> not set -q INSIDE_EMACS
28	28	--> set -l ssh
17	17	--> set -q SSH_TTY
19	2251	--> if set -q argv[1]...
57	57	---> set -q argv[1]
350	2175	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
35	35	----> string sub -l 20 -- $argv[1]
102	1790	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
69	69	-----> argparse -n prompt_pwd $options -- $argv
4	18	-----> if set -q _flag_help...
14	14	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
8	8	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
48	1460	-----> for path in $argv...
180	212	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
248	334	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
86	86	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
39	866	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
43	43	-------> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-------> set -l full
23	500	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
208	416	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
170	208	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
38	38	----------> math $fish_prompt_pwd_full_dirs - 1
27	27	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
197	268	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
71	71	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
93	203879	> ff -c examples/8.jsonc
203786	203786	-> fastfetch $argv
28	58	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
12	63	> fish_mode_prompt
13	51	-> fish_default_mode_prompt
6	38	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
24	24	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
29	223397	> fish_prompt
14	14	-> set -l last_status $status
65	77	-> set -l normal (set_color normal)
12	12	--> set_color normal
66	81	-> set -l status_color (set_color brgreen)
15	15	--> set_color brgreen
40	51	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
36	43	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
3	102	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
13	88	--> fish_is_root_user
3	60	---> if test "$EUID" = 0 2>/dev/null...
57	57	----> test "$EUID" = 0 2>/dev/null
3	11	---> if contains -- $USER root toor Administrator...
8	8	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
118	222957	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	271	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
10	10	---> set -l color_host $fish_color_host
2	5	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
157	231	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
11	42	----> prompt_hostname
31	31	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
25	224	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
13	13	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
15	144	---> for path in $argv...
42	53	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
35	58	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
12	222344	--> fish_vcs_prompt
84	222332	---> fish_git_prompt $argv
10	51485	----> if not command -sq git...
51475	51475	-----> not command -sq git
3	27	----> if functions -q __fish_git_prompt_ready...
24	24	-----> functions -q __fish_git_prompt_ready
131	56052	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
55921	55921	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
11	11	----> set -l git_dir $repo_info[1]
8	8	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
64	57229	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
45	57165	-----> __fish_git_prompt_operation_branch_bare $repo_info
12	12	------> set -l git_dir $argv[1]
7	7	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
5	5	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	77	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
6	42	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
0	9	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
11	56931	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
4	56915	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
107	56911	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56804	56804	---------> command git symbolic-ref HEAD 2>/dev/null
1	19	------> if test true = $inside_gitdir...
18	18	-------> test true = $inside_gitdir
12	12	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
5	5	----> set -l stagedstate
6	6	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
6	6	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
3	7	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50981	56867	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5886	5886	-----> read -lz key value
9	43	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	75	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
8	47	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
4	12	------> begin...
8	8	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
1	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
2	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
60	75	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
3	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
10	579	> fish_title
7	569	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
7	549	--> if set -q argv[1]...
3	3	---> set -q argv[1]
41	46	---> set -l command (status current-command)
5	5	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
64	481	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
22	410	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	316	-----> for path in $argv...
40	50	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
38	60	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	194	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	116	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	94	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	54	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
40	59	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
193	619	> up-or-search
13	58	-> if commandline --search-mode...
45	45	--> commandline --search-mode
7	21	-> if commandline --paging-mode...
14	14	--> commandline --paging-mode
264	293	-> set -l lineno (commandline -L)
29	29	--> commandline -L
26	54	-> switch $lineno...
28	28	--> commandline -f history-search-backward
88	277	> __fish_disable_bracketed_paste 'ff -c examples/9.jsonc'
189	189	-> printf "\e[?2004l"
69	2831	> fish_title ff\ -c\ examples/9.jsonc
35	2762	-> if not set -q INSIDE_EMACS...
37	37	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
17	17	--> set -q SSH_TTY
13	2648	--> if set -q argv[1]...
16	16	---> set -q argv[1]
556	2619	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
51	51	----> string sub -l 20 -- $argv[1]
197	2012	----> prompt_pwd -d 1 -D 1
36	36	-----> set -l options h/help d/dir-length= D/full-length-dirs=
71	71	-----> argparse -n prompt_pwd $options -- $argv
4	18	-----> if set -q _flag_help...
14	14	------> set -q _flag_help
11	11	-----> set -q argv[1]
19	19	-----> set argv $PWD
10	10	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
46	1576	-----> for path in $argv...
132	164	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
176	241	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
65	65	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
63	1125	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
36	36	-------> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-------> set -l full
23	542	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
205	456	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
146	251	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
105	105	----------> math $fish_prompt_pwd_full_dirs - 1
29	29	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
370	468	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
98	98	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
106	84369	> ff -c examples/9.jsonc
84263	84263	-> fastfetch $argv
28	60	> __fish_enable_bracketed_paste
32	32	-> printf "\e[?2004h"
13	78	> fish_mode_prompt
36	65	-> fish_default_mode_prompt
4	29	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
22	225297	> fish_prompt
15	15	-> set -l last_status $status
42	72	-> set -l normal (set_color normal)
30	30	--> set_color normal
38	48	-> set -l status_color (set_color brgreen)
10	10	--> set_color brgreen
35	45	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
33	40	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
6	6	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
3	146	-> if functions -q fish_is_root_user...
56	56	--> functions -q fish_is_root_user
17	87	--> fish_is_root_user
2	38	---> if test "$EUID" = 0 2>/dev/null...
36	36	----> test "$EUID" = 0 2>/dev/null
2	29	---> if contains -- $USER root toor Administrator...
27	27	----> contains -- $USER root toor Administrator
3	3	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
121	224865	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
43	335	--> prompt_login
1	9	---> if not set -q __fish_machine...
8	8	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
163	266	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
38	69	----> prompt_hostname
31	31	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
21	227	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
13	147	---> for path in $argv...
46	57	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
38	59	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
39	224182	--> fish_vcs_prompt
113	224143	---> fish_git_prompt $argv
12	52274	----> if not command -sq git...
52262	52262	-----> not command -sq git
2	80	----> if functions -q __fish_git_prompt_ready...
78	78	-----> functions -q __fish_git_prompt_ready
141	57304	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57163	57163	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
9	9	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
59	56957	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
54	56898	-----> __fish_git_prompt_operation_branch_bare $repo_info
13	13	------> set -l git_dir $argv[1]
7	7	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
23	80	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
7	45	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
8	8	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	56655	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56643	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
86	56641	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56555	56555	---------> command git symbolic-ref HEAD 2>/dev/null
2	17	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
51011	56852	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5841	5841	-----> read -lz key value
6	38	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	13	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
6	6	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
10	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	46	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
66	77	----> set b (string replace refs/heads/ '' -- $b)
11	11	-----> string replace refs/heads/ '' -- $b
1	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	30	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
30	30	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
9	578	> fish_title
7	569	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	548	--> if set -q argv[1]...
3	3	---> set -q argv[1]
36	42	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
64	485	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
24	414	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	321	-----> for path in $argv...
37	48	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
37	58	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	203	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
5	124	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	101	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
41	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
19	19	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
40	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
192	625	> up-or-search
12	91	-> if commandline --search-mode...
79	79	--> commandline --search-mode
6	19	-> if commandline --paging-mode...
13	13	--> commandline --paging-mode
243	270	-> set -l lineno (commandline -L)
27	27	--> commandline -L
27	53	-> switch $lineno...
26	26	--> commandline -f history-search-backward
29	46	> __fish_disable_bracketed_paste 'ff -c examples/10.jsonc'
17	17	-> printf "\e[?2004l"
16	617	> fish_title ff\ -c\ examples/10.jsonc
8	601	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
9	9	--> set -l ssh
4	4	--> set -q SSH_TTY
4	571	--> if set -q argv[1]...
4	4	---> set -q argv[1]
91	563	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
14	14	----> string sub -l 20 -- $argv[1]
29	458	----> prompt_pwd -d 1 -D 1
9	9	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
18	353	-----> for path in $argv...
44	56	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
41	67	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	212	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
9	127	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	101	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
45	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	63	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
84	524581	> ff -c examples/10.jsonc
524497	524497	-> fastfetch $argv
37	105	> __fish_enable_bracketed_paste
68	68	-> printf "\e[?2004h"
36	141	> fish_mode_prompt
20	105	-> fish_default_mode_prompt
7	85	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
63	63	---> test "$fish_key_bindings" = fish_vi_key_bindings
15	15	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
51	234140	> fish_prompt
33	33	-> set -l last_status $status
111	132	-> set -l normal (set_color normal)
21	21	--> set_color normal
107	146	-> set -l status_color (set_color brgreen)
39	39	--> set_color brgreen
111	136	-> set -l cwd_color (set_color $fish_color_cwd)
25	25	--> set_color $fish_color_cwd
84	104	-> set -l vcs_color (set_color brpurple)
20	20	--> set_color brpurple
9	9	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
3	112	-> if functions -q fish_is_root_user...
12	12	--> functions -q fish_is_root_user
17	97	--> fish_is_root_user
2	62	---> if test "$EUID" = 0 2>/dev/null...
60	60	----> test "$EUID" = 0 2>/dev/null
2	14	---> if contains -- $USER root toor Administrator...
12	12	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
269	233380	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
24	621	--> prompt_login
4	21	---> if not set -q __fish_machine...
17	17	----> not set -q __fish_machine
5	30	---> if set -q __fish_machine[1]...
25	25	----> set -q __fish_machine[1]
16	16	---> set -l color_host $fish_color_host
2	9	---> if set -q SSH_TTY...
7	7	----> set -q SSH_TTY
349	521	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
38	38	----> set_color $fish_color_user
18	18	----> set_color normal
17	17	----> set_color $color_host
32	84	----> prompt_hostname
52	52	-----> string replace -r -- "\..*" "" $hostname
15	15	----> set_color normal
64	430	--> prompt_pwd
15	15	---> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	---> argparse -n prompt_pwd $options -- $argv
2	8	---> if set -q _flag_help...
6	6	----> set -q _flag_help
5	5	---> set -q argv[1]
10	10	---> set argv $PWD
5	5	---> set -ql _flag_d
6	6	---> set -q fish_prompt_pwd_dir_length
7	7	---> set -l fulldirs 0
5	5	---> set -ql _flag_D
5	5	---> set -q fish_prompt_pwd_full_dirs
7	7	---> set -l fish_prompt_pwd_full_dirs 1
31	270	---> for path in $argv...
78	95	----> set -l realhome (string escape --style=regex -- ~)
17	17	-----> string escape --style=regex -- ~
83	115	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
32	32	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	29	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
14	14	-----> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-----> echo $tmp
21	232060	--> fish_vcs_prompt
103	232039	---> fish_git_prompt $argv
13	55319	----> if not command -sq git...
55306	55306	-----> not command -sq git
2	28	----> if functions -q __fish_git_prompt_ready...
26	26	-----> functions -q __fish_git_prompt_ready
135	58967	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58832	58832	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
62	59380	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	59318	-----> __fish_git_prompt_operation_branch_bare $repo_info
11	11	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
5	5	------> set -l branch
5	5	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	77	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	42	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
0	9	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	59096	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	59084	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
94	59081	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58987	58987	---------> command git symbolic-ref HEAD 2>/dev/null
3	16	------> if test true = $inside_gitdir...
13	13	-------> test true = $inside_gitdir
10	10	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
5	5	----> set -l dirty
5	5	----> set -l untracked
51753	57650	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5897	5897	-----> read -lz key value
7	42	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
19	19	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	73	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
7	45	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
4	4	----> set -l f ""
17	50	----> for i in $__fish_git_prompt_status_order...
2	8	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
2	9	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
70	84	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
3	27	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	31	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
9	584	> fish_title
7	575	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
7	554	--> if set -q argv[1]...
3	3	---> set -q argv[1]
36	43	---> set -l command (status current-command)
7	7	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
64	489	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
27	418	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	324	-----> for path in $argv...
36	47	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
39	63	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	202	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	120	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	96	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	55	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	61	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
92	424	> __fish_enable_bracketed_paste
332	332	-> printf "\e[?2004h"
141	529	> fish_mode_prompt
277	388	-> fish_default_mode_prompt
19	111	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
65	65	---> test "$fish_key_bindings" = fish_vi_key_bindings
27	27	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
77	241454	> fish_prompt
39	39	-> set -l last_status $status
133	247	-> set -l normal (set_color normal)
114	114	--> set_color normal
162	188	-> set -l status_color (set_color brgreen)
26	26	--> set_color brgreen
217	264	-> set -l cwd_color (set_color $fish_color_cwd)
47	47	--> set_color $fish_color_cwd
170	197	-> set -l vcs_color (set_color brpurple)
27	27	--> set_color brpurple
24	24	-> set -l prompt_status ""
13	13	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
15	15	-> set -l suffix '❯'
8	451	-> if functions -q fish_is_root_user...
156	156	--> functions -q fish_is_root_user
36	287	--> fish_is_root_user
45	161	---> if test "$EUID" = 0 2>/dev/null...
116	116	----> test "$EUID" = 0 2>/dev/null
3	79	---> if contains -- $USER root toor Administrator...
76	76	----> contains -- $USER root toor Administrator
11	11	---> return 1
2	22	-> if test $last_status -ne 0...
20	20	--> test $last_status -ne 0
364	239892	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
103	1656	--> prompt_login
4	19	---> if not set -q __fish_machine...
15	15	----> not set -q __fish_machine
4	14	---> if set -q __fish_machine[1]...
10	10	----> set -q __fish_machine[1]
23	23	---> set -l color_host $fish_color_host
3	13	---> if set -q SSH_TTY...
10	10	----> set -q SSH_TTY
947	1484	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
47	47	----> set_color $fish_color_user
24	24	----> set_color normal
158	158	----> set_color $color_host
166	277	----> prompt_hostname
111	111	-----> string replace -r -- "\..*" "" $hostname
31	31	----> set_color normal
148	833	--> prompt_pwd
28	28	---> set -l options h/help d/dir-length= D/full-length-dirs=
40	40	---> argparse -n prompt_pwd $options -- $argv
5	16	---> if set -q _flag_help...
11	11	----> set -q _flag_help
11	11	---> set -q argv[1]
26	26	---> set argv $PWD
9	9	---> set -ql _flag_d
10	10	---> set -q fish_prompt_pwd_dir_length
14	14	---> set -l fulldirs 0
8	8	---> set -ql _flag_D
10	10	---> set -q fish_prompt_pwd_full_dirs
13	13	---> set -l fish_prompt_pwd_full_dirs 1
55	500	---> for path in $argv...
132	162	----> set -l realhome (string escape --style=regex -- ~)
30	30	-----> string escape --style=regex -- ~
155	211	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
56	56	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
15	72	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
33	33	-----> test "$fish_prompt_pwd_dir_length" -eq 0
24	24	-----> echo $tmp
104	237039	--> fish_vcs_prompt
165	236935	---> fish_git_prompt $argv
12	65581	----> if not command -sq git...
65569	65569	-----> not command -sq git
2	74	----> if functions -q __fish_git_prompt_ready...
72	72	-----> functions -q __fish_git_prompt_ready
133	56651	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56518	56518	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
59	57220	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
36	57161	-----> __fish_git_prompt_operation_branch_bare $repo_info
7	7	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
5	5	------> set -l operation
5	5	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
5	5	------> set -l total
23	79	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
6	43	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
2	11	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
9	56942	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56929	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
87	56927	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56840	56840	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
2	6	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50778	56692	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5914	5914	-----> read -lz key value
6	38	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
3	3	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
60	72	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	30	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
1	12	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
5	5	-----> test -z "$format"
4	4	-----> set format " (%s)"
25	25	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
9	594	> fish_title
6	585	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
7	565	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	43	---> set -l command (status current-command)
6	6	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
65	500	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
11	11	----> string sub -l 20 -- $command
25	424	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
11	332	-----> for path in $argv...
40	53	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
38	59	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	209	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	131	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	108	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	71	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
31	31	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	59	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
51	109	> __fish_disable_bracketed_paste ff
58	58	-> printf "\e[?2004l"
33	1854	> fish_title ff
27	1821	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
10	10	--> set -q SSH_TTY
11	1745	--> if set -q argv[1]...
11	11	---> set -q argv[1]
309	1723	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
30	30	----> string sub -l 20 -- $argv[1]
92	1384	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
90	90	-----> argparse -n prompt_pwd $options -- $argv
9	23	-----> if set -q _flag_help...
14	14	------> set -q _flag_help
13	13	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
39	1030	-----> for path in $argv...
133	167	------> set -l realhome (string escape --style=regex -- ~)
34	34	-------> string escape --style=regex -- ~
134	200	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
66	66	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
22	624	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
12	12	-------> set -l full
19	364	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
125	291	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
129	166	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
37	37	----------> math $fish_prompt_pwd_full_dirs - 1
23	23	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
141	198	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
57	57	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
80	81905	> ff
81825	81825	-> fastfetch $argv
28	57	> __fish_enable_bracketed_paste
29	29	-> printf "\e[?2004h"
12	56	> fish_mode_prompt
15	44	-> fish_default_mode_prompt
3	29	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
31	223827	> fish_prompt
14	14	-> set -l last_status $status
62	74	-> set -l normal (set_color normal)
12	12	--> set_color normal
72	89	-> set -l status_color (set_color brgreen)
17	17	--> set_color brgreen
42	55	-> set -l cwd_color (set_color $fish_color_cwd)
13	13	--> set_color $fish_color_cwd
37	44	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
7	7	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	88	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
14	75	--> fish_is_root_user
2	45	---> if test "$EUID" = 0 2>/dev/null...
43	43	----> test "$EUID" = 0 2>/dev/null
3	12	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
8	75	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
40	49	--> set status_color (set_color $fish_color_error)
9	9	---> set_color $fish_color_error
11	11	--> set prompt_status $status_color "[" $last_status "]" $normal
124	223324	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
13	301	--> prompt_login
1	9	---> if not set -q __fish_machine...
8	8	----> not set -q __fish_machine
2	6	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
188	261	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
13	13	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
12	40	----> prompt_hostname
28	28	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
25	223	--> prompt_pwd
9	9	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
15	141	---> for path in $argv...
38	50	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
37	58	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
11	222676	--> fish_vcs_prompt
99	222665	---> fish_git_prompt $argv
12	51506	----> if not command -sq git...
51494	51494	-----> not command -sq git
2	37	----> if functions -q __fish_git_prompt_ready...
35	35	-----> functions -q __fish_git_prompt_ready
164	56335	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56171	56171	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
24	24	----> test -n "$repo_info"
12	12	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
8	8	----> set -l sha $repo_info[5]
64	56879	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
51	56815	-----> __fish_git_prompt_operation_branch_bare $repo_info
11	11	------> set -l git_dir $argv[1]
9	9	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
8	8	------> set -l sha $argv[5]
5	5	------> set -l branch
6	6	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
6	6	------> set -l total
23	84	------> if test -d $git_dir/rebase-merge...
14	14	-------> test -d $git_dir/rebase-merge
6	47	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
8	56561	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
6	56548	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
92	56542	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56450	56450	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
5	5	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
7	7	----> set -l untracked
50972	57219	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6247	6247	-----> read -lz key value
9	42	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
2	14	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	75	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
9	47	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	17	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
5	5	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
66	78	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
31	31	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
10	623	> fish_title
7	613	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
7	593	--> if set -q argv[1]...
3	3	---> set -q argv[1]
36	42	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
65	528	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
25	456	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
18	362	-----> for path in $argv...
49	62	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
52	78	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	204	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	121	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	97	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	57	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	61	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
79	301	> __fish_disable_bracketed_paste ff
222	222	-> printf "\e[?2004l"
77	2545	> fish_title ff
28	2468	-> if not set -q INSIDE_EMACS...
32	32	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
11	11	--> set -q SSH_TTY
22	2381	--> if set -q argv[1]...
11	11	---> set -q argv[1]
453	2348	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
178	1864	----> prompt_pwd -d 1 -D 1
26	26	-----> set -l options h/help d/dir-length= D/full-length-dirs=
62	62	-----> argparse -n prompt_pwd $options -- $argv
4	16	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
46	1470	-----> for path in $argv...
135	167	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
173	245	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
72	72	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
32	1012	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
36	36	-------> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-------> set -l full
22	635	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
215	545	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
204	330	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
126	126	----------> math $fish_prompt_pwd_full_dirs - 1
27	27	--------> set tmp $all[1]
23	23	--------> set full $all[2..]
226	293	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
67	67	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
127	2124693	> ff
2124566	2124566	-> fastfetch $argv
64	170	> __fish_enable_bracketed_paste
106	106	-> printf "\e[?2004h"
55	203	> fish_mode_prompt
86	148	-> fish_default_mode_prompt
7	62	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
43	43	---> test "$fish_key_bindings" = fish_vi_key_bindings
12	12	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
45	231589	> fish_prompt
27	27	-> set -l last_status $status
85	153	-> set -l normal (set_color normal)
68	68	--> set_color normal
80	98	-> set -l status_color (set_color brgreen)
18	18	--> set_color brgreen
91	110	-> set -l cwd_color (set_color $fish_color_cwd)
19	19	--> set_color $fish_color_cwd
102	116	-> set -l vcs_color (set_color brpurple)
14	14	--> set_color brpurple
11	11	-> set -l prompt_status ""
8	8	-> set -q fish_prompt_pwd_dir_length
10	10	-> set -lx fish_prompt_pwd_dir_length 0
10	10	-> set -l suffix '❯'
7	311	-> if functions -q fish_is_root_user...
101	101	--> functions -q fish_is_root_user
28	203	--> fish_is_root_user
7	102	---> if test "$EUID" = 0 2>/dev/null...
95	95	----> test "$EUID" = 0 2>/dev/null
5	66	---> if contains -- $USER root toor Administrator...
61	61	----> contains -- $USER root toor Administrator
7	7	---> return 1
3	17	-> if test $last_status -ne 0...
14	14	--> test $last_status -ne 0
442	230662	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
81	673	--> prompt_login
4	15	---> if not set -q __fish_machine...
11	11	----> not set -q __fish_machine
4	13	---> if set -q __fish_machine[1]...
9	9	----> set -q __fish_machine[1]
17	17	---> set -l color_host $fish_color_host
2	9	---> if set -q SSH_TTY...
7	7	----> set -q SSH_TTY
334	538	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
27	27	----> set_color $fish_color_user
14	14	----> set_color normal
16	16	----> set_color $color_host
71	130	----> prompt_hostname
59	59	-----> string replace -r -- "\..*" "" $hostname
17	17	----> set_color normal
67	592	--> prompt_pwd
38	38	---> set -l options h/help d/dir-length= D/full-length-dirs=
35	35	---> argparse -n prompt_pwd $options -- $argv
3	12	---> if set -q _flag_help...
9	9	----> set -q _flag_help
8	8	---> set -q argv[1]
17	17	---> set argv $PWD
7	7	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
9	9	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
8	8	---> set -q fish_prompt_pwd_full_dirs
9	9	---> set -l fish_prompt_pwd_full_dirs 1
32	368	---> for path in $argv...
99	129	----> set -l realhome (string escape --style=regex -- ~)
30	30	-----> string escape --style=regex -- ~
88	159	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
71	71	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	48	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
22	22	-----> test "$fish_prompt_pwd_dir_length" -eq 0
17	17	-----> echo $tmp
133	228955	--> fish_vcs_prompt
167	228822	---> fish_git_prompt $argv
10	58341	----> if not command -sq git...
58331	58331	-----> not command -sq git
2	62	----> if functions -q __fish_git_prompt_ready...
60	60	-----> functions -q __fish_git_prompt_ready
131	57211	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57080	57080	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
57	56440	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
47	56383	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
5	5	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
27	82	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	43	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
2	81	------> if test -n "$step" -a -n "$total"...
79	79	-------> test -n "$step" -a -n "$total"
9	56076	------> if test -z "$branch"...
7	7	-------> test -z "$branch"
4	56060	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
101	56056	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
55955	55955	---------> command git symbolic-ref HEAD 2>/dev/null
2	17	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
6	6	------> echo $detached
5	5	------> echo $bare
8	8	----> set -l r $rbc[1]
7	7	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
6	6	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
13	13	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
2	6	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50076	56009	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5933	5933	-----> read -lz key value
9	40	----> if not set -q dirty[1]...
15	15	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
9	9	----> contains untrackedfiles $__fish_git_prompt_status_order
9	71	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
22	55	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
62	77	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
2	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
21	21	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	32	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
3	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
0	4	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
30	30	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
9	589	> fish_title
6	580	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
6	559	--> if set -q argv[1]...
3	3	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
64	496	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
28	425	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
8	8	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
11	326	-----> for path in $argv...
39	49	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
39	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	202	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	117	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
38	93	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
41	55	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	65	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
23	23	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
55	213	> __fish_disable_bracketed_paste ff
158	158	-> printf "\e[?2004l"
32	1969	> fish_title ff
23	1937	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
18	1864	--> if set -q argv[1]...
10	10	---> set -q argv[1]
359	1836	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
36	36	----> string sub -l 20 -- $argv[1]
153	1441	----> prompt_pwd -d 1 -D 1
25	25	-----> set -l options h/help d/dir-length= D/full-length-dirs=
63	63	-----> argparse -n prompt_pwd $options -- $argv
4	15	-----> if set -q _flag_help...
11	11	------> set -q _flag_help
10	10	-----> set -q argv[1]
24	24	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
35	1070	-----> for path in $argv...
137	196	------> set -l realhome (string escape --style=regex -- ~)
59	59	-------> string escape --style=regex -- ~
120	185	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
65	65	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
20	654	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
22	22	-------> test "$fish_prompt_pwd_dir_length" -eq 0
10	10	-------> set -l full
21	396	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
13	13	--------> test $fish_prompt_pwd_full_dirs -gt 0
152	325	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
98	173	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
75	75	----------> math $fish_prompt_pwd_full_dirs - 1
25	25	--------> set tmp $all[1]
12	12	--------> set full $all[2..]
141	206	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
65	65	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
132	2154204	> ff
2154072	2154072	-> fastfetch $argv
77	180	> __fish_enable_bracketed_paste
103	103	-> printf "\e[?2004h"
33	169	> fish_mode_prompt
74	136	-> fish_default_mode_prompt
10	62	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
40	40	---> test "$fish_key_bindings" = fish_vi_key_bindings
12	12	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
46	230861	> fish_prompt
25	25	-> set -l last_status $status
92	159	-> set -l normal (set_color normal)
67	67	--> set_color normal
104	122	-> set -l status_color (set_color brgreen)
18	18	--> set_color brgreen
91	111	-> set -l cwd_color (set_color $fish_color_cwd)
20	20	--> set_color $fish_color_cwd
76	91	-> set -l vcs_color (set_color brpurple)
15	15	--> set_color brpurple
12	12	-> set -l prompt_status ""
8	8	-> set -q fish_prompt_pwd_dir_length
10	10	-> set -lx fish_prompt_pwd_dir_length 0
9	9	-> set -l suffix '❯'
4	276	-> if functions -q fish_is_root_user...
110	110	--> functions -q fish_is_root_user
26	162	--> fish_is_root_user
5	71	---> if test "$EUID" = 0 2>/dev/null...
66	66	----> test "$EUID" = 0 2>/dev/null
2	57	---> if contains -- $USER root toor Administrator...
55	55	----> contains -- $USER root toor Administrator
8	8	---> return 1
2	15	-> if test $last_status -ne 0...
13	13	--> test $last_status -ne 0
203	229964	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
71	788	--> prompt_login
2	12	---> if not set -q __fish_machine...
10	10	----> not set -q __fish_machine
3	10	---> if set -q __fish_machine[1]...
7	7	----> set -q __fish_machine[1]
15	15	---> set -l color_host $fish_color_host
2	9	---> if set -q SSH_TTY...
7	7	----> set -q SSH_TTY
415	671	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
21	21	----> set_color $fish_color_user
14	14	----> set_color normal
40	40	----> set_color $color_host
97	164	----> prompt_hostname
67	67	-----> string replace -r -- "\..*" "" $hostname
17	17	----> set_color normal
56	481	--> prompt_pwd
20	20	---> set -l options h/help d/dir-length= D/full-length-dirs=
30	30	---> argparse -n prompt_pwd $options -- $argv
3	11	---> if set -q _flag_help...
8	8	----> set -q _flag_help
7	7	---> set -q argv[1]
14	14	---> set argv $PWD
6	6	---> set -ql _flag_d
9	9	---> set -q fish_prompt_pwd_dir_length
9	9	---> set -l fulldirs 0
5	5	---> set -ql _flag_D
7	7	---> set -q fish_prompt_pwd_full_dirs
9	9	---> set -l fish_prompt_pwd_full_dirs 1
26	298	---> for path in $argv...
100	121	----> set -l realhome (string escape --style=regex -- ~)
21	21	-----> string escape --style=regex -- ~
74	114	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
40	40	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	37	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
16	16	-----> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-----> echo $tmp
62	228492	--> fish_vcs_prompt
129	228430	---> fish_git_prompt $argv
13	57288	----> if not command -sq git...
57275	57275	-----> not command -sq git
2	84	----> if functions -q __fish_git_prompt_ready...
82	82	-----> functions -q __fish_git_prompt_ready
145	56061	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
55916	55916	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
59	57241	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	57182	-----> __fish_git_prompt_operation_branch_bare $repo_info
13	13	------> set -l git_dir $argv[1]
7	7	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
9	9	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
24	80	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
5	43	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
2	10	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
9	56945	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	56932	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
87	56928	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56841	56841	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
5	5	----> set -l p
7	7	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
5	5	----> set -l informative
4	4	----> set -l dirty
6	6	----> set -l untracked
51147	57044	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5897	5897	-----> read -lz key value
6	39	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
12	23	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
9	9	----> contains untrackedfiles $__fish_git_prompt_status_order
9	70	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
5	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
59	76	----> set b (string replace refs/heads/ '' -- $b)
17	17	-----> string replace refs/heads/ '' -- $b
1	22	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
21	21	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	31	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
10	665	> fish_title
9	655	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
7	633	--> if set -q argv[1]...
3	3	---> set -q argv[1]
46	52	---> set -l command (status current-command)
6	6	----> status current-command
5	21	---> if test "$command" = fish...
10	10	----> test "$command" = fish
6	6	----> set command
81	550	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
27	460	----> prompt_pwd -d 1 -D 1
9	9	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	358	-----> for path in $argv...
41	52	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
43	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	227	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
8	140	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
57	115	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
44	58	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
49	68	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
54	204	> __fish_disable_bracketed_paste ff
150	150	-> printf "\e[?2004l"
35	2315	> fish_title ff
24	2280	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
20	2206	--> if set -q argv[1]...
11	11	---> set -q argv[1]
411	2175	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
204	1733	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
70	70	-----> argparse -n prompt_pwd $options -- $argv
4	20	-----> if set -q _flag_help...
16	16	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
70	1294	-----> for path in $argv...
191	224	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
184	270	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
86	86	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
24	730	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
19	453	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
141	382	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
134	241	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
107	107	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
153	211	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
58	58	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
99	377539	> ff
377440	377440	-> fastfetch $argv
36	82	> __fish_enable_bracketed_paste
46	46	-> printf "\e[?2004h"
17	237	> fish_mode_prompt
100	220	-> fish_default_mode_prompt
18	120	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
74	74	---> test "$fish_key_bindings" = fish_vi_key_bindings
28	28	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
49	227886	> fish_prompt
22	22	-> set -l last_status $status
102	161	-> set -l normal (set_color normal)
59	59	--> set_color normal
53	68	-> set -l status_color (set_color brgreen)
15	15	--> set_color brgreen
61	76	-> set -l cwd_color (set_color $fish_color_cwd)
15	15	--> set_color $fish_color_cwd
57	65	-> set -l vcs_color (set_color brpurple)
8	8	--> set_color brpurple
9	9	-> set -l prompt_status ""
7	7	-> set -q fish_prompt_pwd_dir_length
6	6	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
4	208	-> if functions -q fish_is_root_user...
81	81	--> functions -q fish_is_root_user
26	123	--> fish_is_root_user
4	56	---> if test "$EUID" = 0 2>/dev/null...
52	52	----> test "$EUID" = 0 2>/dev/null
2	36	---> if contains -- $USER root toor Administrator...
34	34	----> contains -- $USER root toor Administrator
5	5	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
170	227188	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
40	374	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
202	308	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
8	8	----> set_color normal
10	10	----> set_color $color_host
39	69	----> prompt_hostname
30	30	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
22	228	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
14	148	---> for path in $argv...
41	52	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
41	63	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	19	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
53	226416	--> fish_vcs_prompt
107	226363	---> fish_git_prompt $argv
13	52486	----> if not command -sq git...
52473	52473	-----> not command -sq git
3	72	----> if functions -q __fish_git_prompt_ready...
69	69	-----> functions -q __fish_git_prompt_ready
133	57443	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57310	57310	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
23	23	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
64	58144	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	58080	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
24	77	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
12	57855	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
10	57839	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
98	57829	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57731	57731	---------> command git symbolic-ref HEAD 2>/dev/null
2	17	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
9	9	----> set -l r $rbc[1]
10	10	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
51460	57511	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6051	6051	-----> read -lz key value
7	39	----> if not set -q dirty[1]...
15	15	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
2	17	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
10	10	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	73	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
2	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
5	14	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
9	9	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
71	88	----> set b (string replace refs/heads/ '' -- $b)
17	17	-----> string replace refs/heads/ '' -- $b
1	34	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
33	33	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
26	26	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	761	> fish_title
9	751	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
10	729	--> if set -q argv[1]...
3	3	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
2	13	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
107	662	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
30	546	----> prompt_pwd -d 1 -D 1
10	10	-----> set -l options h/help d/dir-length= D/full-length-dirs=
27	27	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
8	8	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
18	433	-----> for path in $argv...
43	56	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
59	96	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
37	37	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
13	263	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
13	13	-------> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-------> set -l full
6	143	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
7	7	--------> test $fish_prompt_pwd_full_dirs -gt 0
52	117	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
48	65	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
62	88	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
26	26	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
38	73	> __fish_disable_bracketed_paste ff
35	35	-> printf "\e[?2004l"
22	1457	> fish_title ff
18	1435	-> if not set -q INSIDE_EMACS...
16	16	--> not set -q INSIDE_EMACS
11	11	--> set -l ssh
7	7	--> set -q SSH_TTY
13	1383	--> if set -q argv[1]...
7	7	---> set -q argv[1]
266	1363	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
20	20	----> string sub -l 20 -- $argv[1]
61	1077	----> prompt_pwd -d 1 -D 1
23	23	-----> set -l options h/help d/dir-length= D/full-length-dirs=
46	46	-----> argparse -n prompt_pwd $options -- $argv
3	11	-----> if set -q _flag_help...
8	8	------> set -q _flag_help
7	7	-----> set -q argv[1]
13	13	-----> set argv $PWD
6	6	-----> set -ql _flag_d
14	14	-----> set -l fish_prompt_pwd_dir_length $_flag_d
6	6	-----> set -q fish_prompt_pwd_dir_length
8	8	-----> set -l fulldirs 0
5	5	-----> set -ql _flag_D
11	11	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
6	6	-----> set -q fish_prompt_pwd_full_dirs
27	860	-----> for path in $argv...
92	114	------> set -l realhome (string escape --style=regex -- ~)
22	22	-------> string escape --style=regex -- ~
83	129	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
46	46	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
20	590	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
19	19	-------> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-------> set -l full
24	299	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
12	12	--------> test $fish_prompt_pwd_full_dirs -gt 0
102	235	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
108	133	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
25	25	----------> math $fish_prompt_pwd_full_dirs - 1
18	18	--------> set tmp $all[1]
10	10	--------> set full $all[2..]
199	243	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
44	44	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
108	248747	> ff
248639	248639	-> fastfetch $argv
38	83	> __fish_enable_bracketed_paste
45	45	-> printf "\e[?2004h"
15	77	> fish_mode_prompt
25	62	-> fish_default_mode_prompt
5	37	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
24	24	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
47	224055	> fish_prompt
23	23	-> set -l last_status $status
51	63	-> set -l normal (set_color normal)
12	12	--> set_color normal
58	67	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
132	178	-> set -l cwd_color (set_color $fish_color_cwd)
46	46	--> set_color $fish_color_cwd
96	112	-> set -l vcs_color (set_color brpurple)
16	16	--> set_color brpurple
8	8	-> set -l prompt_status ""
17	17	-> set -q fish_prompt_pwd_dir_length
11	11	-> set -lx fish_prompt_pwd_dir_length 0
17	17	-> set -l suffix '❯'
6	97	-> if functions -q fish_is_root_user...
13	13	--> functions -q fish_is_root_user
16	78	--> fish_is_root_user
2	46	---> if test "$EUID" = 0 2>/dev/null...
44	44	----> test "$EUID" = 0 2>/dev/null
1	12	---> if contains -- $USER root toor Administrator...
11	11	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
134	223394	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
36	378	--> prompt_login
4	11	---> if not set -q __fish_machine...
7	7	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
10	10	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
218	312	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
14	14	----> set_color $fish_color_user
8	8	----> set_color normal
9	9	----> set_color $color_host
17	53	----> prompt_hostname
36	36	-----> string replace -r -- "\..*" "" $hostname
10	10	----> set_color normal
28	266	--> prompt_pwd
10	10	---> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	---> argparse -n prompt_pwd $options -- $argv
3	7	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
14	164	---> for path in $argv...
48	63	----> set -l realhome (string escape --style=regex -- ~)
15	15	-----> string escape --style=regex -- ~
41	66	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	21	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-----> echo $tmp
11	222616	--> fish_vcs_prompt
111	222605	---> fish_git_prompt $argv
12	51357	----> if not command -sq git...
51345	51345	-----> not command -sq git
3	31	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
157	56696	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56539	56539	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
74	57267	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
47	57193	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
5	5	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	79	------> if test -d $git_dir/rebase-merge...
14	14	-------> test -d $git_dir/rebase-merge
4	42	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
0	9	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	56962	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
6	56950	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
83	56944	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56861	56861	---------> command git symbolic-ref HEAD 2>/dev/null
3	17	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
11	11	----> set -l r $rbc[1]
7	7	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
7	7	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
2	6	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
19	19	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
6	6	----> set -l untracked
50614	56534	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5920	5920	-----> read -lz key value
5	40	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
4	19	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
11	11	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	73	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	44	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	11	------> begin...
8	8	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	52	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
70	82	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	32	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
33	33	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
9	626	> fish_title
7	617	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
8	596	--> if set -q argv[1]...
3	3	---> set -q argv[1]
36	42	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
80	530	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
26	443	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
18	345	-----> for path in $argv...
39	49	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
37	57	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	221	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	126	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	103	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
47	64	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
55	73	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
76	276	> __fish_disable_bracketed_paste ff
200	200	-> printf "\e[?2004l"
46	3566	> fish_title ff
31	3520	-> if not set -q INSIDE_EMACS...
33	33	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
15	15	--> set -q SSH_TTY
15	3416	--> if set -q argv[1]...
16	16	---> set -q argv[1]
520	3385	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
45	45	----> string sub -l 20 -- $argv[1]
274	2820	----> prompt_pwd -d 1 -D 1
50	50	-----> set -l options h/help d/dir-length= D/full-length-dirs=
102	102	-----> argparse -n prompt_pwd $options -- $argv
7	27	-----> if set -q _flag_help...
20	20	------> set -q _flag_help
15	15	-----> set -q argv[1]
29	29	-----> set argv $PWD
13	13	-----> set -ql _flag_d
30	30	-----> set -l fish_prompt_pwd_dir_length $_flag_d
14	14	-----> set -q fish_prompt_pwd_dir_length
19	19	-----> set -l fulldirs 0
13	13	-----> set -ql _flag_D
23	23	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
13	13	-----> set -q fish_prompt_pwd_full_dirs
63	2198	-----> for path in $argv...
190	237	------> set -l realhome (string escape --style=regex -- ~)
47	47	-------> string escape --style=regex -- ~
272	363	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
91	91	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
34	1535	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
53	53	-------> test "$fish_prompt_pwd_dir_length" -eq 0
23	23	-------> set -l full
27	974	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
26	26	--------> test $fish_prompt_pwd_full_dirs -gt 0
240	882	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
470	642	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
172	172	----------> math $fish_prompt_pwd_full_dirs - 1
22	22	--------> set tmp $all[1]
17	17	--------> set full $all[2..]
370	451	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
81	81	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
99	212748	> ff
212649	212649	-> fastfetch $argv
24	56	> __fish_enable_bracketed_paste
32	32	-> printf "\e[?2004h"
14	88	> fish_mode_prompt
34	74	-> fish_default_mode_prompt
7	40	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
26	26	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
42	226228	> fish_prompt
21	21	-> set -l last_status $status
46	86	-> set -l normal (set_color normal)
40	40	--> set_color normal
57	67	-> set -l status_color (set_color brgreen)
10	10	--> set_color brgreen
58	76	-> set -l cwd_color (set_color $fish_color_cwd)
18	18	--> set_color $fish_color_cwd
40	51	-> set -l vcs_color (set_color brpurple)
11	11	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	171	-> if functions -q fish_is_root_user...
70	70	--> functions -q fish_is_root_user
16	98	--> fish_is_root_user
2	46	---> if test "$EUID" = 0 2>/dev/null...
44	44	----> test "$EUID" = 0 2>/dev/null
1	32	---> if contains -- $USER root toor Administrator...
31	31	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
171	225673	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
43	402	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
207	334	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
8	8	----> set_color normal
8	8	----> set_color $color_host
48	77	----> prompt_hostname
29	29	-----> string replace -r -- "\..*" "" $hostname
22	22	----> set_color normal
52	291	--> prompt_pwd
11	11	---> set -l options h/help d/dir-length= D/full-length-dirs=
17	17	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
16	172	---> for path in $argv...
50	63	----> set -l realhome (string escape --style=regex -- ~)
13	13	-----> string escape --style=regex -- ~
42	73	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
31	31	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	20	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
45	224809	--> fish_vcs_prompt
112	224764	---> fish_git_prompt $argv
11	51724	----> if not command -sq git...
51713	51713	-----> not command -sq git
5	80	----> if functions -q __fish_git_prompt_ready...
75	75	-----> functions -q __fish_git_prompt_ready
149	57117	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56968	56968	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
63	56969	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
44	56906	-----> __fish_git_prompt_operation_branch_bare $repo_info
11	11	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
8	8	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
27	84	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
5	44	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
10	10	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
7	56674	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56663	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	56661	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56572	56572	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
9	9	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
7	7	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
2	6	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
5	5	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
52228	58167	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5939	5939	-----> read -lz key value
6	41	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
5	16	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	74	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
6	47	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
5	12	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
3	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	52	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
72	87	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	601	> fish_title
8	591	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
6	569	--> if set -q argv[1]...
3	3	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
6	16	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
71	503	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
21	425	----> prompt_pwd -d 1 -D 1
10	10	-----> set -l options h/help d/dir-length= D/full-length-dirs=
26	26	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	324	-----> for path in $argv...
39	51	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
37	62	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	197	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	117	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
42	94	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	52	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
40	61	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
109	270	> __fish_enable_bracketed_paste
161	161	-> printf "\e[?2004h"
108	392	> fish_mode_prompt
196	284	-> fish_default_mode_prompt
17	88	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
51	51	---> test "$fish_key_bindings" = fish_vi_key_bindings
20	20	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
91	240992	> fish_prompt
42	42	-> set -l last_status $status
209	300	-> set -l normal (set_color normal)
91	91	--> set_color normal
216	253	-> set -l status_color (set_color brgreen)
37	37	--> set_color brgreen
184	223	-> set -l cwd_color (set_color $fish_color_cwd)
39	39	--> set_color $fish_color_cwd
143	189	-> set -l vcs_color (set_color brpurple)
46	46	--> set_color brpurple
19	19	-> set -l prompt_status ""
12	12	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
14	14	-> set -l suffix '❯'
7	464	-> if functions -q fish_is_root_user...
152	152	--> functions -q fish_is_root_user
35	305	--> fish_is_root_user
6	148	---> if test "$EUID" = 0 2>/dev/null...
142	142	----> test "$EUID" = 0 2>/dev/null
14	111	---> if contains -- $USER root toor Administrator...
97	97	----> contains -- $USER root toor Administrator
11	11	---> return 1
4	23	-> if test $last_status -ne 0...
19	19	--> test $last_status -ne 0
438	239333	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
101	1531	--> prompt_login
5	20	---> if not set -q __fish_machine...
15	15	----> not set -q __fish_machine
3	14	---> if set -q __fish_machine[1]...
11	11	----> set -q __fish_machine[1]
23	23	---> set -l color_host $fish_color_host
4	14	---> if set -q SSH_TTY...
10	10	----> set -q SSH_TTY
934	1359	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
27	27	----> set_color $fish_color_user
70	70	----> set_color normal
46	46	----> set_color $color_host
147	244	----> prompt_hostname
97	97	-----> string replace -r -- "\..*" "" $hostname
38	38	----> set_color normal
151	831	--> prompt_pwd
32	32	---> set -l options h/help d/dir-length= D/full-length-dirs=
43	43	---> argparse -n prompt_pwd $options -- $argv
19	33	---> if set -q _flag_help...
14	14	----> set -q _flag_help
10	10	---> set -q argv[1]
19	19	---> set argv $PWD
8	8	---> set -ql _flag_d
10	10	---> set -q fish_prompt_pwd_dir_length
13	13	---> set -l fulldirs 0
8	8	---> set -ql _flag_D
10	10	---> set -q fish_prompt_pwd_full_dirs
12	12	---> set -l fish_prompt_pwd_full_dirs 1
38	482	---> for path in $argv...
133	177	----> set -l realhome (string escape --style=regex -- ~)
44	44	-----> string escape --style=regex -- ~
141	208	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
67	67	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
12	59	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
26	26	-----> test "$fish_prompt_pwd_dir_length" -eq 0
21	21	-----> echo $tmp
94	236533	--> fish_vcs_prompt
143	236439	---> fish_git_prompt $argv
13	64012	----> if not command -sq git...
63999	63999	-----> not command -sq git
2	71	----> if functions -q __fish_git_prompt_ready...
69	69	-----> functions -q __fish_git_prompt_ready
136	58241	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58105	58105	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
58	56810	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
39	56752	-----> __fish_git_prompt_operation_branch_bare $repo_info
7	7	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
3	3	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	83	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
11	48	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
9	56529	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56516	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
86	56514	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56428	56428	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
13	13	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50711	56606	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5895	5895	-----> read -lz key value
6	38	----> if not set -q dirty[1]...
15	15	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	74	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
6	47	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
7	13	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
8	8	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	46	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
63	78	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
2	21	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
19	19	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
3	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
15	15	-> echo -n -s $status_color $suffix ' ' $normal
11	627	> fish_title
7	616	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
8	8	--> set -l ssh
4	4	--> set -q SSH_TTY
6	590	--> if set -q argv[1]...
4	4	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
2	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
5	5	----> set command
65	521	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
27	448	----> prompt_pwd -d 1 -D 1
11	11	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	345	-----> for path in $argv...
38	53	------> set -l realhome (string escape --style=regex -- ~)
15	15	-------> string escape --style=regex -- ~
38	61	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	217	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
5	133	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	111	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	74	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
32	32	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
46	65	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
24	39	> __fish_enable_bracketed_paste
15	15	-> printf "\e[?2004h"
9	40	> fish_mode_prompt
10	31	-> fish_default_mode_prompt
3	21	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
10	10	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
25	227320	> fish_prompt
9	9	-> set -l last_status $status
36	45	-> set -l normal (set_color normal)
9	9	--> set_color normal
37	50	-> set -l status_color (set_color brgreen)
13	13	--> set_color brgreen
35	45	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
37	44	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
9	9	-> set -l prompt_status ""
3	3	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	72	-> if functions -q fish_is_root_user...
7	7	--> functions -q fish_is_root_user
11	63	--> fish_is_root_user
2	39	---> if test "$EUID" = 0 2>/dev/null...
37	37	----> test "$EUID" = 0 2>/dev/null
1	9	---> if contains -- $USER root toor Administrator...
8	8	----> contains -- $USER root toor Administrator
4	4	---> return 1
0	6	-> if test $last_status -ne 0...
6	6	--> test $last_status -ne 0
114	226989	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
15	288	--> prompt_login
2	6	---> if not set -q __fish_machine...
4	4	----> not set -q __fish_machine
1	4	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
184	252	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
9	9	----> set_color $fish_color_user
11	11	----> set_color normal
9	9	----> set_color $color_host
12	26	----> prompt_hostname
14	14	-----> string replace -r -- "\..*" "" $hostname
13	13	----> set_color normal
21	208	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
12	12	---> argparse -n prompt_pwd $options -- $argv
1	4	---> if set -q _flag_help...
3	3	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
13	134	---> for path in $argv...
38	48	----> set -l realhome (string escape --style=regex -- ~)
10	10	-----> string escape --style=regex -- ~
40	55	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
15	15	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
10	226379	--> fish_vcs_prompt
86	226369	---> fish_git_prompt $argv
11	52317	----> if not command -sq git...
52306	52306	-----> not command -sq git
2	29	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
175	57423	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57248	57248	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
61	58642	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	58581	-----> __fish_git_prompt_operation_branch_bare $repo_info
8	8	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
3	3	------> set -l total
23	96	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
7	60	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
25	25	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	58346	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	58334	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
113	58331	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58218	58218	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
22	22	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
13	13	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
5	5	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
51361	57276	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5915	5915	-----> read -lz key value
8	43	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
6	6	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
10	10	----> contains untrackedfiles $__fish_git_prompt_status_order
10	73	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
5	44	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	11	------> begin...
8	8	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	16	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	50	----> for i in $__fish_git_prompt_status_order...
2	8	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
66	79	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	21	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
19	19	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	32	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
9	648	> fish_title
8	639	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
3	3	--> set -q SSH_TTY
6	618	--> if set -q argv[1]...
4	4	---> set -q argv[1]
37	42	---> set -l command (status current-command)
5	5	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
100	554	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
30	446	----> prompt_pwd -d 1 -D 1
11	11	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
16	336	-----> for path in $argv...
42	53	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
41	66	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	201	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
5	119	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	96	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
43	56	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
40	62	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
22	22	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
12	23	> __fish_enable_bracketed_paste
11	11	-> printf "\e[?2004h"
8	34	> fish_mode_prompt
9	26	-> fish_default_mode_prompt
4	17	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
8	8	---> test "$fish_key_bindings" = fish_vi_key_bindings
5	5	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
27	227010	> fish_prompt
10	10	-> set -l last_status $status
34	41	-> set -l normal (set_color normal)
7	7	--> set_color normal
34	42	-> set -l status_color (set_color brgreen)
8	8	--> set_color brgreen
37	46	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	39	-> set -l vcs_color (set_color brpurple)
6	6	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
1	65	-> if functions -q fish_is_root_user...
8	8	--> functions -q fish_is_root_user
10	56	--> fish_is_root_user
1	33	---> if test "$EUID" = 0 2>/dev/null...
32	32	----> test "$EUID" = 0 2>/dev/null
1	9	---> if contains -- $USER root toor Administrator...
8	8	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	6	-> if test $last_status -ne 0...
5	5	--> test $last_status -ne 0
133	226703	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	289	--> prompt_login
1	5	---> if not set -q __fish_machine...
4	4	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
0	4	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
191	254	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
9	9	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
10	26	----> prompt_hostname
16	16	-----> string replace -r -- "\..*" "" $hostname
14	14	----> set_color normal
22	251	--> prompt_pwd
10	10	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
3	3	---> set -q argv[1]
7	7	---> set argv $PWD
2	2	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
14	166	---> for path in $argv...
56	69	----> set -l realhome (string escape --style=regex -- ~)
13	13	-----> string escape --style=regex -- ~
41	63	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	20	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
10	226030	--> fish_vcs_prompt
84	226020	---> fish_git_prompt $argv
11	51728	----> if not command -sq git...
51717	51717	-----> not command -sq git
9	36	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
130	58593	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58463	58463	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
12	12	----> set -l sha $repo_info[5]
79	58252	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	58173	-----> __fish_git_prompt_operation_branch_bare $repo_info
8	8	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
4	4	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
30	89	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
6	46	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
11	11	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
7	57940	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	57929	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
84	57925	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57841	57841	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
9	9	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
2	6	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
12	12	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50750	56760	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6010	6010	-----> read -lz key value
11	46	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
2	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	49	----> for i in $__fish_git_prompt_status_order...
2	8	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
60	72	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
21	21	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
0	4	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
4	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
4	4	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
8	589	> fish_title
6	581	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	561	--> if set -q argv[1]...
4	4	---> set -q argv[1]
36	41	---> set -l command (status current-command)
5	5	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
67	498	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
25	423	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	325	-----> for path in $argv...
40	50	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
42	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	198	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
8	117	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	91	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	51	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	62	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
76	150	> __fish_disable_bracketed_paste ls
74	74	-> printf "\e[?2004l"
49	3262	> fish_title ls
32	3213	-> if not set -q INSIDE_EMACS...
35	35	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
16	16	--> set -q SSH_TTY
16	3105	--> if set -q argv[1]...
16	16	---> set -q argv[1]
443	3073	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
44	44	----> string sub -l 20 -- $argv[1]
137	2586	----> prompt_pwd -d 1 -D 1
49	49	-----> set -l options h/help d/dir-length= D/full-length-dirs=
112	112	-----> argparse -n prompt_pwd $options -- $argv
6	27	-----> if set -q _flag_help...
21	21	------> set -q _flag_help
16	16	-----> set -q argv[1]
29	29	-----> set argv $PWD
14	14	-----> set -ql _flag_d
33	33	-----> set -l fish_prompt_pwd_dir_length $_flag_d
14	14	-----> set -q fish_prompt_pwd_dir_length
18	18	-----> set -l fulldirs 0
12	12	-----> set -ql _flag_D
25	25	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
14	14	-----> set -q fish_prompt_pwd_full_dirs
69	2086	-----> for path in $argv...
260	310	------> set -l realhome (string escape --style=regex -- ~)
50	50	-------> string escape --style=regex -- ~
276	374	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
98	98	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
38	1333	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
52	52	-------> test "$fish_prompt_pwd_dir_length" -eq 0
22	22	-------> set -l full
37	856	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
26	26	--------> test $fish_prompt_pwd_full_dirs -gt 0
304	724	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
357	420	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
63	63	----------> math $fish_prompt_pwd_full_dirs - 1
45	45	--------> set tmp $all[1]
24	24	--------> set full $all[2..]
257	365	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
108	108	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
123	84008	> ls
83885	83885	-> eza -lha $argv
27	55	> __fish_enable_bracketed_paste
28	28	-> printf "\e[?2004h"
11	52	> fish_mode_prompt
13	41	-> fish_default_mode_prompt
3	28	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
25	222689	> fish_prompt
15	15	-> set -l last_status $status
44	53	-> set -l normal (set_color normal)
9	9	--> set_color normal
39	48	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
36	45	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
32	38	-> set -l vcs_color (set_color brpurple)
6	6	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	77	-> if functions -q fish_is_root_user...
8	8	--> functions -q fish_is_root_user
13	67	--> fish_is_root_user
1	38	---> if test "$EUID" = 0 2>/dev/null...
37	37	----> test "$EUID" = 0 2>/dev/null
3	12	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
126	222348	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
19	356	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
210	313	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
22	22	----> set_color normal
17	17	----> set_color $color_host
16	46	----> prompt_hostname
30	30	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
26	250	--> prompt_pwd
9	9	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
8	8	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
21	163	---> for path in $argv...
47	58	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
42	65	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	19	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
12	221616	--> fish_vcs_prompt
95	221604	---> fish_git_prompt $argv
11	50538	----> if not command -sq git...
50527	50527	-----> not command -sq git
3	26	----> if functions -q __fish_git_prompt_ready...
23	23	-----> functions -q __fish_git_prompt_ready
137	56437	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56300	56300	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
8	8	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
59	56972	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
44	56913	-----> __fish_git_prompt_operation_branch_bare $repo_info
12	12	------> set -l git_dir $argv[1]
8	8	------> set -l inside_gitdir $argv[2]
7	7	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
4	4	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
24	85	------> if test -d $git_dir/rebase-merge...
14	14	-------> test -d $git_dir/rebase-merge
7	47	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
10	10	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
7	56676	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
6	56664	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
85	56658	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56573	56573	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
6	6	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
15	15	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50948	56944	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5996	5996	-----> read -lz key value
6	42	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
6	23	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
13	13	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	77	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
9	46	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
4	14	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
10	10	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	45	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
60	73	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
8	8	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
2	13	----> if test -z "$format"...
5	5	-----> test -z "$format"
6	6	-----> set format " (%s)"
30	30	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
11	698	> fish_title
7	687	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
10	666	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	43	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
78	597	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
10	10	----> string sub -l 20 -- $command
30	509	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
9	9	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
19	402	-----> for path in $argv...
39	51	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
39	61	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	271	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
10	140	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
52	113	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	61	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
22	22	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
87	107	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
32	53	> __fish_disable_bracketed_paste 'git status'
21	21	-> printf "\e[?2004l"
15	847	> fish_title git\ status
10	832	-> if not set -q INSIDE_EMACS...
11	11	--> not set -q INSIDE_EMACS
8	8	--> set -l ssh
4	4	--> set -q SSH_TTY
5	799	--> if set -q argv[1]...
4	4	---> set -q argv[1]
127	790	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
15	15	----> string sub -l 20 -- $argv[1]
73	648	----> prompt_pwd -d 1 -D 1
11	11	-----> set -l options h/help d/dir-length= D/full-length-dirs=
34	34	-----> argparse -n prompt_pwd $options -- $argv
2	7	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
4	4	-----> set -q argv[1]
8	8	-----> set argv $PWD
5	5	-----> set -ql _flag_d
10	10	-----> set -l fish_prompt_pwd_dir_length $_flag_d
5	5	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
4	4	-----> set -ql _flag_D
7	7	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
4	4	-----> set -q fish_prompt_pwd_full_dirs
19	471	-----> for path in $argv...
55	70	------> set -l realhome (string escape --style=regex -- ~)
15	15	-------> string escape --style=regex -- ~
57	88	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
31	31	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
14	294	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
21	21	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
8	147	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
7	7	--------> test $fish_prompt_pwd_full_dirs -gt 0
56	118	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
45	62	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
75	99	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
24	24	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
64763	64763	> git status
34	68	> __fish_enable_bracketed_paste
34	34	-> printf "\e[?2004h"
12	61	> fish_mode_prompt
17	49	-> fish_default_mode_prompt
5	32	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
20	20	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
42	224512	> fish_prompt
19	19	-> set -l last_status $status
47	58	-> set -l normal (set_color normal)
11	11	--> set_color normal
36	45	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
42	53	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
53	60	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
13	13	-> set -l prompt_status ""
7	7	-> set -q fish_prompt_pwd_dir_length
6	6	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
3	88	-> if functions -q fish_is_root_user...
14	14	--> functions -q fish_is_root_user
14	71	--> fish_is_root_user
2	41	---> if test "$EUID" = 0 2>/dev/null...
39	39	----> test "$EUID" = 0 2>/dev/null
1	12	---> if contains -- $USER root toor Administrator...
11	11	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
122	224095	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
15	291	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
10	10	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
172	250	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
13	13	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
15	43	----> prompt_hostname
28	28	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
24	252	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
20	171	---> for path in $argv...
42	53	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
45	78	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
33	33	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	20	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
12	223430	--> fish_vcs_prompt
95	223418	---> fish_git_prompt $argv
14	51545	----> if not command -sq git...
51531	51531	-----> not command -sq git
2	44	----> if functions -q __fish_git_prompt_ready...
42	42	-----> functions -q __fish_git_prompt_ready
144	57051	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56907	56907	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
58	56959	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
53	56901	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
44	100	------> if test -d $git_dir/rebase-merge...
15	15	-------> test -d $git_dir/rebase-merge
5	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
10	56645	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
2	56630	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
84	56628	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56544	56544	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
2	8	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
6	6	----> set -l untracked
50992	57088	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6096	6096	-----> read -lz key value
5	67	----> if not set -q dirty[1]...
43	43	-----> not set -q dirty[1]
19	19	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
17	17	----> contains dirtystate $__fish_git_prompt_status_order
4	18	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
9	9	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	72	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	44	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
5	5	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
3	3	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
21	49	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
78	90	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	27	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
25	25	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
7	37	----> if test -n "$b"...
7	7	-----> test -n "$b"
9	9	-----> set b "$branch_color$b$branch_done"
2	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
32	32	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
12	647	> fish_title
10	635	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
6	607	--> if set -q argv[1]...
4	4	---> set -q argv[1]
43	49	---> set -l command (status current-command)
6	6	----> status current-command
4	15	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
71	533	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
31	454	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	351	-----> for path in $argv...
46	57	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
39	63	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
10	216	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	119	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	95	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
37	55	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
18	18	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
56	75	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
60	103	> __fish_disable_bracketed_paste 'git add .'
43	43	-> printf "\e[?2004l"
38	2145	> fish_title git\ add\ .
25	2107	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
19	2031	--> if set -q argv[1]...
11	11	---> set -q argv[1]
358	2001	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
41	41	----> string sub -l 20 -- $argv[1]
99	1602	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
77	77	-----> argparse -n prompt_pwd $options -- $argv
5	19	-----> if set -q _flag_help...
14	14	------> set -q _flag_help
11	11	-----> set -q argv[1]
22	22	-----> set argv $PWD
11	11	-----> set -ql _flag_d
28	28	-----> set -l fish_prompt_pwd_dir_length $_flag_d
20	20	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
17	17	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
51	1234	-----> for path in $argv...
129	164	------> set -l realhome (string escape --style=regex -- ~)
35	35	-------> string escape --style=regex -- ~
137	213	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
76	76	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
41	806	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
26	425	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
15	15	--------> test $fish_prompt_pwd_full_dirs -gt 0
185	339	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
117	154	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
37	37	----------> math $fish_prompt_pwd_full_dirs - 1
30	30	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
230	298	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
68	68	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
76253	76253	> git add .
33	67	> __fish_enable_bracketed_paste
34	34	-> printf "\e[?2004h"
11	53	> fish_mode_prompt
13	42	-> fish_default_mode_prompt
4	29	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
24	226468	> fish_prompt
13	13	-> set -l last_status $status
47	57	-> set -l normal (set_color normal)
10	10	--> set_color normal
36	44	-> set -l status_color (set_color brgreen)
8	8	--> set_color brgreen
35	45	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
34	40	-> set -l vcs_color (set_color brpurple)
6	6	--> set_color brpurple
5	5	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	78	-> if functions -q fish_is_root_user...
12	12	--> functions -q fish_is_root_user
12	64	--> fish_is_root_user
2	36	---> if test "$EUID" = 0 2>/dev/null...
34	34	----> test "$EUID" = 0 2>/dev/null
2	12	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
117	226127	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	273	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
159	235	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
7	7	----> set_color normal
7	7	----> set_color $color_host
13	46	----> prompt_hostname
33	33	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
32	241	--> prompt_pwd
13	13	---> set -l options h/help d/dir-length= D/full-length-dirs=
19	19	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
17	140	---> for path in $argv...
37	48	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
38	57	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
19	19	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
11	225496	--> fish_vcs_prompt
90	225485	---> fish_git_prompt $argv
11	51454	----> if not command -sq git...
51443	51443	-----> not command -sq git
3	37	----> if functions -q __fish_git_prompt_ready...
34	34	-----> functions -q __fish_git_prompt_ready
181	57218	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57037	57037	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
12	12	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
62	56768	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	56706	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
11	11	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	96	------> if test -d $git_dir/rebase-merge...
17	17	-------> test -d $git_dir/rebase-merge
6	55	-------> if test -d $git_dir/rebase-apply...
14	14	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
8	8	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
10	56456	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
7	56442	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
101	56435	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56334	56334	---------> command git symbolic-ref HEAD 2>/dev/null
2	17	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
13	13	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
15	15	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
6	6	----> set -l untracked
53163	59309	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6146	6146	-----> read -lz key value
10	47	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
19	19	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
5	17	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	78	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
8	49	-----> if test "$informative" = true...
7	7	------> test "$informative" = true
3	11	------> begin...
8	8	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
2	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
67	83	----> set b (string replace refs/heads/ '' -- $b)
16	16	-----> string replace refs/heads/ '' -- $b
2	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	34	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
5	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	594	> fish_title
9	585	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
6	561	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	43	---> set -l command (status current-command)
6	6	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
63	497	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
31	427	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
8	8	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	325	-----> for path in $argv...
38	50	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
38	62	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	198	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	119	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	97	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	57	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
42	61	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
24	89	> __fish_disable_bracketed_paste ld
65	65	-> printf "\e[?2004l"
12	655	> fish_title ld
7	643	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
4	4	--> set -q SSH_TTY
4	616	--> if set -q argv[1]...
4	4	---> set -q argv[1]
101	608	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
13	13	----> string sub -l 20 -- $argv[1]
57	494	----> prompt_pwd -d 1 -D 1
9	9	-----> set -l options h/help d/dir-length= D/full-length-dirs=
25	25	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	359	-----> for path in $argv...
41	52	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
39	67	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
28	28	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	226	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
12	12	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
9	138	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	111	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
58	72	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
44	65	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
297043	297043	> ld
30	62	> __fish_enable_bracketed_paste
32	32	-> printf "\e[?2004h"
12	86	> fish_mode_prompt
41	74	-> fish_default_mode_prompt
3	33	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
22	22	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
54	225224	> fish_prompt
45	45	-> set -l last_status $status
78	194	-> set -l normal (set_color normal)
116	116	--> set_color normal
99	108	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
71	81	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
39	71	-> set -l vcs_color (set_color brpurple)
32	32	--> set_color brpurple
6	6	-> set -l prompt_status ""
34	34	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
25	25	-> set -l suffix '❯'
7	147	-> if functions -q fish_is_root_user...
54	54	--> functions -q fish_is_root_user
14	86	--> fish_is_root_user
2	39	---> if test "$EUID" = 0 2>/dev/null...
37	37	----> test "$EUID" = 0 2>/dev/null
2	29	---> if contains -- $USER root toor Administrator...
27	27	----> contains -- $USER root toor Administrator
4	4	---> return 1
5	78	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
43	53	--> set status_color (set_color $fish_color_error)
10	10	---> set_color $fish_color_error
13	13	--> set prompt_status $status_color "[" $last_status "]" $normal
270	224361	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
69	761	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
2	5	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
474	669	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
7	7	----> set_color normal
55	55	----> set_color $color_host
78	113	----> prompt_hostname
35	35	-----> string replace -r -- "\..*" "" $hostname
8	8	----> set_color normal
32	445	--> prompt_pwd
14	14	---> set -l options h/help d/dir-length= D/full-length-dirs=
41	41	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
73	317	---> for path in $argv...
61	72	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
94	150	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
56	56	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	22	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-----> echo $tmp
42	222885	--> fish_vcs_prompt
143	222843	---> fish_git_prompt $argv
12	52110	----> if not command -sq git...
52098	52098	-----> not command -sq git
4	110	----> if functions -q __fish_git_prompt_ready...
106	106	-----> functions -q __fish_git_prompt_ready
139	56895	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56756	56756	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
11	11	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
71	56689	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
47	56618	-----> __fish_git_prompt_operation_branch_bare $repo_info
11	11	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
5	5	------> set -l total
23	79	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	44	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
5	17	------> if test -n "$step" -a -n "$total"...
12	12	-------> test -n "$step" -a -n "$total"
10	56380	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
3	56365	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	56362	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56274	56274	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
12	12	----> set -l r $rbc[1]
7	7	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
6	6	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50408	56302	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5894	5894	-----> read -lz key value
7	39	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
10	10	----> contains untrackedfiles $__fish_git_prompt_status_order
9	73	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
7	43	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	6	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
21	49	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
73	85	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
3	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
16	16	-> echo -n -s $status_color $suffix ' ' $normal
13	653	> fish_title
7	640	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
6	615	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	45	---> set -l command (status current-command)
7	7	----> status current-command
2	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
5	5	----> set command
66	546	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
27	472	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	9	-----> if set -q _flag_help...
7	7	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
4	4	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	363	-----> for path in $argv...
45	56	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
38	63	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	231	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	146	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	123	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
41	86	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
45	45	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
46	65	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
51	98	> __fish_disable_bracketed_paste ls
47	47	-> printf "\e[?2004l"
32	1775	> fish_title ls
21	1743	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
11	1671	--> if set -q argv[1]...
11	11	---> set -q argv[1]
293	1649	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
30	30	----> string sub -l 20 -- $argv[1]
88	1326	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
22	22	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
51	1001	-----> for path in $argv...
110	142	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
132	205	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
73	73	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
21	603	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
18	346	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
123	278	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
118	155	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
37	37	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
14	14	--------> set full $all[2..]
131	195	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
64	64	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
86	78329	> ls
78243	78243	-> eza -lha $argv
25	60	> __fish_enable_bracketed_paste
35	35	-> printf "\e[?2004h"
11	67	> fish_mode_prompt
15	56	-> fish_default_mode_prompt
15	41	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
35	224504	> fish_prompt
13	13	-> set -l last_status $status
45	56	-> set -l normal (set_color normal)
11	11	--> set_color normal
39	47	-> set -l status_color (set_color brgreen)
8	8	--> set_color brgreen
35	45	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
34	41	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	78	-> if functions -q fish_is_root_user...
9	9	--> functions -q fish_is_root_user
13	66	--> fish_is_root_user
2	37	---> if test "$EUID" = 0 2>/dev/null...
35	35	----> test "$EUID" = 0 2>/dev/null
2	12	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
140	224145	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	284	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
2	5	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
161	247	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
14	52	----> prompt_hostname
38	38	-----> string replace -r -- "\..*" "" $hostname
9	9	----> set_color normal
27	295	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
21	205	---> for path in $argv...
53	64	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
64	96	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
32	32	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	24	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-----> echo $tmp
14	223426	--> fish_vcs_prompt
95	223412	---> fish_git_prompt $argv
17	51102	----> if not command -sq git...
51085	51085	-----> not command -sq git
2	28	----> if functions -q __fish_git_prompt_ready...
26	26	-----> functions -q __fish_git_prompt_ready
159	56772	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56613	56613	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
24	24	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
8	8	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
8	8	----> set -l sha $repo_info[5]
60	57244	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
39	57184	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
3	3	------> set -l total
25	77	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
4	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	56966	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56954	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
85	56952	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56867	56867	---------> command git symbolic-ref HEAD 2>/dev/null
2	15	------> if test true = $inside_gitdir...
13	13	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
5	5	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
51514	57580	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6066	6066	-----> read -lz key value
6	41	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
18	18	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
16	16	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	76	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
5	46	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
2	10	------> begin...
8	8	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
4	10	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	13	-----> if set -q __fish_git_prompt_showupstream...
5	5	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
2	7	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
65	79	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
2	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
21	21	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	32	----> if test -n "$b"...
5	5	-----> test -n "$b"
9	9	-----> set b "$branch_color$b$branch_done"
3	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
30	30	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
16	16	-> echo -n -s $status_color $suffix ' ' $normal
10	612	> fish_title
8	602	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
5	578	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
3	14	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
67	512	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
23	437	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
8	8	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	340	-----> for path in $argv...
45	56	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
43	63	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	206	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
8	123	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
42	98	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	56	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	63	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
45	76	> __fish_disable_bracketed_paste 'git status'
31	31	-> printf "\e[?2004l"
25	1250	> fish_title git\ status
16	1225	-> if not set -q INSIDE_EMACS...
15	15	--> not set -q INSIDE_EMACS
11	11	--> set -l ssh
7	7	--> set -q SSH_TTY
7	1176	--> if set -q argv[1]...
7	7	---> set -q argv[1]
160	1162	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
21	21	----> string sub -l 20 -- $argv[1]
46	981	----> prompt_pwd -d 1 -D 1
15	15	-----> set -l options h/help d/dir-length= D/full-length-dirs=
50	50	-----> argparse -n prompt_pwd $options -- $argv
3	10	-----> if set -q _flag_help...
7	7	------> set -q _flag_help
6	6	-----> set -q argv[1]
12	12	-----> set argv $PWD
6	6	-----> set -ql _flag_d
14	14	-----> set -l fish_prompt_pwd_dir_length $_flag_d
7	7	-----> set -q fish_prompt_pwd_dir_length
8	8	-----> set -l fulldirs 0
6	6	-----> set -ql _flag_D
11	11	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
6	6	-----> set -q fish_prompt_pwd_full_dirs
28	784	-----> for path in $argv...
98	120	------> set -l realhome (string escape --style=regex -- ~)
22	22	-------> string escape --style=regex -- ~
131	192	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
61	61	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
24	444	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
21	21	-------> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-------> set -l full
12	268	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
11	11	--------> test $fish_prompt_pwd_full_dirs -gt 0
108	214	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
80	106	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
26	26	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
10	10	--------> set full $all[2..]
83	122	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
39	39	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
69287	69287	> git status
28	66	> __fish_enable_bracketed_paste
38	38	-> printf "\e[?2004h"
22	66	> fish_mode_prompt
13	44	-> fish_default_mode_prompt
4	31	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
20	20	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
37	222791	> fish_prompt
17	17	-> set -l last_status $status
43	58	-> set -l normal (set_color normal)
15	15	--> set_color normal
37	46	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
37	48	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
33	40	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	84	-> if functions -q fish_is_root_user...
13	13	--> functions -q fish_is_root_user
15	69	--> fish_is_root_user
2	38	---> if test "$EUID" = 0 2>/dev/null...
36	36	----> test "$EUID" = 0 2>/dev/null
2	12	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
121	222420	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
19	292	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
2	6	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
158	247	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
30	30	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
13	38	----> prompt_hostname
25	25	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
22	234	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
5	5	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
25	156	---> for path in $argv...
42	52	----> set -l realhome (string escape --style=regex -- ~)
10	10	-----> string escape --style=regex -- ~
37	61	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
9	221773	--> fish_vcs_prompt
100	221764	---> fish_git_prompt $argv
12	51591	----> if not command -sq git...
51579	51579	-----> not command -sq git
3	39	----> if functions -q __fish_git_prompt_ready...
36	36	-----> functions -q __fish_git_prompt_ready
151	56049	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
55898	55898	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
60	56976	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	56916	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	84	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
5	47	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
12	12	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
9	56691	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56678	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
129	56676	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56547	56547	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
2	8	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50309	56379	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6070	6070	-----> read -lz key value
7	47	----> if not set -q dirty[1]...
20	20	-----> not set -q dirty[1]
20	20	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
17	17	----> contains dirtystate $__fish_git_prompt_status_order
3	16	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
9	9	----> contains untrackedfiles $__fish_git_prompt_status_order
8	79	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
8	50	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	14	------> begin...
11	11	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
9	15	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
21	58	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
2	11	-----> if test -n "$$i"...
9	9	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
62	81	----> set b (string replace refs/heads/ '' -- $b)
19	19	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	35	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
3	17	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
8	8	------> test -n "$___fish_git_prompt_char_cleanstate"
1	6	----> if test -n "$c"...
5	5	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
2	7	----> if test -n "$f"...
5	5	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
31	31	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
11	754	> fish_title
7	743	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
7	722	--> if set -q argv[1]...
3	3	---> set -q argv[1]
53	61	---> set -l command (status current-command)
8	8	----> status current-command
5	20	---> if test "$command" = fish...
10	10	----> test "$command" = fish
5	5	----> set command
77	631	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
24	545	----> prompt_pwd -d 1 -D 1
12	12	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
19	442	-----> for path in $argv...
81	92	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
67	104	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
37	37	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	227	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	126	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
42	100	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
41	58	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
55	75	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
13960	147421	> source /usr/local/Cellar/fish/3.7.1/share/fish/completions/git.fish
9	9	-> function __fish_git...
3	3	-> function __fish_git_global_optspecs...
3	3	-> function __fish_git_commits...
6	6	-> function __fish_git_recent_commits...
2	2	-> function __fish_git_branches...
3	3	-> function __fish_git_submodules...
2	2	-> function __fish_git_local_branches...
2	2	-> function __fish_git_unique_remote_branches...
2	2	-> function __fish_git_tags...
3	3	-> function __fish_git_heads...
1	1	-> function __fish_git_refs...
1	1	-> function __fish_git_remotes...
1	1	-> function __fish_git_files...
1	1	-> function __fish_git_rev_files...
2	2	-> function __fish_git_complete_rev_files...
2	2	-> function __fish_git_needs_rev_files...
12	12	-> function __fish_git_ranges...
1	1	-> function __fish_git_needs_command...
1	1	-> function __fish_git_config_keys...
1	1	-> function __fish_git_aliased_command...
51940	57960	-> git config -z --get-regexp 'alias\..*' | while read -lz alias cmdline
    set -l command (__fish_git_aliased_command $cmdline)
    string match -q --regex '\w+' -- $command; or continue
    # Git aliases can contain chars that variable names can't - escape them.
    set -l alias (string replace 'alias.' '' -- $alias | string escape --style=var)
    set -g __fish_git_alias_$alias $command $cmdline
    set --append -g __fish_git_aliases $alias
end
6020	6020	--> read -lz alias cmdline
17	17	-> for alias in $__fish_git_aliases...
6	6	-> function __fish_git_using_command...
2	2	-> function __fish_git_contains_opt...
3	3	-> function __fish_git_stash_using_command...
2	2	-> function __fish_git_stash_not_using_subcommand...
2	2	-> function __fish_git_complete_worktrees...
1	1	-> function __fish_git_complete_stashes...
1	1	-> function __fish_git_aliases...
2	2	-> function __fish_git_custom_commands...
2	2	-> function __fish_git_branch_for_remote...
2	2	-> function __fish_git_possible_commithash...
1	1	-> function __fish_git_reflog...
2	2	-> function __fish_git_help_all_concepts...
4	4	-> function __fish_git_diff_opt -a option...
5	5	-> function __fish_git_show_opt -a option...
2	2	-> function __fish_git_is_rebasing...
57	57	-> complete git -f -l help -s h -d 'Display manual of a Git command'
21	21	-> complete git -f -n __fish_git_needs_command -l version -s v -d 'display git version'
18	18	-> complete git -x -n __fish_git_needs_command -s C -a '(__fish_complete_directories)' -d 'run as if started in dir'
27	27	-> complete git -x -n __fish_git_needs_command -s c -a '(__fish_git config -l 2>/dev/null | string replace = \t)' -d 'set config option (conf-key=val)'
20	20	-> complete git -x -n __fish_git_needs_command -l config-env -a '(__fish_git config -l 2>/dev/null | string replace = \t)' -d 'like -c but environment var (conf-key=ENVVAR)'
17	17	-> complete git -x -n __fish_git_needs_command -l exec-path -a '(__fish_complete_directories)' -d 'get or set the path to git'
11	11	-> complete git -f -n __fish_git_needs_command -l html-path -d 'print html docs path'
12	12	-> complete git -f -n __fish_git_needs_command -l man-path -d 'print man pages path'
8	8	-> complete git -f -n __fish_git_needs_command -l info-path -d 'print info docs path'
11	11	-> complete git -f -n __fish_git_needs_command -s p -l paginate -d 'pipe output into pager'
9	9	-> complete git -f -n __fish_git_needs_command -s P -l no-pager -d 'don\'t pipe output into pager'
9	9	-> complete git -r -n __fish_git_needs_command -l git-dir -d 'set path to the repo'
13	13	-> complete git -r -n __fish_git_needs_command -l work-tree -d 'set path to the working tree'
10	10	-> complete git -f -n __fish_git_needs_command -l namespace -d 'set Git namespace'
9	9	-> complete git -f -n __fish_git_needs_command -l bare -d 'treat the repo as bare'
9	9	-> complete git -f -n __fish_git_needs_command -l no-replace-objects -d 'disable replacement references'
9	9	-> complete git -f -n __fish_git_needs_command -l literal-pathspecs -d 'treat pathspecs literally'
9	9	-> complete git -f -n __fish_git_needs_command -l glob-pathspecs -d 'treat pathspecs as globs'
9	9	-> complete git -f -n __fish_git_needs_command -l noglob-pathspecs -d 'don\'t treat pathspecs as globs'
11	11	-> complete git -f -n __fish_git_needs_command -l icase-pathspecs -d 'match pathspecs case-insensitively'
10	10	-> complete git -f -n __fish_git_needs_command -l no-optional-locks -d 'skip optional operations requiring locks'
23	23	-> complete git -x -n __fish_git_needs_command -l list-cmds -d 'list commands by group' -k -a "builtins\t
parseopt\t'builtins using parse-options'
others\t'git- commands in \$PATH'
nohelpers\t'exclude helper commands'
config\t'list completion.commands'"
19	19	-> complete -f -c git -n '__fish_git_using_command log show diff-tree rev-list' -l pretty -a '(__fish_git_show_opt pretty)'
13	13	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l abbrev -d 'Show only a partial prefix instead of the full 40-byte hexadecimal object name'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l binary -d 'Output a binary diff that can be applied with "git-apply"'
15	15	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l check -d 'Warn if changes introduce conflict markers or whitespace errors'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l color -d 'Show colored diff'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l color-moved -d 'Moved lines of code are colored differently'
13	13	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l color-words -d 'Equivalent to --word-diff=color plus --word-diff-regex=<regex>'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l compact-summary -d 'Output a condensed summary of extended header information'
11	11	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -l dst-prefix -d 'Show the given destination prefix instead of "b/"'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l ext-diff -d 'Allow an external diff helper to be executed'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l find-copies-harder -d 'Inspect unmodified files as candidates for the source of copy'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l find-object -d 'Look for differences that change the number of occurrences of the object'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l full-index -d 'Show the full pre- and post-image blob object names on the "index" line'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l histogram -d 'Generate a diff using the "histogram diff" algorithm'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l ignore-blank-lines -d 'Ignore changes whose lines are all blank'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l ignore-cr-at-eol -d 'Ignore carrige-return at the end of line when doing a comparison'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l ignore-space-at-eol -d 'Ignore changes in whitespace at EOL'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l indent-heuristic -d 'Enable the heuristic that shift diff hunk boundaries'
13	13	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -l inter-hunk-context -d 'Show the context between diff hunks, up to the specified number of lines'
13	13	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -l ita-invisible-in-index -d 'Make the entry appear as a new file in "git diff" and non-existent in "git diff -l cached"'
11	11	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -l line-prefix -d 'Prepend an additional prefix to every line of output'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l minimal -d 'Spend extra time to make sure the smallest possible diff is produced'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l name-only -d 'Show only names of changed files'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l name-status -d 'Show only names and status of changed files'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l no-color -d 'Turn off colored diff'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l no-ext-diff -d 'Disallow external diff drivers'
10	10	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l no-indent-heuristic -d 'Disable the indent heuristic'
11	11	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -l no-prefix -d 'Do not show any source or destination prefix'
14	14	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l no-renames -d 'Turn off rename detection'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l no-textconv -d 'Disallow external text conversion filters to be run when comparing binary files'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l numstat -d 'Shows number of added/deleted lines in decimal notation'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l patch-with-raw -d 'Synonym for -p --raw'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l patch-with-stat -d 'Synonym for -p --stat'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l patience -d 'Generate a diff using the "patience diff" algorithm'
14	14	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -l pickaxe-all -d 'When -S or -G finds a change, show all the changes in that changeset'
13	13	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -l pickaxe-regex -d 'Treat the <string> given to -S as an extended POSIX regular expression to match'
12	12	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -l relative -d 'Exclude changes outside the directory and show relative pathnames'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l shortstat -d 'Output only the last line of the --stat format containing total number of modified files'
18	18	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -l src-prefix -d 'Show the given source prefix instead of "a/"'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l stat -d 'Generate a diffstat'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff apply' -l stat -d 'Generate a diffstat'
13	13	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l summary -d 'Output a condensed summary of extended header information'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l textconv -d 'Allow external text conversion filters to be run when comparing binary files'
10	10	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l word-diff -d 'Show a word diff'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -l word-diff-regex -d 'Use <regex> to decide what a word is'
12	12	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -s a -l text -d 'Treat all files as text'
15	15	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -s B -l break-rewrites -d 'Break complete rewrite changes into pairs of delete and create'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -s b -l ignore-space-change -d 'Ignore changes in amount of whitespace'
12	12	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -s C -l find-copies -d 'Detect copies as well as renames'
12	12	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -s D -l irreversible-delete -d 'Omit the preimage for deletes'
12	12	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -s G -d "Look for differences where <regex> matches the patch's added/removed lines"
12	12	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -s M -l find-renames -d 'Detect and report renames'
11	11	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -s R -d 'Swap inputs to create a reverse diff'
12	12	-> complete -c git -n '__fish_git_using_command diff log show range-diff' -s S -d 'Look for differences that change the number of occurrences of the string'
12	12	-> complete -c git -n '__fish_git_using_command diff show range-diff' -s W -l function-context -d 'Show whole surrounding functions of changes'
14	14	-> complete -c git -n '__fish_git_using_command diff show range-diff' -s w -l ignore-all-space -d 'Ignore whitespace when comparing lines'
11	11	-> complete -c git -n '__fish_git_using_command diff show range-diff' -s z -d 'Use NULs as output field/commit terminators'
11	11	-> complete -r -c git -n '__fish_git_using_command diff log show range-diff' -s O -d 'Control the order in which files appear in the output'
12	12	-> complete -f -c git -n '__fish_git_using_command diff show range-diff' -l anchored -d 'Generate a diff using the "anchored diff" algorithm'
13	13	-> complete -x -c git -n '__fish_git_using_command diff log show range-diff' -s l -d 'Prevents rename/copy detection when rename/copy targets exceed the given number'
18	18	-> complete -x -c git -n '__fish_git_using_command diff show range-diff' -l diff-filter -a '(__fish_git_diff_opt diff-filter)' -d 'Choose diff filters'
18	18	-> complete -x -c git -n '__fish_git_using_command diff log show range-diff' -l diff-algorithm -a '(__fish_git_diff_opt diff-algorithm)' -d 'Choose a diff algorithm'
18	18	-> complete -x -c git -n '__fish_git_using_command diff log show range-diff' -l dirstat -a '(__fish_git_diff_opt dirstat)' -d 'Output the distribution of relative amount of changes for each sub-directory'
19	19	-> complete -x -c git -n '__fish_git_using_command diff log show range-diff' -l ignore-submodules -a '(__fish_git_diff_opt ignore-submodules)' -d 'Ignore changes to submodules in the diff generation'
17	17	-> complete -x -c git -n '__fish_git_using_command diff log show range-diff' -l submodule -a '(__fish_git_diff_opt submodule)' -d 'Specify how differences in submodules are shown'
18	18	-> complete -x -c git -n '__fish_git_using_command diff log show range-diff' -l ws-error-highlight -a '(__fish_git_diff_opt ws-error-highlight)' -d 'Highlight whitespace errors in lines of the diff'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch pull' -l unshallow -d 'Convert a shallow repository to a complete one'
13	13	-> complete -f -c git -n '__fish_git_using_command fetch pull' -l set-upstream -d 'Add upstream (tracking) reference'
10	10	-> complete -f -c git -n __fish_git_needs_command -a fetch -d 'Download objects from another repo'
19	19	-> complete -f -c git -n '__fish_git_using_command fetch' -n 'not __fish_git_branch_for_remote' -a '(__fish_git_remotes)' -d Remote
18	18	-> complete -f -c git -n '__fish_git_using_command fetch' -n __fish_git_branch_for_remote -ka '(__fish_git_branch_for_remote)'
13	13	-> complete -f -c git -n '__fish_git_using_command fetch' -s q -l quiet -d 'Be more quiet'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch' -s v -l verbose -d 'Be more verbose'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch' -s a -l append -d 'Append to .git/FETCH_HEAD instead of overwriting'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -l upload-pack -d 'Path to upload pack on remote end'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -s f -l force -d 'Force update of local branches'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch' -s p -l prune -d 'Prune remote-tracking branches no longer on remote'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -l all -d 'Fetch all remotes'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -l atomic -d 'Use atomic transfer to update references'
14	14	-> complete -f -c git -n '__fish_git_using_command fetch' -s m -l multiple -d 'Fetch from multiple remotes'
13	13	-> complete -f -c git -n '__fish_git_using_command fetch' -s t -l tags -d 'Fetch all tags and associated objects'
12	12	-> complete -f -c git -n '__fish_git_using_command fetch' -s P -l prune-tags -d 'Prune local tags no longer on remote and clobber changed tags'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch' -l prefetch -d 'Modify the refspec to replace all refs within refs/prefetch/'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch' -s j -l jobs -d 'Numbers of submodules fetched in parallel'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -s n -d 'Do not fetch all tags (--no-tags)'
17	17	-> complete -f -c git -n '__fish_git_using_command fetch' -l dry-run -d 'Dry run'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -l depth -d 'Limit number of commits'
12	12	-> complete -f -c git -n '__fish_git_using_command fetch' -l with-fetch-head -d 'Write fetched references to the FETCH_HEAD file'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -l update-shallow -d 'Accept refs that update .git/shallow'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch' -s k -l keep -d 'Keep downloaded pack'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch' -s u -l update-head-ok -d 'Allow updating of HEAD ref'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch' -l progress -d 'Force progress reporting'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -l deepen -d 'Deepen history of shallow clones'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -l shallow-since -d 'Deepen history of shallow repository based on time'
11	11	-> complete -f -c git -n '__fish_git_using_command fetch' -l shallow-exclude -d 'Deepen history of shallow clone, excluding rev'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -l unshallow -d 'Convert to a complete repository'
10	10	-> complete -f -c git -n '__fish_git_using_command fetch' -l refetch -d 'Re-fetch without negotiating common commits'
19	19	-> complete -f -c git -n '__fish_git_using_command fetch' -l negotiation-tip -d 'Only report commits reachable from these tips' -kxa '(__fish_git_commits; __fish_git_branches)'
12	12	-> complete -f -c git -n '__fish_git_using_command fetch' -l negotiate-only -d "Don't fetch, only show commits in common with the server"
10	10	-> complete -f -c git -n __fish_git_needs_command -a filter-branch -d 'Rewrite branches'
11	11	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l env-filter -d 'Filter for rewriting env vars like author name/email'
11	11	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l tree-filter -d 'Filter for rewriting the tree and its contents'
10	10	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l index-filter -d 'Filter for rewriting the index'
10	10	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l parent-filter -d 'Filter for rewriting the commit'
11	11	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l msg-filter -d 'Filter for rewriting the commit messages'
10	10	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l commit-filter -d 'Filter for performing the commit'
10	10	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l tag-name-filter -d 'Filter for rewriting tag names'
11	11	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l subdirectory-filter -d 'Only look at the history which touches the given subdirectory'
10	10	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l prune-empty -d 'Ignore empty commits generated by filters'
11	11	-> complete -f -c git -n '__fish_git_using_command filter-branch' -l original -d 'Use this option to set the namespace where the original commits will be stored'
11	11	-> complete -r -c git -n '__fish_git_using_command filter-branch' -s d -d 'Use this option to set the path to the temporary directory used for rewriting'
12	12	-> complete -c git -n '__fish_git_using_command filter-branch' -s f -l force -d 'Filter even with refs in refs/original or existing temp directory'
12	12	-> set -l remotecommands add rm remove show prune update rename set-head set-url set-branches get-url
11	11	-> complete -f -c git -n __fish_git_needs_command -a remote -d 'Manage tracked repositories'
32	32	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from $remotecommands" -a '(__fish_git_remotes)'
25	25	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -s v -l verbose -d 'Be verbose'
26	26	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a add -d 'Adds a new remote'
23	23	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a rm -d 'Removes a remote'
23	23	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a remove -d 'Removes a remote'
24	24	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a show -d 'Shows a remote'
23	23	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a prune -d 'Deletes all stale tracking branches'
23	23	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a update -d 'Fetches updates'
22	22	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a rename -d 'Renames a remote'
24	24	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a set-head -d 'Sets the default branch for a remote'
22	22	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a set-url -d 'Changes URLs for a remote'
22	22	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a get-url -d 'Retrieves URLs for a remote'
23	23	-> complete -f -c git -n "__fish_git_using_command remote" -n "not __fish_seen_subcommand_from $remotecommands" -a set-branches -d 'Changes the list of branches tracked by a remote'
15	15	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from add " -s f -d 'Once the remote information is set up git fetch <name> is run'
14	14	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from add " -l tags -d 'Import every tag from a remote with git fetch <name>'
14	14	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from add " -l no-tags -d "Don't import tags from a remote with git fetch <name>"
17	17	-> complete -f -c git -n '__fish_git_using_command remote' -n '__fish_seen_subcommand_from remove' -xa '(__fish_git_remotes)'
18	18	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from set-branches" -l add -d 'Add to the list of currently tracked branches instead of replacing it'
14	14	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from set-url" -l push -d 'Manipulate push URLs instead of fetch URLs'
15	15	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from set-url" -l add -d 'Add new URL instead of changing the existing URLs'
14	14	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from set-url" -l delete -d 'Remove URLs that match specified URL'
14	14	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from get-url" -l push -d 'Query push URLs rather than fetch URLs'
14	14	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from get-url" -l all -d 'All URLs for the remote will be listed'
15	15	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from show" -s n -d 'Remote heads are not queried, cached information is used instead'
15	15	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from prune" -l dry-run -d 'Report what will be pruned but do not actually prune it'
15	15	-> complete -f -c git -n "__fish_git_using_command remote" -n "__fish_seen_subcommand_from update" -l prune -d 'Prune all remotes that are updated'
13	13	-> complete -f -c git -n __fish_git_needs_command -a show -d 'Show the last commit of a branch'
22	22	-> complete -f -c git -n '__fish_git_using_command show' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_branches)'
21	21	-> complete -f -c git -n '__fish_git_using_command show' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_tags)' -d Tag
20	20	-> complete -f -c git -n '__fish_git_using_command show' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_commits)'
20	20	-> complete -f -c git -n '__fish_git_using_command show' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_complete_stashes)'
18	18	-> complete -f -c git -n __fish_git_needs_rev_files -n 'not contains -- -- (commandline -opc)' -xa '(__fish_git_complete_rev_files)'
16	16	-> complete -F -c git -n '__fish_git_using_command show' -n 'contains -- -- (commandline -opc)'
21	21	-> complete -f -c git -n '__fish_git_using_command show' -l format -d 'Pretty-print the contents of the commit logs in a given format' -a '(__fish_git_show_opt format)'
14	14	-> complete -f -c git -n '__fish_git_using_command show' -l abbrev-commit -d 'Show only a partial hexadecimal commit object name'
12	12	-> complete -f -c git -n '__fish_git_using_command show' -l no-abbrev-commit -d 'Show the full 40-byte hexadecimal commit object name'
11	11	-> complete -f -c git -n '__fish_git_using_command show' -l oneline -d 'Shorthand for "--pretty=oneline --abbrev-commit"'
11	11	-> complete -f -c git -n '__fish_git_using_command show' -l encoding -d 'Re-code the commit log message in the encoding'
10	10	-> complete -f -c git -n '__fish_git_using_command show' -l expand-tabs -d 'Perform a tab expansion in the log message'
12	12	-> complete -f -c git -n '__fish_git_using_command show' -l no-expand-tabs -d 'Do not perform a tab expansion in the log message'
15	15	-> complete -f -c git -n '__fish_git_using_command show' -l notes -ka '(__fish_git_refs)' -d 'Show the notes that annotate the commit'
12	12	-> complete -f -c git -n '__fish_git_using_command show' -l no-notes -d 'Do not show notes'
11	11	-> complete -f -c git -n '__fish_git_using_command show' -s s -l no-patch -d 'Suppress diff output'
10	10	-> complete -f -c git -n '__fish_git_using_command show' -l show-signature -d 'Check the validity of a signed commit object'
10	10	-> complete -f -c git -n __fish_git_needs_command -a show-branch -d 'Show the commits on branches'
24	24	-> complete -f -c git -n '__fish_git_using_command show-branch' -ka '(__fish_git_refs)' -d Rev
13	13	-> complete -f -c git -n '__fish_git_using_command show-branch' -s r -l remotes -d "Shows the remote tracking branches"
14	14	-> complete -f -c git -n '__fish_git_using_command show-branch' -s a -l all -d "Show both remote-tracking branches and local branches"
12	12	-> complete -f -c git -n '__fish_git_using_command show-branch' -l current -d "Includes the current branch to the list of revs to be shown"
11	11	-> complete -f -c git -n '__fish_git_using_command show-branch' -l topo-order -d "Makes commits appear in topological order"
10	10	-> complete -f -c git -n '__fish_git_using_command show-branch' -l date-order -d "Makes commits appear in date order"
10	10	-> complete -f -c git -n '__fish_git_using_command show-branch' -l sparse -d "Shows merges only reachable from one tip"
10	10	-> complete -f -c git -n '__fish_git_using_command show-branch' -l no-name -d "Do not show naming strings for each commit"
11	11	-> complete -f -c git -n '__fish_git_using_command show-branch' -l sha1-name -d "Name commits with unique prefix"
10	10	-> complete -f -c git -n '__fish_git_using_command show-branch' -l no-color -d "Turn off colored output"
10	10	-> complete -f -c git -n '__fish_git_using_command show-branch' -l merge-base -d "Determine merge bases for the given commits"
12	12	-> complete -f -c git -n '__fish_git_using_command show-branch' -l independent -d "Show which refs can't be reached from any other"
10	10	-> complete -f -c git -n '__fish_git_using_command show-branch' -l topics -d "Show only commits that are not on the first given branch"
10	10	-> complete -c git -n __fish_git_needs_command -a add -d 'Add file contents to the staging area'
13	13	-> complete -c git -n '__fish_git_using_command add' -s n -l dry-run -d "Don't actually add the file(s)"
11	11	-> complete -c git -n '__fish_git_using_command add' -s v -l verbose -d 'Be verbose'
11	11	-> complete -c git -n '__fish_git_using_command add' -s f -l force -d 'Allow adding otherwise ignored files'
11	11	-> complete -c git -n '__fish_git_using_command add' -s i -l interactive -d 'Interactive mode'
11	11	-> complete -c git -n '__fish_git_using_command add' -s p -l patch -d 'Interactively choose hunks to stage'
11	11	-> complete -c git -n '__fish_git_using_command add' -s e -l edit -d 'Manually create a patch'
10	10	-> complete -c git -n '__fish_git_using_command add' -s u -l update -d 'Only match tracked files'
12	12	-> complete -c git -n '__fish_git_using_command add' -s A -l all -d 'Match files both in working tree and index'
11	11	-> complete -c git -n '__fish_git_using_command add' -s N -l intent-to-add -d 'Record only the fact that the path will be added later'
12	12	-> complete -c git -n '__fish_git_using_command add' -l refresh -d "Don't add the file(s), but only refresh their stat"
17	17	-> complete -c git -n '__fish_git_using_command add' -l chmod -xa "-x\t'Track file as non-executable' +x\t'Track file as executable'"
10	10	-> complete -c git -n '__fish_git_using_command add' -l ignore-errors -d 'Ignore errors'
9	9	-> complete -c git -n '__fish_git_using_command add' -l ignore-missing -d 'Check if any of the given files would be ignored'
20	20	-> complete -f -c git -n '__fish_git_using_command add' -a '(__fish_git_files modified untracked deleted unmerged modified-staged-deleted)'
10	10	-> complete -c git -n __fish_git_needs_command -a am -d 'Apply patches from a mailbox'
12	12	-> complete -f -c git -n '__fish_git_using_command am' -s s -l signoff -d 'Add a Signed-off-By trailer to commit message'
11	11	-> complete -f -c git -n '__fish_git_using_command am' -l keep-non-patch -d 'Only strip bracket pairs containing \'PATCH\''
10	10	-> complete -f -c git -n '__fish_git_using_command am' -l no-keep-cr -d 'Override am.keepcr to false'
11	11	-> complete -f -c git -n '__fish_git_using_command am' -s c -l scissors -d 'Remove everything in body before scissors'
11	11	-> complete -f -c git -n '__fish_git_using_command am' -l no-scissors -d 'Ignore scissor lines'
14	14	-> complete -x -c git -n '__fish_git_using_command am' -l quoted-cr -a 'nowarn warn strip' -d 'What to do when an email ends with CRLF'
10	10	-> complete -f -c git -n '__fish_git_using_command am' -l no-messageid -d 'Do not add message id to commit message'
24	24	-> complete -f -c git -n '__fish_git_using_command am' -s q -l quiet -d 'Supress logs'
11	11	-> complete -f -c git -n '__fish_git_using_command am' -l no-utf8 -d 'Disable all charset re-encoding of metadata'
11	11	-> complete -f -c git -n '__fish_git_using_command am' -s 3 -l 3way -d 'Fall back to three way merge on patch failure'
11	11	-> complete -f -c git -n '__fish_git_using_command am' -l no-3way -d 'Do not fall back to three way merge on patch failure'
10	10	-> complete -f -c git -n '__fish_git_using_command am' -l rerere-autoupdate -d 'Allow rerere to update index if possible'
10	10	-> complete -f -c git -n '__fish_git_using_command am' -l ignore-space-change -d 'Pass --ignore-space-change to git apply'
10	10	-> complete -F -c git -n '__fish_git_using_command am' -l directory -d 'Pass --directory to git apply'
10	10	-> complete -F -c git -n '__fish_git_using_command am' -l exclude -d 'Pass --exclude to git apply'
10	10	-> complete -F -c git -n '__fish_git_using_command am' -l include -d 'Pass --include to git apply'
10	10	-> complete -f -c git -n '__fish_git_using_command am' -l reject -d 'Pass --reject to git apply'
17	17	-> complete -x -f git -n '__fish_git_using_command am' -l patch-format -a 'mbox mboxrd stgit stgit-series hg' -d 'Specify the patch format'
10	10	-> complete -f -c git -n '__fish_git_using_command am' -s i -l interactive -d 'Run interactively'
12	12	-> complete -f -c git -n '__fish_git_using_command am' -l committer-date-is-author-date -d 'Treat committer date as author date'
10	10	-> complete -f -c git -n '__fish_git_using_command am' -l ignore-date -d 'Treat author date as committer date'
9	9	-> complete -f -c git -n '__fish_git_using_command am' -l skip -d 'Skip current patch'
21	21	-> complete -x -c git -n '__fish_git_using_command am' -s S -l gpg-sign -a '(type -q gpg && __fish_complete_gpg_key_id gpg)' -d 'Sign commits with gpg'
12	12	-> complete -f -c git -n '__fish_git_using_command am' -l no-gpg-sign -d 'Do not sign commits'
13	13	-> complete -f -c git -n '__fish_git_using_command am' -s r -l resolved -l continue -d 'Mark patch failures as resolved'
10	10	-> complete -x -c git -n '__fish_git_using_command am' -l resolvemsg -d 'Message to print after patch failure'
10	10	-> complete -f -c git -n '__fish_git_using_command am' -l abort -d 'Abort patch operation and restore branch'
10	10	-> complete -f -c git -n '__fish_git_using_command am' -l quit -d 'Abort without restoring branch'
13	13	-> complete -c git -n '__fish_git_using_command am' -l show-current-patch -a 'diff raw' -d 'Show message at which patch failures occured'
16	16	-> complete -F -c git -n '__fish_git_using_command checkout' -n 'contains -- -- (commandline -opc)'
10	10	-> complete -f -c git -n __fish_git_needs_command -a checkout -d 'Checkout and switch to a branch'
21	21	-> complete -f -c git -n '__fish_git_using_command checkout' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_recent_commits --all)'
21	21	-> complete -f -c git -n '__fish_git_using_command checkout' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_tags)' -d Tag
20	20	-> complete -f -c git -n '__fish_git_using_command checkout' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_heads)' -d Head
25	25	-> complete -f -c git -n '__fish_git_using_command checkout' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_unique_remote_branches)' -d 'Unique Remote Branch'
20	20	-> complete -f -c git -n '__fish_git_using_command checkout' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_branches)'
17	17	-> complete -f -c git -n '__fish_git_using_command checkout' -ka '(__fish_git_files modified deleted modified-staged-deleted)'
10	10	-> complete -f -c git -n '__fish_git_using_command checkout' -s b -d 'Create a new branch'
10	10	-> complete -f -c git -n '__fish_git_using_command checkout' -s B -d 'Create a new branch or reset existing to start point'
11	11	-> complete -f -c git -n '__fish_git_using_command checkout' -s t -l track -d 'Track a new branch'
10	10	-> complete -f -c git -n '__fish_git_using_command checkout' -l theirs -d 'Keep staged changes'
10	10	-> complete -f -c git -n '__fish_git_using_command checkout' -l ours -d 'Keep unmerged changes'
10	10	-> complete -f -c git -n '__fish_git_using_command checkout' -l recurse-submodules -d 'Update the work trees of submodules'
10	10	-> complete -f -c git -n '__fish_git_using_command checkout' -l no-recurse-submodules -d 'Do not update the work trees of submodules'
11	11	-> complete -f -c git -n '__fish_git_using_command checkout' -l progress -d 'Report progress even if not connected to a terminal'
10	10	-> complete -f -c git -n '__fish_git_using_command checkout' -l no-progress -d "Don't report progress"
11	11	-> complete -f -c git -n '__fish_git_using_command checkout' -s f -l force -d 'Switch even if working tree differs or unmerged files exist'
11	11	-> complete -c git -n __fish_git_needs_command -a apply -d 'Apply a patch'
13	13	-> complete -f -c git -n '__fish_git_using_command apply' -l numstat -d 'Show number of additions and deletions'
10	10	-> complete -f -c git -n '__fish_git_using_command apply' -l summary -d 'Output a condensed summary'
13	13	-> complete -f -c git -n '__fish_git_using_command apply' -l check -d 'Just check if the patches can be applied'
11	11	-> complete -f -c git -n '__fish_git_using_command apply' -l index -d 'Apply patch to index and working tree'
10	10	-> complete -f -c git -n '__fish_git_using_command apply' -l cached -d 'Apply patch to index'
11	11	-> complete -f -c git -n '__fish_git_using_command apply' -l intent-to-add -d 'Add entry for file in index with no content'
12	12	-> complete -f -c git -n '__fish_git_using_command apply' -s 3 -l 3way -d 'Attempt a 3 way merge on conflicts'
10	10	-> complete -F -c git -n '__fish_git_using_command apply' -l build-fake-ancestor -d 'Build a temporary index containing these blobs'
12	12	-> complete -f -c git -n '__fish_git_using_command apply' -s R -l reverse -d 'Apply the patch in reverse'
12	12	-> complete -f -c git -n '__fish_git_using_command apply' -l reject -d 'Leave rejected hunks in *.rej files'
15	15	-> complete -f -c git -n '__fish_git_using_command apply' -n '__fish_git_contains_opt numstat' -s z -d 'Do not munge pathnames'
11	11	-> complete -x -c git -n '__fish_git_using_command apply am' -s p -d 'Remove n leading path components'
11	11	-> complete -x -c git -n '__fish_git_using_command apply am' -s C -d 'Ensure n that lines of surrounding context match'
10	10	-> complete -f -c git -n '__fish_git_using_command apply' -l unidiff-zero -d 'Do not break on diffs generated using --unified=0'
10	10	-> complete -f -c git -n '__fish_git_using_command apply' -l apply -d 'Always apply patches'
10	10	-> complete -f -c git -n '__fish_git_using_command apply' -l no-add -d 'Ignore additions made by patches'
12	12	-> complete -f -c git -n '__fish_git_using_command apply' -l allow-binary-replacement -l binary -d 'Also patch binaries'
10	10	-> complete -F -c git -n '__fish_git_using_command apply' -l exclude -d 'Dont apply changes to files matching given pattern'
9	9	-> complete -F -c git -n '__fish_git_using_command apply' -l include -d 'Apply changes to files matching given pattern'
15	15	-> complete -f -c git -n '__fish_git_using_command apply am' -l ignore-space-change -l ignore-whitespace -d 'Ignore whitespace change in context lines'
18	18	-> complete -x -c git -n '__fish_git_using_command apply am' -l whitespace -a 'nowarn warn fix error error-all' -d 'Action to take when there are whitespace errors'
12	12	-> complete -f -c git -n '__fish_git_using_command apply' -l inaccurate-eof -d 'Work around some diff versions not detecting newlines at end of file'
11	11	-> complete -f -c git -n '__fish_git_using_command apply' -s v -l verbose -d 'Report progress to stderr'
11	11	-> complete -f -c git -n '__fish_git_using_command apply' -l recount -d 'Do not trust the line counts in the hunk headers'
10	10	-> complete -F -c git -n '__fish_git_using_command apply' -l directory -d 'Prepend given path to all filenames'
11	11	-> complete -f -c git -n '__fish_git_using_command apply' -l unsafe-paths -d 'Allow patches that work outside working area'
12	12	-> complete -f -c git -n __fish_git_needs_command -a archive -d 'Create an archive of files from a tree'
13	13	-> complete -f -c git -n '__fish_git_using_command archive' -s l -l list -d "Show all available formats"
11	11	-> complete -f -c git -n '__fish_git_using_command archive' -s v -l verbose -d "Be verbose"
11	11	-> complete -f -c git -n '__fish_git_using_command archive' -l worktree-attributes -d "Look for attributes in .gitattributes files in the working tree as well"
10	10	-> complete -f -c git -n __fish_git_needs_command -a bisect -d 'Use binary search to find what introduced a bug'
34	34	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_prev_arg_in bisect' -xa "
start\t'Start a new bisect session'
bad\t'Mark a commit as bad'
new\t'Mark a commit as new'
good\t'Mark a commit as good'
old\t'Mark a commit as old'
terms\t'Show terms used for new/old states'
skip\t'Skip some commits'
reset\t'Exit a bisect session and reset HEAD'
visualize\t'See remaining commits in gitk'
replay\t'Replay a bisect log file'
log\t'Record a bisect log file'
run\t'Bisect automaically with the given command as discriminator'
help\t'Print a synopsis of all commands'
"
13	13	-> complete -c git -n '__fish_git_using_command bisect' -n '__fish_seen_argument --' -F
18	18	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from start' -l term-new -l term-bad -x -d 'Use another term instead of new/bad'
16	16	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from start' -l term-old -l term-good -x -d 'Use another term instead of old/good'
15	15	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from start' -l no-checkout -d 'Do not checkout tree, only update BISECT_HEAD'
16	16	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from start' -l first-parent -d 'On merge commits, follow only the first parent commit'
24	24	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from start' -n 'not contains -- -- (commandline -opc)' -a '(__fish_git_refs)'
18	18	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from bad new good old' -a '(__fish_git_refs)'
15	15	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from terms' -l --term-good -d 'Print the term for the old state'
14	14	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from terms' -l --term-bad -d 'Print the term for the new state'
19	19	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from skip' -a '(__fish_git_ranges)'
16	16	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from reset' -a '(__fish_git_refs)'
13	13	-> complete -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from replay' -F
18	18	-> complete -f -c git -n '__fish_git_using_command bisect' -n '__fish_seen_subcommand_from run' -xa '(__fish_complete_subcommand --fcs-skip=3)'
10	10	-> complete -f -c git -n __fish_git_needs_command -a branch -d 'List, create, or delete branches'
13	13	-> complete -f -c git -n '__fish_git_using_command branch' -ka '(__fish_git_branches)'
16	16	-> complete -f -c git -n '__fish_git_using_command branch' -s d -l delete -d 'Delete branch' -xa '(__fish_git_local_branches)'
15	15	-> complete -f -c git -n '__fish_git_using_command branch' -s D -d 'Force deletion of branch' -xa '(__fish_git_local_branches)'
11	11	-> complete -f -c git -n '__fish_git_using_command branch' -s f -l force -d 'Reset branch even if it already exists'
11	11	-> complete -f -c git -n '__fish_git_using_command branch' -s m -l move -d 'Rename branch'
10	10	-> complete -f -c git -n '__fish_git_using_command branch' -s M -d 'Force rename branch'
11	11	-> complete -f -c git -n '__fish_git_using_command branch' -s c -l copy -d 'Copy branch'
10	10	-> complete -f -c git -n '__fish_git_using_command branch' -s C -d 'Force copy branch'
11	11	-> complete -f -c git -n '__fish_git_using_command branch' -s a -l all -d 'Lists both local and remote branches'
16	16	-> complete -f -c git -n '__fish_git_using_command branch' -s r -l remotes -d 'List or delete (if used with -d) the remote-tracking branches.'
12	12	-> complete -f -c git -n '__fish_git_using_command branch' -s t -l track -l track -d 'Track remote branch'
10	10	-> complete -f -c git -n '__fish_git_using_command branch' -l no-track -d 'Do not track remote branch'
15	15	-> complete -f -c git -n '__fish_git_using_command branch' -l set-upstream-to -d 'Set remote branch to track' -ka '(__fish_git_branches)'
11	11	-> complete -f -c git -n '__fish_git_using_command branch' -l merged -d 'List branches that have been merged'
10	10	-> complete -f -c git -n '__fish_git_using_command branch' -l no-merged -d 'List branches that have not been merged'
11	11	-> complete -f -c git -n '__fish_git_using_command branch' -l unset-upstream -d 'Remove branch upstream information'
15	15	-> complete -f -c git -n '__fish_git_using_command branch' -l contains -d 'List branches that contain the specified commit' -xa '(__fish_git_commits)'
15	15	-> complete -f -c git -n '__fish_git_using_command branch' -l no-contains -d 'List branches that don\'t contain the specified commit' -xa '(__fish_git_commits)'
9	9	-> set -l bundlecommands create verify list-heads unbundle
10	10	-> complete -f -c git -n __fish_git_needs_command -a bundle -d 'Create, unpack, and manipulate "bundle" files'
31	31	-> complete -f -c git -n "__fish_git_using_command bundle" -n "not __fish_seen_subcommand_from $bundlecommands" -a "create\t'Create a bundle'
verify\t'Check that the bundle is valid and will apply cleanly'
list-heads\t'List the references defined in the bundle'
unbundle\t'Build a pack index file and print all defined references'"
17	17	-> complete -f -c git -n "__fish_git_using_command bundle" -n "__fish_seen_subcommand_from create verify" -s q -l quiet -d 'Do not show progress meter'
15	15	-> complete -f -c git -n "__fish_git_using_command bundle" -n "__fish_seen_subcommand_from create unbundle" -l progress -d 'Show progress meter'
14	14	-> complete -f -c git -n "__fish_git_using_command bundle" -n "__fish_seen_subcommand_from create" -l all-progress -d 'Show progress meter during object writing phase'
15	15	-> complete -f -c git -n "__fish_git_using_command bundle" -n "__fish_seen_subcommand_from create" -l all-progress-implied -d 'Similar to --all-progress when progress meter is shown'
15	15	-> complete -x -c git -n "__fish_git_using_command bundle" -n "__fish_seen_subcommand_from create" -l version -d 'Specify bundle format version'
17	17	-> complete -c git -n '__fish_git_using_command bundle' -n "__fish_seen_subcommand_from create" -ka '--all\t"All refs"'
16	16	-> complete -c git -n '__fish_git_using_command bundle' -n "__fish_seen_subcommand_from create" -ka '(__fish_git_ranges)'
10	10	-> complete -f -c git -n __fish_git_needs_command -a cherry -d 'Find commits yet to be applied to upstream'
10	10	-> complete -f -c git -n '__fish_git_using_command cherry' -s v -d 'Show the commit subjects next to the SHA1s'
13	13	-> complete -f -c git -n '__fish_git_using_command cherry' -ka '(__fish_git_refs)' -d Upstream
10	10	-> complete -f -c git -n __fish_git_needs_command -a cherry-pick -d 'Reapply a commit on another branch'
13	13	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -ka '(__fish_git_ranges)'
15	15	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -n __fish_git_possible_commithash -ka '(__fish_git_commits)'
12	12	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -s e -l edit -d 'Edit the commit message prior to committing'
11	11	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -s x -d 'Append info in generated commit on the origin of the cherry-picked change'
13	13	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -s n -l no-commit -d 'Apply changes without making any commit'
12	12	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -s s -l signoff -d 'Add Signed-off-by line to the commit message'
10	10	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -l ff -d 'Fast-forward if possible'
12	12	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -l continue -d 'Continue the operation in progress'
10	10	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -l abort -d 'Cancel the operation'
11	11	-> complete -f -c git -n '__fish_git_using_command cherry-pick' -l skip -d 'Skip the current commit and continue with the rest of the sequence'
10	10	-> complete -f -c git -n __fish_git_needs_command -a clone -d 'Clone a repository into a new directory'
10	10	-> complete -f -c git -n '__fish_git_using_command clone' -l no-hardlinks -d 'Copy files instead of using hardlinks'
11	11	-> complete -f -c git -n '__fish_git_using_command clone' -s q -l quiet -d 'Operate quietly and do not report progress'
11	11	-> complete -f -c git -n '__fish_git_using_command clone' -s v -l verbose -d 'Provide more information on what is going on'
14	14	-> complete -f -c git -n '__fish_git_using_command clone' -s n -l no-checkout -d 'No checkout of HEAD is performed after the clone is complete'
11	11	-> complete -f -c git -n '__fish_git_using_command clone' -l bare -d 'Make a bare Git repository'
13	13	-> complete -f -c git -n '__fish_git_using_command clone' -l mirror -d 'Set up a mirror of the source repository'
12	12	-> complete -f -c git -n '__fish_git_using_command clone' -s o -l origin -d 'Use a specific name of the remote instead of the default'
15	15	-> complete -f -c git -n '__fish_git_using_command clone' -s b -l branch -d 'Use a specific branch instead of the one used by the cloned repository'
11	11	-> complete -f -c git -n '__fish_git_using_command clone' -l depth -d 'Truncate the history to a specified number of revisions'
11	11	-> complete -f -c git -n '__fish_git_using_command clone' -l recursive -d 'Initialize all submodules within the cloned repository'
10	10	-> complete -c git -n __fish_git_needs_command -a commit -d 'Record changes to the repository'
11	11	-> complete -c git -n '__fish_git_using_command commit' -l amend -d 'Amend the log message of the last commit'
18	18	-> complete -f -c git -n '__fish_git_using_command commit' -a '(__fish_git_files modified deleted modified-staged-deleted untracked)'
11	11	-> complete -c git -n '__fish_git_using_command commit' -s a -l all -d 'Automatically stage modified and deleted files'
14	14	-> complete -c git -n '__fish_git_using_command commit' -s p -l patch -d 'Use interactive patch selection interface'
10	10	-> complete -f -c git -n '__fish_git_using_command commit' -l fixup -d 'Fixup commit to be used with rebase --autosquash'
10	10	-> complete -f -c git -n '__fish_git_using_command commit' -l squash -d 'Squash commit to be used with rebase --autosquash'
10	10	-> complete -c git -n '__fish_git_using_command commit' -l reset-author -d 'When amending, reset author of commit to the committer'
10	10	-> complete -x -c git -n '__fish_git_using_command commit' -l author -d 'Override the commit author'
24	24	-> complete -x -c git -n '__fish_git_using_command commit' -l cleanup -a "strip\t'Leading/trailing whitespace/empty lines, #commentary'
 whitespace\t'Like strip but keep #commentary'
 verbatim\t'Do not change the message'
 scissors\t'Like whitespace but also remove after scissor lines'
 default\t'Like strip if the message is to be edited, whitespace otherwise'" -d 'How to clean up the commit message'
10	10	-> complete -x -c git -n '__fish_git_using_command commit' -l date -d 'Override the author date'
11	11	-> complete -x -c git -n '__fish_git_using_command commit' -s m -l message -d 'Use the given message as the commit message'
13	13	-> complete -f -c git -n '__fish_git_using_command commit' -l no-edit -d 'Use the selected commit message without launching an editor'
12	12	-> complete -f -c git -n '__fish_git_using_command commit' -l no-gpg-sign -d 'Do not sign commit'
11	11	-> complete -f -c git -n '__fish_git_using_command commit' -s n -l no-verify -d 'Do not run pre-commit and commit-msg hooks'
17	17	-> complete -f -c git -n '__fish_git_using_command commit' -n '__fish_git_contains_opt fixup squash' -ka '(__fish_git_recent_commits)'
11	11	-> complete -f -c git -n '__fish_git_using_command commit' -l allow-empty -d 'Create a commit with no changes'
10	10	-> complete -f -c git -n '__fish_git_using_command commit' -l allow-empty-message -d 'Create a commit with no commit message'
12	12	-> complete -f -c git -n '__fish_git_using_command commit' -s s -l signoff -d 'Append Signed-off-by trailer to commit message'
10	10	-> complete -f -c git -n '__fish_git_using_command commit' -l no-signoff -d 'Do not append Signed-off-by trailer to commit message'
10	10	-> complete -f -c git -n __fish_git_needs_command -a count-objects -d 'Count number of objects and disk consumption'
11	11	-> complete -f -c git -n '__fish_git_using_command count-objects' -s v -l verbose -d 'Be verbose'
13	13	-> complete -f -c git -n '__fish_git_using_command count-objects' -s H -l human-readable -d 'Print in human readable format'
10	10	-> complete -c git -n __fish_git_needs_command -a daemon -d 'A simple server for git repositories'
10	10	-> complete -f -c git -n '__fish_git_using_command daemon' -l strict-paths -d 'Match paths exactly'
10	10	-> complete -F -c git -n '__fish_git_using_command daemon' -l base-path -d 'Git Root'
12	12	-> complete -f -c git -n '__fish_git_using_command daemon' -l base-path-relaxed -d 'When looking up with base path fails, try without it'
11	11	-> complete -F -c git -n '__fish_git_using_command daemon' -l interpolated-path -d 'Construct a path from the given template'
10	10	-> complete -f -c git -n '__fish_git_using_command daemon' -l export-all -d 'Allow pulling from all directories'
10	10	-> complete -f -c git -n '__fish_git_using_command daemon' -l inetd -d 'Run as inetd service'
10	10	-> complete -x -c git -n '__fish_git_using_command daemon' -l listen -d 'Listen on this IP'
9	9	-> complete -x -c git -n '__fish_git_using_command daemon' -l port -d 'Listen on this port'
10	10	-> complete -x -c git -n '__fish_git_using_command daemon' -l init-timeout -d 'Connection timeout'
10	10	-> complete -x -c git -n '__fish_git_using_command daemon' -l timeout -d 'Timeout for each request'
11	11	-> complete -x -c git -n '__fish_git_using_command daemon' -l max-connections -d 'Maximum parallel clients'
11	11	-> complete -f -c git -n '__fish_git_using_command daemon' -l syslog -d '--log-destination=syslog'
14	14	-> complete -x -c git -n '__fish_git_using_command daemon' -l log-destination -a 'stderr syslog none' -d 'Log destination'
12	12	-> complete -x -c git -n '__fish_git_using_command daemon' -l user-path -d 'Allow ~user notation to be used'
10	10	-> complete -f -c git -n '__fish_git_using_command daemon' -l verbose -d 'Log all details'
10	10	-> complete -f -c git -n '__fish_git_using_command daemon' -l reuseaddr -d 'Reuse address when binding to listening server'
10	10	-> complete -f -c git -n '__fish_git_using_command daemon' -l detach -d 'Detach from shell'
10	10	-> complete -x -c git -n '__fish_git_using_command daemon' -l reuseaddr -d 'Save the process id in file'
10	10	-> complete -x -c git -n '__fish_git_using_command daemon' -l user -d 'Change daemon\'s uid'
10	10	-> complete -x -c git -n '__fish_git_using_command daemon' -l group -d 'Change daemon\'s gid'
16	16	-> complete -x -c git -n '__fish_git_using_command daemon' -l enable -a 'upload-pack upload-archive receive-pack' -d 'Enable service'
15	15	-> complete -x -c git -n '__fish_git_using_command daemon' -l disable -a 'upload-pack upload-archive receive-pack' -d 'Disable service'
16	16	-> complete -x -c git -n '__fish_git_using_command daemon' -l allow-override -a 'upload-pack upload-archive receive-pack' -d 'Allow overriding site-wide default per repository configuration'
16	16	-> complete -x -c git -n '__fish_git_using_command daemon' -l forbid-override -a 'upload-pack upload-archive receive-pack' -d 'Forbid overriding site-wide default per repository configuration'
11	11	-> complete -f -c git -n '__fish_git_using_command daemon' -l informative-errors -d 'Report more verbose errors to clients'
10	10	-> complete -f -c git -n '__fish_git_using_command daemon' -l no-informative-errors -d 'Report less verbose errors to clients'
10	10	-> complete -x -c git -n '__fish_git_using_command daemon' -l access-hook -d 'Hook to run whenever a client connects'
12	12	-> complete -c git -n __fish_git_needs_command -a describe -d 'Give an object a human readable name'
17	17	-> complete -f -c git -n '__fish_git_using_command describe' -ka '(__fish_git_tags)' -d Tag
13	13	-> complete -f -c git -n '__fish_git_using_command describe' -ka '(__fish_git_branches)'
12	12	-> complete -f -c git -n '__fish_git_using_command describe' -ka '(__fish_git_heads)' -d Head
11	11	-> complete -f -c git -n '__fish_git_using_command describe' -l dirty -d 'Describe the state of the working tree, append dirty if there are local changes'
12	12	-> complete -f -c git -n '__fish_git_using_command describe' -l broken -d 'Describe the state of the working tree, append -broken instead of erroring'
10	10	-> complete -f -c git -n '__fish_git_using_command describe' -l all -d 'Use all tags, not just annotated'
10	10	-> complete -f -c git -n '__fish_git_using_command describe' -l tags -d 'Use all commits/tags, not just annotated tags'
10	10	-> complete -f -c git -n '__fish_git_using_command describe' -l contains -d 'Find the tag that comes after the commit'
12	12	-> complete -f -c git -n '__fish_git_using_command describe' -l abbrev -d 'Use <n> digits, or as many digits as needed to form a unique object name'
10	10	-> complete -f -c git -n '__fish_git_using_command describe' -l candidates -d 'Consider up to <n> candidates'
10	10	-> complete -f -c git -n '__fish_git_using_command describe' -l exact-match -d 'Only output exact matches'
10	10	-> complete -f -c git -n '__fish_git_using_command describe' -l debug -d 'Display debug info'
10	10	-> complete -f -c git -n '__fish_git_using_command describe' -l long -d 'Always output the long format'
11	11	-> complete -f -c git -n '__fish_git_using_command describe' -l match -d 'Only consider tags matching the given glob pattern'
10	10	-> complete -f -c git -n '__fish_git_using_command describe' -l exclude -d 'Do not consider tags matching the given glob pattern'
10	10	-> complete -f -c git -n '__fish_git_using_command describe' -l always -d 'Show uniquely abbreviated commit object as fallback'
11	11	-> complete -f -c git -n '__fish_git_using_command describe' -l first-parent -d 'Follow only the first parent of a merge commit'
10	10	-> complete -c git -n __fish_git_needs_command -a diff -d 'Show changes between commits and working tree'
22	22	-> complete -c git -n '__fish_git_using_command diff' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_ranges)'
23	23	-> complete -c git -n '__fish_git_using_command diff' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_complete_stashes)'
10	10	-> complete -c git -n '__fish_git_using_command diff' -l cached -d 'Show diff of changes in the index'
10	10	-> complete -c git -n '__fish_git_using_command diff' -l staged -d 'Show diff of changes in the index'
10	10	-> complete -c git -n '__fish_git_using_command diff' -l no-index -d 'Compare two paths on the filesystem'
11	11	-> complete -c git -n '__fish_git_using_command diff' -l exit-code -d 'Exit with 1 if there were differences or 0 if no differences'
10	10	-> complete -c git -n '__fish_git_using_command diff' -l quiet -d 'Disable all output of the program, implies --exit-code'
37	37	-> complete -c git -n '__fish_git_using_command diff' -s 1 -l base -d 'Compare the working tree with the "base" version'
11	11	-> complete -c git -n '__fish_git_using_command diff' -s 2 -l ours -d 'Compare the working tree with the "our branch"'
12	12	-> complete -c git -n '__fish_git_using_command diff' -s 3 -l theirs -d 'Compare the working tree with the "their branch"'
11	11	-> complete -c git -n '__fish_git_using_command diff' -s 0 -d 'Omit diff output for unmerged entries and just show "Unmerged"'
42	42	-> complete -c git -n '__fish_git_using_command diff' -n 'not __fish_git_contains_opt cached staged' -a '(
    set -l kinds modified
    contains -- -- (commandline -opc) && set -a kinds deleted modified-staged-deleted
    __fish_git_files $kinds
)'
19	19	-> complete -c git -n '__fish_git_using_command diff' -n '__fish_git_contains_opt cached staged' -fa '(__fish_git_files all-staged)'
3	3	-> function __fish_git_diffmerge_tools -a cmd...
10	10	-> complete -c git -n __fish_git_needs_command -a difftool -d 'Open diffs in a visual tool'
22	22	-> complete -c git -n '__fish_git_using_command difftool' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_ranges)'
13	13	-> complete -c git -n '__fish_git_using_command difftool' -l cached -d 'Visually show diff of changes in the index'
32	32	-> complete -f -c git -n '__fish_git_using_command difftool' -a '(
    set -l kinds modified
    contains -- -- (commandline -opc) && set -a kinds deleted modified-staged-deleted
    __fish_git_files $kinds
)'
12	12	-> complete -f -c git -n '__fish_git_using_command difftool' -s g -l gui -d 'Use `diff.guitool` instead of `diff.tool`'
11	11	-> complete -f -c git -n '__fish_git_using_command difftool' -s d -l dir-diff -d 'Perform a full-directory diff'
10	10	-> complete -c git -n '__fish_git_using_command difftool' -l prompt -d 'Prompt before each invocation of the diff tool'
12	12	-> complete -f -c git -n '__fish_git_using_command difftool' -s y -l no-prompt -d 'Do not prompt before launching a diff tool'
10	10	-> complete -f -c git -n '__fish_git_using_command difftool' -l symlinks -d 'Use symlinks in dir-diff mode'
16	16	-> complete -f -c git -n '__fish_git_using_command difftool' -s t -l tool -d 'Use the specified diff tool' -a "(__fish_git_diffmerge_tools difftool)"
10	10	-> complete -f -c git -n '__fish_git_using_command difftool' -l tool-help -d 'Print a list of diff tools that may be used with `--tool`'
13	13	-> complete -f -c git -n '__fish_git_using_command difftool' -l trust-exit-code -d 'Exit when an invoked diff tool returns a non-zero exit code'
13	13	-> complete -f -c git -n '__fish_git_using_command difftool' -s x -l extcmd -d 'Specify a custom command for viewing diffs'
10	10	-> complete -f -c git -n '__fish_git_using_command difftool' -l no-gui -d 'Overrides --gui setting'
9	9	-> complete -f -c git -n __fish_git_needs_command -a gc -d 'Collect garbage (unreachable commits etc)'
10	10	-> complete -f -c git -n '__fish_git_using_command gc' -l aggressive -d 'Aggressively optimize the repository'
10	10	-> complete -f -c git -n '__fish_git_using_command gc' -l auto -d 'Checks any housekeeping is required and then run'
10	10	-> complete -f -c git -n '__fish_git_using_command gc' -l prune -d 'Prune loose objects older than date'
9	9	-> complete -f -c git -n '__fish_git_using_command gc' -l no-prune -d 'Do not prune any loose objects'
9	9	-> complete -f -c git -n '__fish_git_using_command gc' -l quiet -d 'Be quiet'
10	10	-> complete -f -c git -n '__fish_git_using_command gc' -l force -d 'Force `git gc` to run'
10	10	-> complete -f -c git -n '__fish_git_using_command gc' -l keep-largest-pack -d 'Ignore `gc.bigPackThreshold`'
9	9	-> complete -c git -n __fish_git_needs_command -a grep -d 'Print lines matching a pattern'
10	10	-> complete -f -c git -n '__fish_git_using_command grep' -l cached -d 'Search blobs registered in the index file'
10	10	-> complete -f -c git -n '__fish_git_using_command grep' -l no-index -d 'Search files in the current directory not managed by Git'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -l untracked -d 'Search also in untracked files'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -l no-exclude-standard -d 'Also search in ignored files by not honoring the .gitignore mechanism'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -l exclude-standard -d 'Do not search ignored files specified via the .gitignore mechanism'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -l recurse-submodules -d 'Recursively search in each submodule that is active and checked out in the repository'
16	16	-> complete -f -c git -n '__fish_git_using_command grep' -s a -l text -d 'Process binary files as if they were text'
10	10	-> complete -f -c git -n '__fish_git_using_command grep' -l textconv -d 'Honor textconv filter settings'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -l no-textconv -d 'Do not honor textconv filter settings'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -s i -l ignore-case -d 'Ignore case differences between the patterns and the files'
9	9	-> complete -f -c git -n '__fish_git_using_command grep' -s I -d 'Don\'t match the pattern in binary files'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -s r -l recursive -d 'Descend into levels of directories endlessly'
10	10	-> complete -f -c git -n '__fish_git_using_command grep' -l no-recursive -d 'Do not descend into directories'
12	12	-> complete -f -c git -n '__fish_git_using_command grep' -s w -l word-regexp -d 'Match the pattern only at word boundary'
10	10	-> complete -f -c git -n '__fish_git_using_command grep' -s v -l invert-match -d 'Select non-matching lines'
10	10	-> complete -f -c git -n '__fish_git_using_command grep' -l full-name -d 'Forces paths to be output relative to the project top directory'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -s E -l extended-regexp -d 'Use POSIX extended regexp for patterns'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -s G -l basic-regexp -d 'Use POSIX basic regexp for patterns'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -s P -l perl-regexp -d 'Use Perl-compatible regular expressions for patterns'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -s F -l fixed-strings -d 'Don\'t interpret pattern as a regex'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -s n -l line-number -d 'Prefix the line number to matching lines'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -l column -d 'Prefix the 1-indexed byte-offset of the first match from the start of the matching line'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -s l -l files-with-matches -d 'Show only the names of files that contain matches'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -s L -l files-without-match -d 'Show only the names of files that do not contain matches'
12	12	-> complete -f -c git -n '__fish_git_using_command grep' -s z -l null -d 'Use \\0 as the delimiter for pathnames in the output, and print them verbatim'
13	13	-> complete -f -c git -n '__fish_git_using_command grep' -s o -l only-matching -d 'Print only the matched parts of a matching line'
14	14	-> complete -f -c git -n '__fish_git_using_command grep' -s c -l count -d 'Instead of showing every matched line, show the number of lines that match'
12	12	-> complete -f -c git -n '__fish_git_using_command grep' -l no-color -d 'Turn off match highlighting, even when the configuration file gives the default to color output'
12	12	-> complete -f -c git -n '__fish_git_using_command grep' -l break -d 'Print an empty line between matches from different files'
11	11	-> complete -f -c git -n '__fish_git_using_command grep' -l heading -d 'Show the filename above the matches in that file instead of at the start of each shown line'
12	12	-> complete -f -c git -n '__fish_git_using_command grep' -s p -l show-function -d 'Show the line that contains the function name of the match, unless the match is a function name itself'
12	12	-> complete -f -c git -n '__fish_git_using_command grep' -s W -l function-context -d 'Show the surrounding text from the line containing a function name up to the one before the next function name'
10	10	-> complete -f -c git -n '__fish_git_using_command grep' -s e -d 'The next parameter is the pattern'
10	10	-> complete -f -c git -n '__fish_git_using_command grep' -l and -d 'Combine patterns using and'
10	10	-> complete -f -c git -n '__fish_git_using_command grep' -l or -d 'Combine patterns using or'
9	9	-> complete -f -c git -n '__fish_git_using_command grep' -l not -d 'Combine patterns using not'
12	12	-> complete -f -c git -n '__fish_git_using_command grep' -l all-match -d 'Only match files that can match all the pattern expressions when giving multiple'
12	12	-> complete -f -c git -n '__fish_git_using_command grep' -s q -l quiet -d 'Just exit with status 0 when there is a match and with non-zero status when there isn\'t'
22	22	-> complete -c git -n '__fish_git_using_command grep' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_refs)'
9	9	-> complete -f -c git -n __fish_git_needs_command -a init -d 'Create an empty git repository'
11	11	-> complete -f -c git -n '__fish_git_using_command init' -s q -l quiet -d 'Only print error and warning messages'
10	10	-> complete -f -c git -n '__fish_git_using_command init' -l bare -d 'Create a bare repository'
12	12	-> complete -c git -n __fish_git_needs_command -a shortlog -d 'Show commit shortlog'
9	9	-> complete -c git -n __fish_git_needs_command -a log -d 'Show commit logs'
13	13	-> complete -c git -n '__fish_git_using_command log' -a '(__fish_git ls-files)'
19	19	-> complete -c git -n '__fish_git_using_command log' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_ranges)'
10	10	-> complete -c git -n '__fish_git_using_command log' -l follow -d 'Continue listing file history beyond renames'
10	10	-> complete -c git -n '__fish_git_using_command log' -l no-decorate -d 'Don\'t print ref names'
21	21	-> complete -f -c git -n '__fish_git_using_command log' -l decorate -a 'short\tHide\ prefixes full\tShow\ full\ ref\ names auto\tHide\ prefixes\ if\ printed\ to\ terminal no\tDon\\\'t\ display\ ref' -d 'Print out ref names'
10	10	-> complete -c git -n '__fish_git_using_command log' -l source -d 'Print ref name by which each commit was reached'
11	11	-> complete -c git -n '__fish_git_using_command log' -l use-mailmap
9	9	-> complete -c git -n '__fish_git_using_command log' -l full-diff
8	8	-> complete -c git -n '__fish_git_using_command log' -l log-size
9	9	-> complete -x -c git -n '__fish_git_using_command log' -s L
12	12	-> complete -x -c git -n '__fish_git_using_command log' -s n -l max-count -d 'Limit the number of commits before starting to show the commit output'
10	10	-> complete -x -c git -n '__fish_git_using_command log' -l skip -d 'Skip given number of commits'
10	10	-> complete -x -c git -n '__fish_git_using_command log' -l since -d 'Show commits more recent than specified date'
10	10	-> complete -x -c git -n '__fish_git_using_command log' -l after -d 'Show commits more recent than specified date'
10	10	-> complete -x -c git -n '__fish_git_using_command log' -l until -d 'Show commits older than specified date'
10	10	-> complete -x -c git -n '__fish_git_using_command log' -l before -d 'Show commits older than specified date'
10	10	-> complete -x -c git -n '__fish_git_using_command log' -l author -d 'Limit commits from given author'
11	11	-> complete -x -c git -n '__fish_git_using_command log' -l committer -d 'Limit commits from given committer'
11	11	-> complete -x -c git -n '__fish_git_using_command log' -l grep-reflog -d 'Limit commits to ones with reflog entries matching given pattern'
10	10	-> complete -x -c git -n '__fish_git_using_command log' -l grep -d 'Limit commits with message that match given pattern'
9	9	-> complete -c git -n '__fish_git_using_command log' -l all-match -d 'Limit commits to ones that match all given --grep'
61	61	-> complete -c git -n '__fish_git_using_command log' -l invert-grep -d 'Limit commits to ones with message that don\'t match --grep'
41	41	-> complete -c git -n '__fish_git_using_command log' -l regexp-ignore-case -s i -d 'Case insensitive match'
12	12	-> complete -c git -n '__fish_git_using_command log' -l basic-regexp -d 'Patterns are basic regular expressions (default)'
11	11	-> complete -c git -n '__fish_git_using_command log' -l extended-regexp -s E -d 'Patterns are extended regular expressions'
11	11	-> complete -c git -n '__fish_git_using_command log' -l fixed-strings -s F -d 'Patterns are fixed strings'
10	10	-> complete -c git -n '__fish_git_using_command log' -l perl-regexp -d 'Patterns are Perl-compatible regular expressions'
24	24	-> complete -c git -n '__fish_git_using_command log' -l remove-empty -d 'Stop when given path disappears from tree'
34	34	-> complete -c git -n '__fish_git_using_command log' -l merges -d 'Print only merge commits'
13	13	-> complete -c git -n '__fish_git_using_command log' -l no-merges -d 'Don\'t print commits with more than one parent'
12	12	-> complete -x -c git -n '__fish_git_using_command log' -l min-parents -d 'Show only commit with at least the given number of parents'
11	11	-> complete -x -c git -n '__fish_git_using_command log' -l max-parents -d 'Show only commit with at most the given number of parents'
10	10	-> complete -c git -n '__fish_git_using_command log' -l no-min-parents -d 'Show only commit without a minimum number of parents'
10	10	-> complete -c git -n '__fish_git_using_command log' -l no-max-parents -d 'Show only commit without a maximum number of parents'
35	35	-> complete -c git -n '__fish_git_using_command log' -l first-parent -d 'Follow only the first parent commit upon seeing a merge commit'
20	20	-> complete -c git -n '__fish_git_using_command log' -l not -d 'Reverse meaning of ^ prefix'
10	10	-> complete -c git -n '__fish_git_using_command log' -l all -d 'Show log for all branches, tags, and remotes'
12	12	-> complete -f -c git -n '__fish_git_using_command log' -l branches -d 'Show log for all matching branches'
10	10	-> complete -f -c git -n '__fish_git_using_command log' -l tags -d 'Show log for all matching tags'
10	10	-> complete -f -c git -n '__fish_git_using_command log' -l remotes -d 'Show log for all matching remotes'
10	10	-> complete -x -c git -n '__fish_git_using_command log' -l glob -d 'Show log for all matching branches, tags, and remotes'
11	11	-> complete -x -c git -n '__fish_git_using_command log' -l exclude -d 'Do not include refs matching given glob pattern'
10	10	-> complete -c git -n '__fish_git_using_command log' -l reflog -d 'Show log for all reflogs entries'
10	10	-> complete -c git -n '__fish_git_using_command log' -l ingnore-missing -d 'Ignore invalid object names'
9	9	-> complete -c git -n '__fish_git_using_command log' -l bisect
9	9	-> complete -c git -n '__fish_git_using_command log' -l stdin -d 'Read commits from stdin'
10	10	-> complete -c git -n '__fish_git_using_command log' -l cherry-mark -d 'Mark equivalent commits with = and inequivalent with +'
11	11	-> complete -c git -n '__fish_git_using_command log' -l cherry-pick -d 'Omit equivalent commits'
9	9	-> complete -c git -n '__fish_git_using_command log' -l left-only
9	9	-> complete -c git -n '__fish_git_using_command log' -l right-only
8	8	-> complete -c git -n '__fish_git_using_command log' -l cherry
38	38	-> complete -c git -n '__fish_git_using_command log' -l walk-reflogs -s g
33	33	-> complete -c git -n '__fish_git_using_command log' -l merge
14	14	-> complete -c git -n '__fish_git_using_command log' -l boundary
14	14	-> complete -c git -n '__fish_git_using_command log' -l simplify-by-decoration
10	10	-> complete -c git -n '__fish_git_using_command log' -l full-history
10	10	-> complete -c git -n '__fish_git_using_command log' -l dense
8	8	-> complete -c git -n '__fish_git_using_command log' -l sparse
9	9	-> complete -c git -n '__fish_git_using_command log' -l simplify-merges
9	9	-> complete -c git -n '__fish_git_using_command log' -l ancestry-path
9	9	-> complete -c git -n '__fish_git_using_command log' -l date-order
9	9	-> complete -c git -n '__fish_git_using_command log' -l author-date-order
9	9	-> complete -c git -n '__fish_git_using_command log' -l topo-order
8	8	-> complete -c git -n '__fish_git_using_command log' -l reverse
14	14	-> complete -f -c git -n '__fish_git_using_command log' -l no-walk -a "sorted unsorted"
9	9	-> complete -c git -n '__fish_git_using_command log' -l do-walk
8	8	-> complete -c git -n '__fish_git_using_command log' -l format
8	8	-> complete -c git -n '__fish_git_using_command log' -l abbrev-commit
8	8	-> complete -c git -n '__fish_git_using_command log' -l no-abbrev-commit
8	8	-> complete -c git -n '__fish_git_using_command log' -l oneline
15	15	-> complete -x -c git -n '__fish_git_using_command log' -l encoding -a '(__fish_print_encodings)'
10	10	-> complete -f -c git -n '__fish_git_using_command log' -l expand-tabs
9	9	-> complete -c git -n '__fish_git_using_command log' -l no-expand-tabs
9	9	-> complete -f -c git -n '__fish_git_using_command log' -l notes
8	8	-> complete -c git -n '__fish_git_using_command log' -l no-notes
8	8	-> complete -f -c git -n '__fish_git_using_command log' -l show-notes
8	8	-> complete -c git -n '__fish_git_using_command log' -l standard-notes
9	9	-> complete -c git -n '__fish_git_using_command log' -l no-standard-notes
8	8	-> complete -c git -n '__fish_git_using_command log' -l show-signature
8	8	-> complete -c git -n '__fish_git_using_command log' -l relative-date
36	36	-> complete -x -c git -n '__fish_git_using_command log' -l date -a '
  relative
  local
  iso
  iso-local
  iso8601
  iso8601-local
  iso-strict
  iso-strict-local
  iso8601-strict
  iso8601-strict-local
  rfc-local
  rfc2822-local
  short
  short-local
  raw
  human
  unix
  format:
  default
  default-local
'
9	9	-> complete -c git -n '__fish_git_using_command log' -l parents
10	10	-> complete -c git -n '__fish_git_using_command log' -l children
8	8	-> complete -c git -n '__fish_git_using_command log' -l left-right
9	9	-> complete -c git -n '__fish_git_using_command log' -l graph
8	8	-> complete -f -c git -n '__fish_git_using_command log' -l show-linear-break
9	9	-> complete -c git -n '__fish_git_using_command log' -s c
8	8	-> complete -c git -n '__fish_git_using_command log' -l cc
8	8	-> complete -c git -n '__fish_git_using_command log' -s m
8	8	-> complete -c git -n '__fish_git_using_command log' -s r
8	8	-> complete -c git -n '__fish_git_using_command log' -s t
10	10	-> complete -c git -n '__fish_git_using_command log' -l patch -s p
9	9	-> complete -c git -n '__fish_git_using_command log' -s u
10	10	-> complete -c git -n '__fish_git_using_command log' -l no-patch -s s
10	10	-> complete -x -c git -n '__fish_git_using_command log' -l unified -s U
9	9	-> complete -c git -n '__fish_git_using_command log' -l raw
9	9	-> complete -c git -n '__fish_git_using_command log' -l patch-with-raw
9	9	-> complete -c git -n '__fish_git_using_command log' -l indent-heuristic
8	8	-> complete -c git -n '__fish_git_using_command log' -l no-indent-heuristic
9	9	-> complete -c git -n '__fish_git_using_command log' -l compaction-heuristic
9	9	-> complete -c git -n '__fish_git_using_command log' -l no-compaction-heuristic
8	8	-> complete -c git -n '__fish_git_using_command log' -l minimal
11	11	-> complete -c git -n '__fish_git_using_command log' -l patience
8	8	-> complete -c git -n '__fish_git_using_command log' -l histogram
9	9	-> complete -f -x -c git -n '__fish_git_using_command log' -l stat
8	8	-> complete -c git -n '__fish_git_using_command log' -l numstat
9	9	-> complete -c git -n '__fish_git_using_command log' -l shortstat
8	8	-> complete -c git -n '__fish_git_using_command log' -l summary
8	8	-> complete -c git -n '__fish_git_using_command log' -l patch-with-stat
8	8	-> complete -c git -n '__fish_git_using_command log' -s z
8	8	-> complete -c git -n '__fish_git_using_command log' -l name-only
10	10	-> complete -c git -n '__fish_git_using_command log' -l name-status
13	13	-> complete -f -c git -n '__fish_git_using_command log' -l color -a 'always never auto'
9	9	-> complete -c git -n '__fish_git_using_command log' -l no-color
13	13	-> complete -f -c git -n '__fish_git_using_command log' -l word-diff -a '
  color
  plain
  porcelain
  none
'
9	9	-> complete -f -c git -n '__fish_git_using_command log' -l color-words
9	9	-> complete -c git -n '__fish_git_using_command log' -l no-renames
8	8	-> complete -c git -n '__fish_git_using_command log' -l check
9	9	-> complete -c git -n '__fish_git_using_command log' -l full-index
9	9	-> complete -c git -n '__fish_git_using_command log' -l binary
8	8	-> complete -f -c git -n '__fish_git_using_command log' -l abbrev
9	9	-> complete -f -c git -n '__fish_git_using_command log' -s l
3	3	-> function __fish__git_append_letters_nosep...
37	37	-> complete -x -c git -n '__fish_git_using_command log' -l diff-filter -a '(__fish__git_append_letters_nosep a\tExclude\ added c\tExclude\ copied d\tExclude\ deleted m\tExclude\ modified r\tExclude\ renamed t\tExclude\ type\ changed u\tExclude\ unmerged x\tExclude\ unknown b\tExclude\ broken A\tAdded C\tCopied D\tDeleted M\tModified R\tRenamed T\tType\ Changed U\tUnmerged X\tUnknown B\tBroken)'
11	11	-> complete -c git -n __fish_git_needs_command -a ls-files -d 'Show information about files'
9	9	-> complete -c git -n '__fish_git_using_command ls-files'
12	12	-> complete -c git -n '__fish_git_using_command ls-files' -s c -l cached -d 'Show cached files in the output'
13	13	-> complete -c git -n '__fish_git_using_command ls-files' -s d -l deleted -d 'Show deleted files in the output'
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -s m -l modified -d 'Show modified files in the output'
12	12	-> complete -c git -n '__fish_git_using_command ls-files' -s o -l others -d 'Show other (i.e. untracked) files in the output'
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -s i -l ignored -d 'Show only ignored files in the output'
16	16	-> complete -c git -n '__fish_git_using_command ls-files' -s s -l stage -d "Show staged contents' mode bits, object name and stage number in the output"
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -l directory -d 'If a whole directory is classified as "other", show just its name'
10	10	-> complete -c git -n '__fish_git_using_command ls-files' -l no-empty-directory -d 'Do not list empty directories'
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -s u -l unmerged -d 'Show unmerged files in the output'
14	14	-> complete -c git -n '__fish_git_using_command ls-files' -s k -l killed -d 'Show files on the filesystem that need to be removed for checkout-index to succeed'
10	10	-> complete -c git -n '__fish_git_using_command ls-files' -s z -d 'Use \0 delimiter'
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -s x -l exclude -d 'Skip untracked files matching pattern'
12	12	-> complete -c git -n '__fish_git_using_command ls-files' -s X -l exclude-from -d 'Read exclude patterns from <file>; 1 per line'
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -l exclude-per-directory -d 'Read extra exclude patterns that apply only to the dir and its subdirs in <file>'
10	10	-> complete -c git -n '__fish_git_using_command ls-files' -l exclude-standard -d 'Add the standard Git exclusions'
12	12	-> complete -c git -n '__fish_git_using_command ls-files' -l error-unmatch -d 'If any <file> does not appear in the index, treat this as an error'
9	9	-> complete -c git -n '__fish_git_using_command ls-files' -l with-tree
10	10	-> complete -c git -n '__fish_git_using_command ls-files' -s t -d 'Identifies the file status'
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -s v -d 'Show file status, use lowercase letters for files assumed unchanged'
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -s f -d 'Show file status, use lowercase letters for files marked as fsmonitor valid'
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -l full-name -d 'Force paths to be output relative to the project top directory'
13	13	-> complete -c git -n '__fish_git_using_command ls-files' -l recurse-submodules -d 'Recursively calls ls-files on each submodule in the repository'
10	10	-> complete -c git -n '__fish_git_using_command ls-files' -l abbrev -d 'Show only a partial prefix'
11	11	-> complete -c git -n '__fish_git_using_command ls-files' -l debug -d 'After each line that describes a file, add more data about its cache entry'
10	10	-> complete -c git -n '__fish_git_using_command ls-files' -l eol -d 'Show <eolinfo> and <eolattr> of files'
11	11	-> complete -f -c git -n __fish_git_needs_command -a mailinfo -d 'Extracts patch and authorship from an e-mail'
13	13	-> complete -f -c git -n '__fish_git_using_command mailinfo am' -s k -d 'Do not remove email cruft from subject'
11	11	-> complete -f -c git -n '__fish_git_using_command mailinfo' -s b -d 'Only strip bracket pairs containing \'PATCH\''
11	11	-> complete -f -c git -n '__fish_git_using_command mailinfo am' -s u -d 'Do not reencode author name and email'
10	10	-> complete -x -c git -n '__fish_git_using_command mailinfo' -l encoding -d 'Re-encode to given charset'
11	11	-> complete -f -c git -n '__fish_git_using_command mailinfo' -s n -d 'Disable all charset re-encoding of metadata'
21	21	-> complete -f -c git -n '__fish_git_using_command mailinfo am' -s m -l message-id -d 'Copy message id to the end of commit message'
10	10	-> complete -f -c git -n '__fish_git_using_command mailinfo' -l scissors -d 'Remove everything above scissor line'
10	10	-> complete -f -c git -n '__fish_git_using_command mailinfo' -l no-scissors -d 'Ignore scissor lines'
15	15	-> complete -x -c git -n '__fish_git_using_command mailinfo' -l quoted-cr -a 'nowarn warn strip' -d 'Action when processed email message end with CRLF instead of LF'
10	10	-> complete -c git -n __fish_git_needs_command -a mailsplit -d 'mbox splitter'
11	11	-> complete -F -c git -n '__fish_git_using_command mailsplit' -s o -d 'Directory to place individual messages'
11	11	-> complete -f -c git -n '__fish_git_using_command mailsplit' -s b -d 'Treat files not starting with From line as single mail message'
10	10	-> complete -x -c git -n '__fish_git_using_command mailsplit' -s d -d 'File name prefix digit precision'
10	10	-> complete -x -c git -n '__fish_git_using_command mailsplit' -s f -d 'Skip first n numbers'
11	11	-> complete -f -c git -n '__fish_git_using_command mailsplit am' -l keep-cr -d 'Do not remove \\r from lines starting with \\n\\r'
10	10	-> complete -f -c git -n '__fish_git_using_command mailsplit' -l mboxrd -d 'Input is of mboxrd form'
11	11	-> complete -f -c git -n __fish_git_needs_command -a maintenance -d 'Run tasks to optimize Git repository data'
12	12	-> complete -f -c git -n '__fish_git_using_command maintenance' -a register -d 'Initialize Git config vars for maintenance'
11	11	-> complete -f -c git -n '__fish_git_using_command maintenance' -a run -d 'Run one or more maintenance tasks'
11	11	-> complete -f -c git -n '__fish_git_using_command maintenance' -a start -d 'Start maintenance'
11	11	-> complete -f -c git -n '__fish_git_using_command maintenance' -a stop -d 'Halt background maintenance'
13	13	-> complete -f -c git -n '__fish_git_using_command maintenance' -a unregister -d 'Remove repository from background maintenance'
10	10	-> complete -f -c git -n '__fish_git_using_command maintenance' -l quiet -d 'Supress logs'
18	18	-> complete -x -c git -n '__fish_git_using_command maintenance' -l task -a 'commit-graph prefetch gc loose-objects incremental-repack pack-refs' -d 'Tasks to run'
11	11	-> complete -f -c git -n '__fish_git_using_command maintenance' -l auto -d 'Run maintenance only when necessary'
11	11	-> complete -f -c git -n '__fish_git_using_command maintenance' -l schedule -d 'Run maintenance on certain intervals'
10	10	-> complete -f -c git -n __fish_git_needs_command -a merge -d 'Join multiple development histories'
14	14	-> complete -f -c git -n '__fish_git_using_command merge' -ka '(__fish_git_branches)'
10	10	-> complete -f -c git -n '__fish_git_using_command merge' -l commit -d "Autocommit the merge"
10	10	-> complete -f -c git -n '__fish_git_using_command merge' -l no-commit -d "Don't autocommit the merge"
13	13	-> complete -f -c git -n '__fish_git_using_command merge' -s e -l edit -d 'Edit auto-generated merge message'
11	11	-> complete -f -c git -n '__fish_git_using_command merge' -l no-edit -d "Don't edit auto-generated merge message"
13	13	-> complete -f -c git -n '__fish_git_using_command merge' -l ff -d "Don't generate a merge commit if merge is fast-forward"
10	10	-> complete -f -c git -n '__fish_git_using_command merge' -l no-ff -d "Generate a merge commit even if merge is fast-forward"
10	10	-> complete -f -c git -n '__fish_git_using_command merge' -l ff-only -d 'Refuse to merge unless fast-forward possible'
13	13	-> complete -f -c git -n '__fish_git_using_command merge' -s S -l gpg-sign -d 'GPG-sign the merge commit'
10	10	-> complete -f -c git -n '__fish_git_using_command merge' -l log -d 'Populate the log message with one-line descriptions'
11	11	-> complete -f -c git -n '__fish_git_using_command merge' -l no-log -d "Don't populate the log message with one-line descriptions"
11	11	-> complete -f -c git -n '__fish_git_using_command merge' -l signoff -d 'Add Signed-off-by line at the end of the merge commit message'
11	11	-> complete -f -c git -n '__fish_git_using_command merge' -l no-signoff -d 'Do not add a Signed-off-by line at the end of the merge commit message'
14	14	-> complete -f -c git -n '__fish_git_using_command merge' -l stat -d "Show diffstat of the merge"
12	12	-> complete -f -c git -n '__fish_git_using_command merge' -s n -l no-stat -d "Don't show diffstat of the merge"
13	13	-> complete -f -c git -n '__fish_git_using_command merge' -l squash -d "Squash changes from other branch as a single commit"
11	11	-> complete -f -c git -n '__fish_git_using_command merge' -l no-squash -d "Don't squash changes"
11	11	-> complete -x -c git -n '__fish_git_using_command merge' -s s -l strategy -d 'Use the given merge strategy'
13	13	-> complete -r -c git -n '__fish_git_using_command merge' -s X -l strategy-option -d 'Pass given option to the merge strategy'
11	11	-> complete -f -c git -n '__fish_git_using_command merge' -l verify-signatures -d 'Abort merge if other branch tip commit is not signed with a valid key'
11	11	-> complete -f -c git -n '__fish_git_using_command merge' -l no-verify-signatures -d 'Do not abort merge if other branch tip commit is not signed with a valid key'
11	11	-> complete -f -c git -n '__fish_git_using_command merge' -s q -l quiet -d 'Be quiet'
12	12	-> complete -f -c git -n '__fish_git_using_command merge' -s v -l verbose -d 'Be verbose'
10	10	-> complete -f -c git -n '__fish_git_using_command merge' -l progress -d 'Force progress status'
10	10	-> complete -f -c git -n '__fish_git_using_command merge' -l no-progress -d 'Force no progress status'
11	11	-> complete -f -c git -n '__fish_git_using_command merge' -l allow-unrelated-histories -d 'Allow merging even when branches do not share a common history'
34	34	-> complete -x -c git -n '__fish_git_using_command merge' -s m -d 'Set the commit message'
31	31	-> complete -f -c git -n '__fish_git_using_command merge' -l rerere-autoupdate -d 'If possible, use previous conflict resolutions'
16	16	-> complete -f -c git -n '__fish_git_using_command merge' -l no-rerere-autoupdate -d 'Do not use previous conflict resolutions'
12	12	-> complete -f -c git -n '__fish_git_using_command merge' -l abort -d 'Abort the current conflict resolution process'
43	43	-> complete -f -c git -n '__fish_git_using_command merge' -l continue -d 'Conclude current conflict resolution process'
11	11	-> complete -f -c git -n __fish_git_needs_command -a merge-base -d 'Find a common ancestor for a merge'
12	12	-> complete -f -c git -n '__fish_git_using_command merge-base' -ka '(__fish_git_branches)'
14	14	-> complete -f -c git -n '__fish_git_using_command merge-base' -s a -l all -d 'Output all merge bases for the commits, instead of just one'
10	10	-> complete -f -c git -n '__fish_git_using_command merge-base' -l octopus -d 'Compute the best common ancestors of all supplied commits'
11	11	-> complete -f -c git -n '__fish_git_using_command merge-base' -l independent -d 'Print a minimal subset of the supplied commits with the same ancestors'
10	10	-> complete -f -c git -n '__fish_git_using_command merge-base' -l is-ancestor -d 'Check if the first commit is an ancestor of the second commit'
10	10	-> complete -f -c git -n '__fish_git_using_command merge-base' -l fork-point -d 'Find the point at which a branch forked from another branch ref'
10	10	-> complete -f -c git -n __fish_git_needs_command -a mergetool -d 'Run merge conflict resolution tool'
16	16	-> complete -f -c git -n '__fish_git_using_command mergetool' -s t -l tool -d "Use specific merge resolution program" -a "(__fish_git_diffmerge_tools mergetool)"
10	10	-> complete -f -c git -n '__fish_git_using_command mergetool' -l tool-help -d 'Print a list of merge tools that may be used with `--tool`'
13	13	-> complete -f -c git -n '__fish_git_using_command mergetool' -a "(__fish_git_files unmerged)"
11	11	-> complete -f -c git -n '__fish_git_using_command mergetool' -s y -l no-prompt -d 'Do not prompt before launching a diff tool'
10	10	-> complete -f -c git -n '__fish_git_using_command mergetool' -l prompt -d 'Prompt before each invocation of the merge resolution program'
10	10	-> complete -c git -n '__fish_git_using_command mergetool' -s O -d 'Process files in the order specified in the file passed as argument'
9	9	-> complete -c git -n __fish_git_needs_command -a mv -d 'Move or rename a file'
13	13	-> complete -f -c git -n '__fish_git_using_command mv' -a '(__fish_git ls-files)'
14	14	-> complete -f -c git -n '__fish_git_using_command mv' -s f -l force -d 'Force rename/moving even if target exists'
9	9	-> complete -f -c git -n '__fish_git_using_command mv' -s k -d 'Skip rename/move which can lead to error'
9	9	-> complete -f -c git -n '__fish_git_using_command mv' -s n -l dry-run -d 'Only show what would happen'
10	10	-> complete -f -c git -n '__fish_git_using_command mv' -s v -l verbose -d 'Report names of files as they are changed'
11	11	-> set -l notescommands add copy append edit show merge remove
10	10	-> complete -c git -n __fish_git_needs_command -a notes -d 'Add or inspect object notes'
25	25	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a list -d 'List notes for given object'
19	19	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a add -d 'Add notes for a given object'
18	18	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a copy -d 'Copy notes from object1 to object2'
18	18	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a append -d 'Append to the notes of existing object'
19	19	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a edit -d 'Edit notes for a given object'
18	18	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a show -d 'Show notes for given object'
19	19	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a merge -d 'Merge the given notes ref to current notes ref'
19	19	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a remove -d 'Remove notes for given object'
19	19	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a prune -d 'Remove notes for non-existing/unreachable objects'
18	18	-> complete -f -c git -n "__fish_git_using_command notes" -n "not __fish_seen_subcommand_from $notescommands" -a get-ref -d 'Print current notes ref'
20	20	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from $notescommands" -ka '(__fish_git_commits)'
16	16	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from add copy" -s f -l force -d 'Overwrite existing notes'
15	15	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from add append edit" -l allow-empty -d 'Allow empty note'
14	14	-> complete -r -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from add append" -s F -l file -d 'Read note message from file'
14	14	-> complete -x -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from add append" -s m -l message -d 'Use this note message'
18	18	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from add append" -s C -l reuse-message -a '(__fish_git_commits)' -d 'Copy note from object'
19	19	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from add append" -s c -l reedit-message -a '(__fish_git_commits)' -d 'Copy and edit note from object'
14	14	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from copy remove" -l stdin -d 'Read object names from stdin'
15	15	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from merge remove prune" -s v -l verbose -d 'Be more verbose'
15	15	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from merge remove prune" -s q -l quiet -d 'Operate quietly'
36	36	-> complete -x -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from merge" -s s -l strategy -d 'Merge strategy to use to resolve conflicts' -a "
	manual\t'Instruct the user to resolve merge conflicts'
	ours\t'Resolve conflicts in favour of local version'
	theirs\t'Resolve conflicts in favour of remote version'
	union\t'Resolve conflicts by concatenating local and remote versions'
	cat_sort_uniq\t'Concatenate, sort and remove duplicate lines'
	"
13	13	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from merge" -l commit -d 'Finalize git notes merge'
12	12	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from merge" -l abort -d 'Abort git notes merge'
15	15	-> complete -f -c git -n "__fish_git_using_command notes" -n "__fish_seen_subcommand_from remove" -l ignore-missing -d 'Do not throw error on deleting non-existing object note'
10	10	-> complete -f -c git -n __fish_git_needs_command -a prune -d 'Prune unreachable objects from the database'
10	10	-> complete -f -c git -n '__fish_git_using_command prune' -s n -l dry-run -d 'Just report what it would remove'
10	10	-> complete -f -c git -n '__fish_git_using_command prune' -s v -l verbose -d 'Report all removed objects'
10	10	-> complete -f -c git -n '__fish_git_using_command prune' -l progress -d 'Show progress'
9	9	-> complete -f -c git -n __fish_git_needs_command -a pull -d 'Fetch from and merge with another repo or branch'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -s q -l quiet -d 'Be quiet'
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -s v -l verbose -d 'Be verbose'
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -l all -d 'Fetch all remotes'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -s a -l append -d 'Append ref names and object names'
12	12	-> complete -f -c git -n '__fish_git_using_command pull' -s f -l force -d 'Force update of local branches'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -s k -l keep -d 'Keep downloaded pack'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l no-tags -d 'Disable automatic tag following'
11	11	-> complete -f -c git -n '__fish_git_using_command pull' -s p -l prune -d 'Remove remote-tracking references that no longer exist on the remote'
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -l progress -d 'Force progress status'
17	17	-> complete -f -c git -n '__fish_git_using_command pull' -n 'not __fish_git_branch_for_remote' -a '(__fish_git_remotes)' -d 'Remote alias'
14	14	-> complete -f -c git -n '__fish_git_using_command pull' -n __fish_git_branch_for_remote -ka '(__fish_git_branch_for_remote)'
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -l commit -d "Autocommit the merge"
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -l no-commit -d "Don't autocommit the merge"
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -s e -l edit -d 'Edit auto-generated merge message'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l no-edit -d "Don't edit auto-generated merge message"
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -l ff -d "Don't generate a merge commit if merge is fast-forward"
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l no-ff -d "Generate a merge commit even if merge is fast-forward"
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l ff-only -d 'Refuse to merge unless fast-forward possible'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -s S -l gpg-sign -d 'GPG-sign the merge commit'
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -l log -d 'Populate the log message with one-line descriptions'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l no-log -d "Don't populate the log message with one-line descriptions"
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -l signoff -d 'Add Signed-off-by line at the end of the merge commit message'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l no-signoff -d 'Do not add a Signed-off-by line at the end of the merge commit message'
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -l stat -d "Show diffstat of the merge"
11	11	-> complete -f -c git -n '__fish_git_using_command pull' -s n -l no-stat -d "Don't show diffstat of the merge"
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l squash -d "Squash changes from upstream branch as a single commit"
9	9	-> complete -f -c git -n '__fish_git_using_command pull' -l no-squash -d "Don't squash changes"
12	12	-> complete -x -c git -n '__fish_git_using_command pull' -s s -l strategy -d 'Use the given merge strategy'
10	10	-> complete -r -c git -n '__fish_git_using_command pull' -s X -l strategy-option -d 'Pass given option to the merge strategy'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l verify-signatures -d 'Abort merge if upstream branch tip commit is not signed with a valid key'
11	11	-> complete -f -c git -n '__fish_git_using_command pull' -l no-verify-signatures -d 'Do not abort merge if upstream branch tip commit is not signed with a valid key'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l allow-unrelated-histories -d 'Allow merging even when branches do not share a common history'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -s r -l rebase -d 'Rebase the current branch on top of the upstream branch'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l no-rebase -d 'Do not rebase the current branch on top of the upstream branch'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l autostash -d 'Before starting rebase, stash local changes, and apply stash when done'
10	10	-> complete -f -c git -n '__fish_git_using_command pull' -l no-autostash -d 'Do not stash local changes before starting rebase'
9	9	-> complete -f -c git -n __fish_git_needs_command -a range-diff -d 'Compare two commit ranges'
12	12	-> complete -f -c git -n '__fish_git_using_command range-diff' -ka '(__fish_git_ranges)'
10	10	-> complete -f -c git -n '__fish_git_using_command range-diff' -l creation-factor -d 'Percentage by which creation is weighted'
10	10	-> complete -f -c git -n '__fish_git_using_command range-diff' -l no-dual-color -d 'Use simple diff colors'
8	8	-> complete -f -c git -n __fish_git_needs_command -a push -d 'Push changes elsewhere'
16	16	-> complete -f -c git -n '__fish_git_using_command push' -n 'not __fish_git_branch_for_remote' -a '(__fish_git_remotes)' -d 'Remote alias'
15	15	-> complete -f -c git -n '__fish_git_using_command push' -n __fish_git_branch_for_remote -ka '(__fish_git_tags)' -d Tag
14	14	-> complete -f -c git -n '__fish_git_using_command push' -n __fish_git_branch_for_remote -ka '(__fish_git_branches)'
14	14	-> complete -f -c git -n '__fish_git_using_command push' -n __fish_git_branch_for_remote -ka '(__fish_git_heads)'
33	33	-> complete -f -c git -n '__fish_git_using_command push' -n __fish_git_branch_for_remote -n 'string match -q "+*" -- (commandline -ct)' -ka '+(__fish_git_branches | string replace -r \t".*" "")' -d 'Force-push branch'
29	29	-> complete -f -c git -n '__fish_git_using_command push' -n __fish_git_branch_for_remote -n 'string match -q ":*" -- (commandline -ct)' -ka ':(__fish_git_branch_for_remote | string replace -r \t".*" "")' -d 'Delete remote branch'
35	35	-> complete -f -c git -n '__fish_git_using_command push' -n __fish_git_branch_for_remote -n 'string match -q "+*:*" -- (commandline -ct)' -ka '(commandline -ct | string replace -r ":.*" ""):(__fish_git_branch_for_remote | string replace -r \t".*" "")' -d 'Force-push local branch to remote branch'
33	33	-> complete -f -c git -n '__fish_git_using_command push' -n __fish_git_branch_for_remote -n 'string match -q "*:*" -- (commandline -ct)' -ka '(commandline -ct | string replace -r ":.*" ""):(__fish_git_branch_for_remote | string replace -r \t".*" "")' -d 'Push local branch to remote branch'
10	10	-> complete -f -c git -n '__fish_git_using_command push' -l all -d 'Push all refs under refs/heads/'
10	10	-> complete -f -c git -n '__fish_git_using_command push' -l prune -d "Remove remote branches that don't have a local counterpart"
10	10	-> complete -f -c git -n '__fish_git_using_command push' -l mirror -d 'Push all refs under refs/'
10	10	-> complete -f -c git -n '__fish_git_using_command push' -l delete -d 'Delete all listed refs from the remote repository'
13	13	-> complete -f -c git -n '__fish_git_using_command push' -l tags -d 'Push all refs under refs/tags'
10	10	-> complete -f -c git -n '__fish_git_using_command push' -l follow-tags -d 'Push all usual refs plus the ones under refs/tags'
11	11	-> complete -f -c git -n '__fish_git_using_command push' -s n -l dry-run -d 'Do everything except actually send the updates'
9	9	-> complete -f -c git -n '__fish_git_using_command push' -l porcelain -d 'Produce machine-readable output'
12	12	-> complete -f -c git -n '__fish_git_using_command push' -s f -l force -d 'Force update of remote refs'
11	11	-> complete -f -c git -n '__fish_git_using_command push' -l force-with-lease -d 'Force update of remote refs, stopping if other\'s changes would be overwritten'
11	11	-> complete -f -c git -n '__fish_git_using_command push' -l force-if-includes -d 'Force an update only if the tip of the remote-tracking ref has been integrated locally'
10	10	-> complete -f -c git -n '__fish_git_using_command push' -s u -l set-upstream -d 'Add upstream (tracking) reference'
10	10	-> complete -f -c git -n '__fish_git_using_command push' -s q -l quiet -d 'Be quiet'
10	10	-> complete -f -c git -n '__fish_git_using_command push' -s v -l verbose -d 'Be verbose'
9	9	-> complete -f -c git -n '__fish_git_using_command push' -l progress -d 'Force progress status'
9	9	-> complete -f -c git -n __fish_git_needs_command -a rebase -d 'Reapply commit sequence on a new base'
12	12	-> complete -f -c git -n '__fish_git_using_command rebase' -a '(__fish_git_remotes)' -d 'Remote alias'
11	11	-> complete -f -c git -n '__fish_git_using_command rebase' -ka '(__fish_git_branches)'
11	11	-> complete -f -c git -n '__fish_git_using_command rebase' -a '(__fish_git_heads)' -d Head
14	14	-> complete -f -c git -n '__fish_git_using_command rebase' -ka '(__fish_git_tags)' -d Tag -k
12	12	-> complete -f -c git -n '__fish_git_using_command rebase' -a '(__fish_git_recent_commits)' -k
12	12	-> complete -f -c git -n '__fish_git_using_command rebase' -n __fish_git_is_rebasing -l continue -d 'Restart the rebasing process'
12	12	-> complete -f -c git -n '__fish_git_using_command rebase' -n __fish_git_is_rebasing -l abort -d 'Abort the rebase operation'
12	12	-> complete -f -c git -n '__fish_git_using_command rebase' -n __fish_git_is_rebasing -l edit-todo -d 'Edit the todo list'
9	9	-> complete -f -c git -n '__fish_git_using_command rebase' -l keep-empty -d "Keep the commits that don't change anything"
13	13	-> complete -f -c git -n '__fish_git_using_command rebase' -n __fish_git_is_rebasing -l skip -d 'Restart the rebasing process by skipping the current patch'
11	11	-> complete -f -c git -n '__fish_git_using_command rebase' -s m -l merge -d 'Use merging strategies to rebase'
10	10	-> complete -f -c git -n '__fish_git_using_command rebase' -s q -l quiet -d 'Be quiet'
49	49	-> complete -f -c git -n '__fish_git_using_command rebase' -s v -l verbose -d 'Be verbose'
10	10	-> complete -f -c git -n '__fish_git_using_command rebase' -l stat -d "Show diffstat of the rebase"
11	11	-> complete -f -c git -n '__fish_git_using_command rebase' -s n -l no-stat -d "Don't show diffstat of the rebase"
26	26	-> complete -f -c git -n '__fish_git_using_command rebase' -l verify -d "Allow the pre-rebase hook to run"
18	18	-> complete -f -c git -n '__fish_git_using_command rebase' -l no-verify -d "Don't allow the pre-rebase hook to run"
12	12	-> complete -f -c git -n '__fish_git_using_command rebase' -s f -l force-rebase -d 'Force the rebase'
43	43	-> complete -f -c git -n '__fish_git_using_command rebase' -l committer-date-is-author-date -d "Use the author date as the committer date"
10	10	-> complete -f -c git -n '__fish_git_using_command rebase' -l ignore-date -d "Use the committer date as the author date"
10	10	-> complete -f -c git -n '__fish_git_using_command rebase' -s i -l interactive -d 'Interactive mode'
11	11	-> complete -f -c git -n '__fish_git_using_command rebase' -s p -l preserve-merges -d 'Try to recreate merges'
72	72	-> complete -f -c git -n '__fish_git_using_command rebase' -s r -l rebase-merges -a 'rebase-cousins no-rebase-cousins' -d 'Preserve branch structure'
12	12	-> complete -f -c git -n '__fish_git_using_command rebase' -l root -d 'Rebase all reachable commits'
11	11	-> complete -f -c git -n '__fish_git_using_command rebase' -l autosquash -d 'Automatic squashing'
10	10	-> complete -f -c git -n '__fish_git_using_command rebase' -l no-autosquash -d 'No automatic squashing'
12	12	-> complete -f -c git -n '__fish_git_using_command rebase' -l autostash -d 'Before starting rebase, stash local changes, and apply stash when done'
10	10	-> complete -f -c git -n '__fish_git_using_command rebase' -l no-autostash -d 'Do not stash local changes before starting rebase'
13	13	-> complete -f -c git -n '__fish_git_using_command rebase' -l no-ff -d 'No fast-forward'
15	15	-> complete -f -c git -n '__fish_git_using_command rebase' -l onto -d 'Rebase current branch onto given upstream or newbase' -ka '(__fish_git_branches)'
10	10	-> complete -f -c git -n '__fish_git_using_command rebase' -l update-refs -d 'Update any branches that point to commits being rebased'
13	13	-> complete -f -c git -n '__fish_git_using_command rebase' -l no-update-refs -d 'Don\'t update any branches that point to commits being rebased'
10	10	-> complete -r -c git -n '__fish_git_using_command rebase' -l exec -d 'Execute shellscript'
8	8	-> set -l reflogcommands show expire delete exists
10	10	-> complete -f -c git -n __fish_git_needs_command -a reflog -d 'Manage reflog information'
13	13	-> complete -f -c git -n '__fish_git_using_command reflog' -ka '(__fish_git_branches)'
12	12	-> complete -f -c git -n '__fish_git_using_command reflog' -ka '(__fish_git_heads)' -d Head
29	29	-> complete -f -c git -n "__fish_git_using_command reflog" -n "not __fish_seen_subcommand_from $reflogcommands" -a "$reflogcommands"
10	10	-> complete -c git -n __fish_git_needs_command -a reset -d 'Reset current HEAD to the specified state'
10	10	-> complete -f -c git -n '__fish_git_using_command reset' -l hard -d 'Reset the index and the working tree'
10	10	-> complete -f -c git -n '__fish_git_using_command reset' -l soft -d 'Reset head without touching the index or the working tree'
10	10	-> complete -f -c git -n '__fish_git_using_command reset' -l mixed -d 'The default: reset the index but not the working tree'
21	21	-> complete -c git -n '__fish_git_using_command reset' -n 'not contains -- -- (commandline -opc)' -ka '(__fish_git_branches)'
22	22	-> complete -f -c git -n '__fish_git_using_command reset' -n 'not contains -- -- (commandline -opc)' -a '(__fish_git_files all-staged modified)'
21	21	-> complete -f -c git -n '__fish_git_using_command reset' -n 'contains -- -- (commandline -opc)' -a '(__fish_git_files all-staged deleted modified)'
19	19	-> complete -f -c git -n '__fish_git_using_command reset' -n 'not contains -- -- (commandline -opc)' -a '(__fish_git_reflog)' -d Reflog
9	9	-> complete -f -c git -n __fish_git_needs_command -a restore -d 'Restore working tree files'
15	15	-> complete -f -c git -n '__fish_git_using_command restore' -r -s s -l source -d 'Specify the source tree used to restore the working tree' -ka '(__fish_git_refs)'
10	10	-> complete -f -c git -n '__fish_git_using_command restore' -s p -l patch -d 'Interactive mode'
11	11	-> complete -f -c git -n '__fish_git_using_command restore' -s W -l worktree -d 'Restore working tree (default)'
10	10	-> complete -f -c git -n '__fish_git_using_command restore' -s S -l staged -d 'Restore the index'
11	11	-> complete -f -c git -n '__fish_git_using_command restore' -l ours -d 'When restoring files, use stage #2 (ours)'
9	9	-> complete -f -c git -n '__fish_git_using_command restore' -l theirs -d 'When restoring files, use stage #3 (theirs)'
12	12	-> complete -f -c git -n '__fish_git_using_command restore' -s m -l merge -d 'Recreate the conflicted merge in the unmerged paths when restoring files'
10	10	-> complete -f -c git -n '__fish_git_using_command restore' -l ignore-unmerged -d 'When restoring files, do not abort the operation if there are unmerged entries'
12	12	-> complete -f -c git -n '__fish_git_using_command restore' -l ignore-skip-worktree-bits -d 'Ignore the sparse-checkout file and unconditionally restore any files in <pathspec>'
11	11	-> complete -f -c git -n '__fish_git_using_command restore' -l overlay -d 'Never remove files when restoring'
10	10	-> complete -f -c git -n '__fish_git_using_command restore' -l no-overlay -d 'Remove files when restoring (default)'
22	22	-> complete -f -c git -n '__fish_git_using_command restore' -n 'not __fish_git_contains_opt -s S staged' -a '(__fish_git_files modified deleted modified-staged-deleted unmerged)'
22	22	-> complete -f -c git -n '__fish_git_using_command restore' -n '__fish_git_contains_opt -s S staged' -a '(__fish_git_files added modified-staged deleted-staged renamed copied)'
13	13	-> complete -F -c git -n '__fish_git_using_command restore' -n '__fish_git_contains_opt -s s source'
9	9	-> complete -f -c git -n __fish_git_needs_command -a switch -d 'Switch to a branch'
14	14	-> complete -f -c git -n '__fish_git_using_command switch' -ka '(__fish_git_unique_remote_branches)' -d 'Unique Remote Branch'
12	12	-> complete -f -c git -n '__fish_git_using_command switch' -ka '(__fish_git_branches)'
10	10	-> complete -f -c git -n '__fish_git_using_command switch' -s c -l create -d 'Create a new branch'
10	10	-> complete -f -c git -n '__fish_git_using_command switch' -s C -l force-create -d 'Force create a new branch'
14	14	-> complete -f -c git -n '__fish_git_using_command switch' -s d -l detach -rka '(__fish_git_recent_commits --all)'
15	15	-> complete -f -c git -n '__fish_git_using_command switch' -s d -l detach -d 'Switch to a commit for inspection and discardable experiment' -rka '(__fish_git_refs)'
9	9	-> complete -f -c git -n '__fish_git_using_command switch' -l guess -d 'Guess branch name from remote branch (default)'
9	9	-> complete -f -c git -n '__fish_git_using_command switch' -l no-guess -d 'Do not guess branch name from remote branch'
13	13	-> complete -f -c git -n '__fish_git_using_command switch' -s f -l force -l discard-changes -d 'Proceed even if the index or the working tree differs from HEAD'
11	11	-> complete -f -c git -n '__fish_git_using_command switch' -s m -l merge -d 'Merge the current branch and contents of the working tree into a new branch'
11	11	-> complete -f -c git -n '__fish_git_using_command switch' -s t -l track -d 'Track remote branch when creating a new branch'
10	10	-> complete -f -c git -n '__fish_git_using_command switch' -l no-track -d 'Do not track remote branch when creating a new branch'
10	10	-> complete -f -c git -n '__fish_git_using_command switch' -r -l orphan -d 'Create a new orphan branch'
9	9	-> complete -f -c git -n '__fish_git_using_command switch' -l ignore-other-worktrees -d 'Force check out of the reference'
9	9	-> complete -f -c git -n '__fish_git_using_command switch' -l recurse-submodules -d 'Update the work trees of submodules'
10	10	-> complete -f -c git -n '__fish_git_using_command switch' -l no-recurse-submodules -d 'Do not update the work trees of submodules'
11	11	-> complete -f -c git -n '__fish_git_using_command restore switch' -s q -l quiet -d 'Suppress messages'
10	10	-> complete -f -c git -n '__fish_git_using_command restore switch' -l progress -d 'Report progress status to stderr (default)'
11	11	-> complete -f -c git -n '__fish_git_using_command restore switch' -l no-progress -d 'Do not report progress status to stderr'
11	11	-> complete -f -c git -n '__fish_git_using_command restore switch' -l 'conflict=merge' -d 'Same as --merge, but specify \'merge\' as the conflicting hunk style (default)'
12	12	-> complete -f -c git -n '__fish_git_using_command restore switch' -l 'conflict=diff3' -d 'Same as --merge, but specify \'diff3\' as the conflicting hunk style'
10	10	-> complete -f -c git -n __fish_git_needs_command -a rev-parse -d 'Parse revision names or give repo information'
12	12	-> complete -f -c git -n '__fish_git_using_command rev-parse' -ka '(__fish_git_branches)'
13	13	-> complete -f -c git -n '__fish_git_using_command rev-parse' -a '(__fish_git_heads)' -d Head
13	13	-> complete -c git -n '__fish_git_using_command rev-parse' -ka '(__fish_git_tags)' -d Tag
9	9	-> complete -c git -n '__fish_git_using_command rev-parse' -l abbrev-ref -d 'Output non-ambiguous short object names'
9	9	-> complete -f -c git -n __fish_git_needs_command -a revert -d 'Revert an existing commit'
12	12	-> complete -f -c git -n '__fish_git_using_command revert' -ka '(__fish_git_commits)'
9	9	-> complete -f -c git -n '__fish_git_using_command revert' -l continue -d 'Continue the operation in progress'
9	9	-> complete -f -c git -n '__fish_git_using_command revert' -l abort -d 'Cancel the operation'
10	10	-> complete -f -c git -n '__fish_git_using_command revert' -l skip -d 'Skip the current commit and continue with the rest of the sequence'
9	9	-> complete -f -c git -n '__fish_git_using_command revert' -l quit -d 'Forget about the current operation in progress'
9	9	-> complete -f -c git -n '__fish_git_using_command revert' -l no-edit -d 'Do not start the commit message editor'
11	11	-> complete -f -c git -n '__fish_git_using_command revert' -s n -l no-commit -d 'Apply changes to index but don\'t create a commit'
10	10	-> complete -f -c git -n '__fish_git_using_command revert' -s s -l signoff -d 'Add a Signed-off-by trailer at the end of the commit message'
10	10	-> complete -f -c git -n '__fish_git_using_command revert' -l rerere-autoupdate -d 'Allow the rerere mechanism to update the index with the result of auto-conflict resolution'
12	12	-> complete -f -c git -n '__fish_git_using_command revert' -l no-rerere-autoupdate -d 'Prevent the rerere mechanism from updating the index with auto-conflict resolution'
11	11	-> complete -c git -n __fish_git_needs_command -a rm -d 'Remove files from the working tree and/or staging area'
9	9	-> complete -c git -n '__fish_git_using_command rm' -l cached -d 'Unstage files from the index'
17	17	-> complete -c git -n '__fish_git_using_command rm' -n '__fish_git_contains_opt cached' -f -a '(__fish_git_files all-staged)'
10	10	-> complete -c git -n '__fish_git_using_command rm' -l ignore-unmatch -d 'Exit with a zero status even if no files matched'
9	9	-> complete -c git -n '__fish_git_using_command rm' -s r -d 'Allow recursive removal'
10	10	-> complete -c git -n '__fish_git_using_command rm' -s q -l quiet -d 'Be quiet'
12	12	-> complete -c git -n '__fish_git_using_command rm' -s f -l force -d 'Override the up-to-date check'
10	10	-> complete -c git -n '__fish_git_using_command rm' -s n -l dry-run -d 'Dry run'
12	12	-> complete -c git -n '__fish_git_using_command rm' -l sparse -d 'Allow updating index entries outside of the sparse-checkout cone'
9	9	-> complete -f -c git -n __fish_git_needs_command -a status -d 'Show the working tree status'
10	10	-> complete -f -c git -n '__fish_git_using_command status' -s s -l short -d 'Give the output in the short-format'
12	12	-> complete -f -c git -n '__fish_git_using_command status' -s b -l branch -d 'Show the branch and tracking info even in short-format'
10	10	-> complete -f -c git -n '__fish_git_using_command status' -l porcelain -d 'Give the output in a stable, easy-to-parse format'
9	9	-> complete -f -c git -n '__fish_git_using_command status' -s z -d 'Terminate entries with null character'
54	54	-> complete -f -c git -n '__fish_git_using_command status' -s u -l untracked-files -x -a 'no normal all' -d 'The untracked files handling mode'
15	15	-> complete -f -c git -n '__fish_git_using_command status' -l ignore-submodules -x -a 'none untracked dirty all' -d 'Ignore changes to submodules'
11	11	-> complete -f -c git -n '__fish_git_using_command status' -s v -l verbose -d 'Also show the textual changes that are staged to be committed'
10	10	-> complete -f -c git -n '__fish_git_using_command status' -l no-ahead-behind -d 'Do not display detailed ahead/behind upstream-branch counts'
12	12	-> complete -f -c git -n '__fish_git_using_command status' -l renames -d 'Turn on rename detection regardless of user configuration'
23	23	-> complete -f -c git -n '__fish_git_using_command status' -l no-renames -d 'Turn off rename detection regardless of user configuration'
11	11	-> complete -f -c git -n __fish_git_needs_command -a stripspace -d 'Remove unnecessary whitespace'
15	15	-> complete -f -c git -n '__fish_git_using_command stripspace' -s s -l strip-comments -d 'Strip all lines starting with comment character'
12	12	-> complete -f -c git -n '__fish_git_using_command stripspace' -s c -l comment-lines -d 'Prepend comment character to each line'
43	43	-> complete -f -c git -n __fish_git_needs_command -a tag -d 'Create, list, delete or verify a tag object signed with GPG'
75	75	-> complete -f -c git -n '__fish_git_using_command tag' -n '__fish_not_contain_opt -s d' -n '__fish_not_contain_opt -s v' -n 'test (count (commandline -opc | string match -r -v \'^-\')) -eq 3' -ka '(__fish_git_branches)'
12	12	-> complete -f -c git -n '__fish_git_using_command tag' -s a -l annotate -d 'Make an unsigned, annotated tag object'
45	45	-> complete -f -c git -n '__fish_git_using_command tag' -s s -l sign -d 'Make a GPG-signed tag'
10	10	-> complete -f -c git -n '__fish_git_using_command tag' -s d -l delete -d 'Remove a tag'
10	10	-> complete -f -c git -n '__fish_git_using_command tag' -s v -l verify -d 'Verify signature of a tag'
9	9	-> complete -f -c git -n '__fish_git_using_command tag' -s f -l force -d 'Force overwriting existing tag'
9	9	-> complete -f -c git -n '__fish_git_using_command tag' -s l -l list -d 'List tags'
15	15	-> complete -f -c git -n '__fish_git_using_command tag' -l contains -xka '(__fish_git_commits)' -d 'List tags that contain a commit'
22	22	-> complete -f -c git -n '__fish_git_using_command tag' -n '__fish_git_contains_opt -s d delete -s v verify -s f force' -ka '(__fish_git_tags)' -d Tag
10	10	-> complete -c git -n __fish_git_needs_command -a update-index -d 'Register file contents in the working tree to the index'
9	9	-> complete -f -c git -n '__fish_git_using_command update-index' -l add -d 'Add specified files to the index'
9	9	-> complete -f -c git -n '__fish_git_using_command update-index' -l remove -d 'Remove specified files from the index'
9	9	-> complete -f -c git -n '__fish_git_using_command update-index' -l refresh -d 'Refresh current index'
9	9	-> complete -f -c git -n '__fish_git_using_command update-index' -s q -d 'Continue refresh after error'
11	11	-> complete -f -c git -n '__fish_git_using_command update-index' -l ignore-submodules -d 'Do not try to update submodules'
11	11	-> complete -f -c git -n '__fish_git_using_command update-index' -l unmerged -d 'Continue on unmerged changes in the index'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l ignore-missing -d 'Ignores missing files during a refresh'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l index-info -d 'Read index information from stdin'
15	15	-> complete -x -c git -n '__fish_git_using_command update-index' -l chmod -a '+x\tAdd\ execute\ permissions -x\tRemove\ execute\ permissions' -d 'Set execute permissions'
11	11	-> complete -f -c git -n '__fish_git_using_command update-index' -l assume-unchanged -d 'Set the "assume unchanged" bit for the paths'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l no-assume-unchanged -d 'Unset the "assume unchanged" bit'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l really-refresh -d 'Refresh but check stat info unconditionally'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l skip-worktree -d 'Set the "fsmonitor valid" bit'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l no-skip-worktree -d 'Unset the "fsmonitor valid" bit'
9	9	-> complete -f -c git -n '__fish_git_using_command update-index' -l fsmonitor-valid -d 'Set the "fsmonitor valid" bit'
11	11	-> complete -f -c git -n '__fish_git_using_command update-index' -l no-fsmonitor-valid -d 'Unset the "fsmonitor valid" bit'
13	13	-> complete -f -c git -n '__fish_git_using_command update-index' -s g -l again -d 'Run git update-index on paths with differing index'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l unresolve -d 'Restores the state of a file during a merge'
10	10	-> complete -r -c git -n '__fish_git_using_command update-index' -l info-only -d 'Do not create objects in the object database'
12	12	-> complete -f -c git -n '__fish_git_using_command update-index' -l force-remove -d 'Forcefully remove the file from the index'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l replace -d 'Replace conflicting entries'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l stdin -d 'Read list of paths from stdin'
9	9	-> complete -f -c git -n '__fish_git_using_command update-index' -l verbose -d 'Report changes to index'
12	12	-> complete -x -c git -n '__fish_git_using_command update-index' -l index-version -a "2\t\t3\t\t4" -d 'Set index-version'
9	9	-> complete -f -c git -n '__fish_git_using_command update-index' -s z -d 'Seperate paths with NUL instead of LF'
9	9	-> complete -f -c git -n '__fish_git_using_command update-index' -l split-index -d 'Enable split index mode'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l no-split-index -d 'Disable split index mode'
12	12	-> complete -f -c git -n '__fish_git_using_command update-index' -l untracked-cache -d 'Enable untracked cache feature'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l no-untracked-cache -d 'Disable untracked cache feature'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l test-untracked-cache -d 'Only perform tests on the working directory'
10	10	-> complete -f -c git -n '__fish_git_using_command update-index' -l force-untracked-cache -d 'Same as --untracked-cache'
51	51	-> complete -f -c git -n '__fish_git_using_command update-index' -l fsmonitor -d 'Enable files system monitor feature'
14	14	-> complete -f -c git -n '__fish_git_using_command update-index' -l no-fsmonitor -d 'Disable files system monitor feature'
9	9	-> set -l git_worktree_commands add list lock move prune remove unlock
12	12	-> complete -c git -n __fish_git_needs_command -a worktree -d 'Manage multiple working trees'
25	25	-> complete -f -c git -n "__fish_git_using_command worktree" -n "not __fish_seen_subcommand_from $git_worktree_commands" -a add -d 'Create a working tree'
87	87	-> complete -f -c git -n "__fish_git_using_command worktree" -n "not __fish_seen_subcommand_from $git_worktree_commands" -a list -d 'List details of each worktree'
74	74	-> complete -f -c git -n "__fish_git_using_command worktree" -n "not __fish_seen_subcommand_from $git_worktree_commands" -a lock -d 'Lock a working tree'
27	27	-> complete -f -c git -n "__fish_git_using_command worktree" -n "not __fish_seen_subcommand_from $git_worktree_commands" -a move -d 'Move a working tree to a new location'
47	47	-> complete -f -c git -n "__fish_git_using_command worktree" -n "not __fish_seen_subcommand_from $git_worktree_commands" -a prune -d 'Prune working tree information in $GIT_DIR/worktrees'
21	21	-> complete -f -c git -n "__fish_git_using_command worktree" -n "not __fish_seen_subcommand_from $git_worktree_commands" -a remove -d 'Remove a working tree'
20	20	-> complete -f -c git -n "__fish_git_using_command worktree" -n "not __fish_seen_subcommand_from $git_worktree_commands" -a unlock -d 'Unlock a working tree'
17	17	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add move remove' -s f -l force -d 'Override safeguards'
12	12	-> complete -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add'
17	17	-> complete -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -ka '(__fish_git_branches)'
53	53	-> complete -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -ka '(__fish_git_heads)' -d Head
17	17	-> complete -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -ka '(__fish_git_tags)' -d Tag
18	18	-> complete -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -ka '(__fish_git_unique_remote_branches)' -d 'Unique Remote Branch'
16	16	-> complete -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -ka '(__fish_git_local_branches)'
15	15	-> complete -x -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -s b -d 'Create a new branch'
48	48	-> complete -x -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -s B -d 'Create a new branch even if it already exists'
14	14	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -l detach -d 'Detach HEAD in the new working tree'
14	14	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -l checkout -d 'Checkout <commit-ish> after creating working tree'
54	54	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -l no-checkout -d 'Suppress checkout'
15	15	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -l guess-remote
13	13	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -l no-guess-remote
17	17	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -l track -d 'Mark <commit-ish> as "upstream" from the new branch'
54	54	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -l no-track -d 'Don\'t mark <commit-ish> as "upstream" from the new branch'
53	53	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -l lock -d 'Lock working tree after creation'
15	15	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from add' -s q -l quiet -d 'Suppress feedback messages'
14	14	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from list' -l porcelain -d 'Output in an easy-to-parse format for scripts'
17	17	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from lock' -a '(__fish_git_complete_worktrees)' -d Worktree
15	15	-> complete -x -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from lock' -l reason -d 'An explanation why the working tree is locked'
103	103	-> complete -x -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from move' -n 'not __fish_any_arg_in (__fish_git_complete_worktrees)' -a '(__fish_git_complete_worktrees)' -d Worktree
60	60	-> complete -x -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from move' -n '__fish_any_arg_in (__fish_git_complete_worktrees)' -a '(__fish_complete_directories)'
14	14	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from prune' -s n -l dry-run -d 'Do not remove anything'
52	52	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from prune' -s v -l verbose -d 'Report all removals'
17	17	-> complete -x -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from prune' -l expire -d 'Only expire unused working trees older than <time>'
18	18	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from remove' -a '(__fish_git_complete_worktrees)' -d Worktree
41	41	-> complete -f -c git -n '__fish_git_using_command worktree' -n '__fish_seen_subcommand_from unlock' -a '(__fish_git_complete_worktrees)' -d Worktree
10	10	-> complete -c git -n __fish_git_needs_command -a stash -d 'Stash away changes'
15	15	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a list -d 'List stashes'
14	14	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a show -d 'Show the changes recorded in the stash'
14	14	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a pop -d 'Apply and remove a single stashed state'
14	14	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a apply -d 'Apply a single stashed state'
12	12	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a clear -d 'Remove all stashed states'
12	12	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a drop -d 'Remove a single stashed state from the stash list'
13	13	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a create -d 'Create a stash'
12	12	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a save -d 'Save a new stash'
12	12	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a branch -d 'Create a new branch from a stash'
12	12	-> complete -f -c git -n '__fish_git_using_command stash' -n __fish_git_stash_not_using_subcommand -a push -d 'Create a new stash with given files'
15	15	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command apply' -ka '(__fish_git_complete_stashes)'
15	15	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command branch' -ka '(__fish_git_complete_stashes)'
14	14	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command drop' -ka '(__fish_git_complete_stashes)'
14	14	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command pop' -ka '(__fish_git_complete_stashes)'
15	15	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command show' -ka '(__fish_git_complete_stashes)'
20	20	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command push' -a '(__fish_git_files modified deleted modified-staged-deleted)'
14	14	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command push' -s a -l all -d 'Stash ignored and untracked files'
17	17	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command push' -s k -l keep-index -d 'Keep changes in index intact'
13	13	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command push' -s p -l patch -d 'Interactively select hunks'
12	12	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command push' -s m -l message -d 'Add a description'
14	14	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command push' -l no-keep-index -d 'Don\'t keep changes in index intact'
13	13	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command push' -s S -l staged -d 'Stash only staged changes'
13	13	-> complete -f -c git -n '__fish_git_using_command stash' -n '__fish_git_stash_using_command push' -s u -l include-untracked -d 'Stash untracked files'
9	9	-> complete -f -c git -n __fish_git_needs_command -a config -d 'Set and read git configuration variables'
9	9	-> complete -f -c git -n __fish_git_needs_command -a format-patch -d 'Generate patch series to send upstream'
11	11	-> complete -f -c git -n '__fish_git_using_command format-patch' -ka '(__fish_git_branches)'
13	13	-> complete -c git -n '__fish_git_using_command format-patch' -s o -l output-directory -xa '(__fish_complete_directories)'
15	15	-> complete -f -c git -n '__fish_git_using_command format-patch' -s p -l no-stat -d "Generate plain patches without diffstat"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch' -s s -l no-patch -d "Suppress diff output"
9	9	-> complete -f -c git -n '__fish_git_using_command format-patch' -l minimal -d "Spend more time to create smaller diffs"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch' -l patience -d "Generate diff with the 'patience' algorithm"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch' -l histogram -d "Generate diff with the 'histogram' algorithm"
11	11	-> complete -f -c git -n '__fish_git_using_command format-patch' -l stdout -d "Print all commits to stdout in mbox format"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch' -l numstat -d "Show number of added/deleted lines in decimal notation"
9	9	-> complete -f -c git -n '__fish_git_using_command format-patch' -l shortstat -d "Output only last line of the stat"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch' -l summary -d "Output a condensed summary of extended header information"
9	9	-> complete -f -c git -n '__fish_git_using_command format-patch' -l no-renames -d "Disable rename detection"
9	9	-> complete -f -c git -n '__fish_git_using_command format-patch' -l full-index -d "Show full blob object names"
9	9	-> complete -f -c git -n '__fish_git_using_command format-patch' -l binary -d "Output a binary diff for use with git apply"
11	11	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l find-copies-harder -d "Also inspect unmodified files as source for a copy"
9	9	-> complete -f -c git -n '__fish_git_using_command format-patch' -l text -s a -d "Treat all files as text"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l ignore-space-at-eol -d "Ignore changes in whitespace at EOL"
11	11	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l ignore-space-change -s b -d "Ignore changes in amount of whitespace"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l ignore-all-space -s w -d "Ignore whitespace when comparing lines"
12	12	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l ignore-blank-lines -d "Ignore changes whose lines are all blank"
18	18	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l function-context -s W -d "Show whole surrounding functions of changes"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l ext-diff -d "Allow an external diff helper to be executed"
9	9	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l no-ext-diff -d "Disallow external diff helpers"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l no-textconv -d "Disallow external text conversion filters for binary files (Default)"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l textconv -d "Allow external filters for binary files (Resulting diff is unappliable)"
9	9	-> complete -f -c git -n '__fish_git_using_command format-patch log' -l no-prefix -d "Do not show source or destination prefix"
10	10	-> complete -f -c git -n '__fish_git_using_command format-patch' -l numbered -s n -d "Name output in [Patch n/m] format, even with a single patch"
12	12	-> complete -f -c git -n '__fish_git_using_command format-patch' -l no-numbered -s N -d "Name output in [Patch] format, even with multiple patches"
14	14	-> set -l submodulecommands add status init deinit update set-branch set-url summary foreach sync absorbgitdirs
10	10	-> complete -f -c git -n __fish_git_needs_command -a submodule -d 'Initialize, update or inspect submodules'
24	24	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a add -d 'Add a submodule'
24	24	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a status -d 'Show submodule status'
20	20	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a init -d 'Initialize all submodules'
22	22	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a deinit -d 'Unregister the given submodules'
20	20	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a update -d 'Update all submodules'
21	21	-> complete -x -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a set-branch -d 'Set the default remote tracking branch'
20	20	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a set-url -d 'Sets the URL of the specified submodule'
19	19	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a summary -d 'Show commit summary'
20	20	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a foreach -d 'Run command on each submodule'
20	20	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a sync -d 'Sync submodules\' URL with .gitmodules'
23	23	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -a absorbgitdirs -d 'Move submodule\'s git directory to current .git/module directory'
21	21	-> complete -f -c git -n "__fish_git_using_command submodule" -n "not __fish_seen_subcommand_from $submodulecommands" -s q -l quiet -d "Only print error messages"
13	13	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from update' -l init -d "Initialize all submodules"
14	14	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from update' -l checkout -d "Checkout the superproject's commit on a detached HEAD in the submodule"
14	14	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from update' -l merge -d "Merge the superproject's commit into the current branch of the submodule"
13	13	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from update' -l rebase -d "Rebase current branch onto the superproject's commit"
14	14	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from update' -s N -l no-fetch -d "Don't fetch new objects from the remote"
14	14	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from update' -l remote -d "Instead of using superproject's SHA-1, use the state of the submodule's remote-tracking branch"
14	14	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from update' -l force -d "Discard local changes when switching to a different commit & always run checkout"
15	15	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from add' -l force -d "Also add ignored submodule path"
13	13	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from deinit' -l force -d "Remove even with local changes"
13	13	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from deinit' -l all -d "Remove all submodules"
23	23	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from deinit' -n 'not contains -- -- (commandline -opc)' -a '(__fish_git_submodules)' -d Submodule
14	14	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from set-branch' -s b -l branch -d "Specify the branch to use"
13	13	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from set-branch' -s d -l default -d "Use default branch of the submodule"
16	16	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from status summary' -l cached -d "Use the commit stored in the index"
22	22	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from status' -n 'not contains -- -- (commandline -opc)' -a '(__fish_git_submodules)' -d Submodule
13	13	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from summary' -l files -d "Compare the commit in the index with submodule HEAD"
15	15	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from foreach update status' -l recursive -d "Traverse submodules recursively"
16	16	-> complete -f -c git -n '__fish_git_using_command submodule' -n '__fish_seen_subcommand_from foreach' -a "(__fish_complete_subcommand --fcs-skip=3)"
10	10	-> complete -f -c git -n __fish_git_needs_command -a whatchanged -d 'Show logs with difference each commit introduces'
9	9	-> complete -c git -n __fish_git_needs_command -a '(__fish_git_aliases)'
8	8	-> complete -f -c git -n __fish_git_needs_command -a clean -d 'Remove untracked files from the working tree'
10	10	-> complete -f -c git -n '__fish_git_using_command clean' -s f -l force -d 'Force run'
10	10	-> complete -f -c git -n '__fish_git_using_command clean' -s i -l interactive -d 'Show what would be done and clean files interactively'
10	10	-> complete -f -c git -n '__fish_git_using_command clean' -s n -l dry-run -d 'Don\'t actually remove anything, just show what would be done'
11	11	-> complete -f -c git -n '__fish_git_using_command clean' -s q -l quiet -d 'Be quiet, only report errors'
9	9	-> complete -f -c git -n '__fish_git_using_command clean' -s d -d 'Remove untracked directories in addition to untracked files'
8	8	-> complete -f -c git -n '__fish_git_using_command clean' -s x -d 'Remove ignored files, as well'
9	9	-> complete -f -c git -n '__fish_git_using_command clean' -s X -d 'Remove only ignored files'
9	9	-> complete -f -c git -n __fish_git_needs_command -a blame -d 'Show what last modified each line of a file'
8	8	-> complete -f -c git -n '__fish_git_using_command blame' -s b -d 'Show blank SHA-1 for boundary commits'
9	9	-> complete -f -c git -n '__fish_git_using_command blame' -l root -d 'Do not treat root commits as boundaries'
9	9	-> complete -f -c git -n '__fish_git_using_command blame' -l show-stats -d 'Include additional statistics'
8	8	-> complete -f -c git -n '__fish_git_using_command blame' -s L -d 'Annotate only the given line range'
8	8	-> complete -f -c git -n '__fish_git_using_command blame' -s l -d 'Show long rev'
9	9	-> complete -f -c git -n '__fish_git_using_command blame' -s t -d 'Show raw timestamp'
9	9	-> complete -r -c git -n '__fish_git_using_command blame' -s S -d 'Use revisions from named file instead of calling rev-list'
9	9	-> complete -f -c git -n '__fish_git_using_command blame' -l reverse -d 'Walk history forward instead of backward'
10	10	-> complete -f -c git -n '__fish_git_using_command blame' -s p -l porcelain -d 'Show in a format designed for machine consumption'
9	9	-> complete -f -c git -n '__fish_git_using_command blame' -l line-porcelain -d 'Show the porcelain format'
9	9	-> complete -f -c git -n '__fish_git_using_command blame' -l incremental -d 'Show the result incrementally'
10	10	-> complete -r -c git -n '__fish_git_using_command blame' -l contents -d 'Instead of working tree, use the contents of the named file'
9	9	-> complete -x -c git -n '__fish_git_using_command blame' -l date -d 'Specifies the format used to output dates'
9	9	-> complete -f -c git -n '__fish_git_using_command blame' -s M -d 'Detect moved or copied lines within a file'
9	9	-> complete -f -c git -n '__fish_git_using_command blame' -s C -d 'Detect lines moved or copied from other files modified in the same commit'
8	8	-> complete -f -c git -n '__fish_git_using_command blame' -s h -d 'Show help message'
9	9	-> complete -f -c git -n '__fish_git_using_command blame' -s c -d 'Use the same output mode as git-annotate'
11	11	-> complete -f -c git -n '__fish_git_using_command blame' -s f -l show-name -d 'Show the filename in the original commit'
10	10	-> complete -f -c git -n '__fish_git_using_command blame' -s n -l show-number -d 'Show the line number in the original commit'
8	8	-> complete -f -c git -n '__fish_git_using_command blame' -s s -d 'Suppress the author name and timestamp from the output'
11	11	-> complete -f -c git -n '__fish_git_using_command blame' -s e -l show-email -d 'Show the author email instead of author name'
8	8	-> complete -f -c git -n '__fish_git_using_command blame' -s w -d 'Ignore whitespace changes'
9	9	-> complete -f -c git -n __fish_git_needs_command -a help -d 'Display help information about Git'
11	11	-> complete -f -c git -n '__fish_git_using_command help' -a '(__fish_git_help_all_concepts)'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a add -d 'Add file contents to the index'
12	12	-> complete -f -c git -n '__fish_git_using_command help' -a am -d 'Apply a series of patches from a mailbox'
12	12	-> complete -f -c git -n '__fish_git_using_command help' -a apply -d 'Apply a patch on a git index file and a working tree'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a archive -d 'Create an archive of files from a named tree'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a bisect -d 'Find the change that introduced a bug by binary search'
11	11	-> complete -f -c git -n '__fish_git_using_command help' -a blame -d 'Show what revision and author last modified each line of a file'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a branch -d 'List, create, or delete branches'
13	13	-> complete -f -c git -n '__fish_git_using_command help' -a checkout -d 'Checkout and switch to a branch'
11	11	-> complete -f -c git -n '__fish_git_using_command help' -a cherry-pick -d 'Apply the change introduced by an existing commit'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a clean -d 'Remove untracked files from the working tree'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a clone -d 'Clone a repository into a new directory'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a commit -d 'Record changes to the repository'
11	11	-> complete -f -c git -n '__fish_git_using_command help' -a config -d 'Set and read git configuration variables'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a count-objects -d 'Count unpacked number of objects and their disk consumption'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a describe -d 'Give an object a human-readable name'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a diff -d 'Show changes between commits, commit and working tree, etc'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a daemon -d 'A really simple server for Git repositories'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a difftool -d 'Open diffs in a visual tool'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a fetch -d 'Download objects and refs from another repository'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a filter-branch -d 'Rewrite branches'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a format-patch -d 'Generate patch series to send upstream'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a gc -d 'Cleanup unnecessary files and optimize the local repository'
12	12	-> complete -f -c git -n '__fish_git_using_command help' -a grep -d 'Print lines matching a pattern'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a init -d 'Create an empty git repository or reinitialize an existing one'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a log -d 'Show commit logs'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a ls-files -d 'Show information about files in the index and the working tree'
12	12	-> complete -f -c git -n '__fish_git_using_command help' -a mailinfo -d 'Extracts patch and authorship from a single e-mail message'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a mailsplit -d 'Simple UNIX mbox splitter program'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a maintenance -d 'Run tasks to optimize Git repository data'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a merge -d 'Join two or more development histories together'
11	11	-> complete -f -c git -n '__fish_git_using_command help' -a merge-base -d 'Find as good common ancestors as possible for a merge'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a mergetool -d 'Run merge conflict resolution tools to resolve merge conflicts'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a mv -d 'Move or rename a file, a directory, or a symlink'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a notes -d 'Add or inspect object notes'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a prune -d 'Prune all unreachable objects from the object database'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a pull -d 'Fetch from and merge with another repository or a local branch'
11	11	-> complete -f -c git -n '__fish_git_using_command help' -a push -d 'Update remote refs along with associated objects'
12	12	-> complete -f -c git -n '__fish_git_using_command help' -a range-diff -d 'Compare two commit ranges (e.g. two versions of a branch)'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a rebase -d 'Forward-port local commits to the updated upstream head'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a reflog -d 'Manage reflog information'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a remote -d 'Manage set of tracked repositories'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a reset -d 'Reset current HEAD to the specified state'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a restore -d 'Restore working tree files'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a revert -d 'Revert an existing commit'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a rev-parse -d 'Pick out and massage parameters'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a rm -d 'Remove files from the working tree and from the index'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a show -d 'Shows the last commit of a branch'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a show-branch -d 'Shows the commits on branches'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a stash -d 'Stash away changes'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a status -d 'Show the working tree status'
9	9	-> complete -f -c git -n '__fish_git_using_command help' -a submodule -d 'Initialize, update or inspect submodules'
11	11	-> complete -f -c git -n '__fish_git_using_command help' -a stripspace -d 'Remove unnecessary whitespace'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a switch -d 'Switch to a branch'
12	12	-> complete -f -c git -n '__fish_git_using_command help' -a tag -d 'Create, list, delete or verify a tag object signed with GPG'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a update-index -d 'Register file contents in the working tree to the index'
12	12	-> complete -f -c git -n '__fish_git_using_command help' -a whatchanged -d 'Show logs with difference each commit introduces'
10	10	-> complete -f -c git -n '__fish_git_using_command help' -a worktree -d 'Manage multiple working trees'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l global -d 'Get/set global configuration'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l system -d 'Get/set system configuration'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l local -d 'Get/set local repo configuration'
10	10	-> complete -F -c git -n '__fish_git_using_command config' -s f -l file -d 'Read config from file' -r
9	9	-> complete -F -c git -n '__fish_git_using_command config' -l blob -d 'Read config from blob' -r
3	3	-> function __fish_git_complete_key_values...
16	16	-> complete -c git -n '__fish_git_using_command config' -n '__fish_is_nth_token 2' -kfa '(__fish_git_config_keys)'
15	15	-> complete -c git -n '__fish_git_using_command config' -n '__fish_is_nth_token 3' -fa '(__fish_git_complete_key_values)'
15	15	-> complete -f -c git -n '__fish_git_using_command config' -l get -d 'Get config with name' -kra '(__fish_git_config_keys)'
12	12	-> complete -f -c git -n '__fish_git_using_command config' -l get-all -d 'Get all values matching key' -ka '(__fish_git_config_keys)'
10	10	-> complete -f -c git -n '__fish_git_using_command config' -l get-urlmatch -d 'Get value specific for the section url' -r
13	13	-> complete -f -c git -n '__fish_git_using_command config' -l replace-all -d 'Replace all matching variables' -kra '(__fish_git_config_keys)'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l add -d 'Add a new variable' -r
14	14	-> complete -f -c git -n '__fish_git_using_command config' -l unset -d 'Remove a variable' -ka '(__fish_git_config_keys)'
13	13	-> complete -f -c git -n '__fish_git_using_command config' -l unset-all -d 'Remove matching variables' -ka '(__fish_git_config_keys)'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l rename-section -d 'Rename section' -r
10	10	-> complete -f -c git -n '__fish_git_using_command config' -s l -l list -d 'List all variables'
11	11	-> complete -f -c git -n '__fish_git_using_command config' -s e -l edit -d 'Open configuration in an editor'
10	10	-> complete -f -c git -n '__fish_git_using_command config' -s t -l type -d 'Value is of given type'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l bool -d 'Value is \'true\' or \'false\''
8	8	-> complete -f -c git -n '__fish_git_using_command config' -l int -d 'Value is a decimal number'
10	10	-> complete -f -c git -n '__fish_git_using_command config' -l bool-or-int -d 'Value is --bool or --int'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l path -d 'Value is a path'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l expiry-date -d 'Value is an expiry date'
10	10	-> complete -f -c git -n '__fish_git_using_command config' -s z -l null -d 'Terminate values with NUL byte'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l name-only -d 'Show variable names only'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l includes -d 'Respect include directives'
9	9	-> complete -f -c git -n '__fish_git_using_command config' -l show-origin -d 'Show origin of configuration'
14	14	-> complete -f -c git -n '__fish_git_using_command config' -n '__fish_seen_argument get' -l default -d 'Use default value when missing entry'
9	9	-> complete -f -c git -n __fish_git_needs_command -a for-each-ref -d "Format and output info on each ref"
9	9	-> complete -f -c git -n '__fish_git_using_command for-each-ref' -l count -d "Limit to n results"
8	8	-> set -l for_each_ref_interpreters shell perl python tcl
115	212	-> for intr in $for_each_ref_interpreters...
43	43	--> complete -f -c git -n '__fish_git_using_command for-each-ref' \
        -n "not __fish_seen_argument --$for_each_ref_interpreters" \
        -l $intr -d "%(fieldname) placeholders are $intr scripts"
19	19	--> complete -f -c git -n '__fish_git_using_command for-each-ref' \
        -n "not __fish_seen_argument --$for_each_ref_interpreters" \
        -l $intr -d "%(fieldname) placeholders are $intr scripts"
18	18	--> complete -f -c git -n '__fish_git_using_command for-each-ref' \
        -n "not __fish_seen_argument --$for_each_ref_interpreters" \
        -l $intr -d "%(fieldname) placeholders are $intr scripts"
17	17	--> complete -f -c git -n '__fish_git_using_command for-each-ref' \
        -n "not __fish_seen_argument --$for_each_ref_interpreters" \
        -l $intr -d "%(fieldname) placeholders are $intr scripts"
11	11	-> complete -f -c git -n '__fish_git_using_command for-each-ref' -x -l format -d "Format string with %(fieldname) placeholders"
17	17	-> complete -f -c git -n '__fish_git_using_command for-each-ref' -f -l color -d "When to color" -a "always never auto"
14	14	-> complete -f -c git -n '__fish_git_using_command for-each-ref' -l points-at -d "Only list refs pointing at object" -ka '(__fish_git_commits)'
52	52	-> complete -f -c git -n '__fish_git_using_command for-each-ref' -x -l merged -d "Only list refs reachable from specified commit" -ka '(__fish_git_commits)'
18	18	-> complete -f -c git -n '__fish_git_using_command for-each-ref' -x -l no-merged -d "Only list refs not reachable from specified commit" -ka '(__fish_git_commits)'
15	15	-> complete -f -c git -n '__fish_git_using_command for-each-ref' -x -l contains -d "Only list refs containing the specified commit" -ka '(__fish_git_commits)'
15	15	-> complete -f -c git -n '__fish_git_using_command for-each-ref' -x -l no-contains -d "Only list refs not containing the specified commit" -ka '(__fish_git_commits)'
12	12	-> complete -f -c git -n '__fish_git_using_command for-each-ref' -x -l ignore-case -d "Sorting and filtering refs are case insensitive"
8	8	-> set -l sortcommands branch for-each-ref tag
2	2	-> function __fish_git_sort_keys...
19	19	-> complete -f -c git -n "__fish_seen_subcommand_from $sortcommands" -l sort -d 'Sort results by' -a "(__fish_git_sort_keys)"
12	12	-> complete -c git -n __fish_git_needs_command -a '(__fish_git_custom_commands)' -d 'Custom command'
3	3	-> function __fish_git_complete_custom_command -a subcommand...
5	5	-> set -l __fish_git_custom_commands_completion
241	58576	-> for file in (path filter -xZ $PATH/git-* | path basename)...
57387	57387	--> path filter -xZ $PATH/git-* | path basename
17	17	--> contains -- $file $__fish_git_custom_commands_completion
61	115	--> set -l cmd (string replace -r '^git-' '' -- $file | string escape)
54	54	---> string replace -r '^git-' '' -- $file | string escape
32	32	--> complete -c git -f -n "__fish_git_using_command $cmd" -a "(__fish_git_complete_custom_command $cmd)"
12	12	--> set -a __fish_git_custom_commands_completion $file
7	7	--> contains -- $file $__fish_git_custom_commands_completion
42	74	--> set -l cmd (string replace -r '^git-' '' -- $file | string escape)
32	32	---> string replace -r '^git-' '' -- $file | string escape
22	22	--> complete -c git -f -n "__fish_git_using_command $cmd" -a "(__fish_git_complete_custom_command $cmd)"
8	8	--> set -a __fish_git_custom_commands_completion $file
7	7	--> contains -- $file $__fish_git_custom_commands_completion
44	75	--> set -l cmd (string replace -r '^git-' '' -- $file | string escape)
31	31	---> string replace -r '^git-' '' -- $file | string escape
22	22	--> complete -c git -f -n "__fish_git_using_command $cmd" -a "(__fish_git_complete_custom_command $cmd)"
8	8	--> set -a __fish_git_custom_commands_completion $file
8	8	--> contains -- $file $__fish_git_custom_commands_completion
105	135	--> set -l cmd (string replace -r '^git-' '' -- $file | string escape)
30	30	---> string replace -r '^git-' '' -- $file | string escape
41	41	--> complete -c git -f -n "__fish_git_using_command $cmd" -a "(__fish_git_complete_custom_command $cmd)"
12	12	--> set -a __fish_git_custom_commands_completion $file
10	10	--> contains -- $file $__fish_git_custom_commands_completion
61	108	--> set -l cmd (string replace -r '^git-' '' -- $file | string escape)
47	47	---> string replace -r '^git-' '' -- $file | string escape
36	36	--> complete -c git -f -n "__fish_git_using_command $cmd" -a "(__fish_git_complete_custom_command $cmd)"
11	11	--> set -a __fish_git_custom_commands_completion $file
16	16	--> contains -- $file $__fish_git_custom_commands_completion
50	94	--> set -l cmd (string replace -r '^git-' '' -- $file | string escape)
44	44	---> string replace -r '^git-' '' -- $file | string escape
25	25	--> complete -c git -f -n "__fish_git_using_command $cmd" -a "(__fish_git_complete_custom_command $cmd)"
9	9	--> set -a __fish_git_custom_commands_completion $file
11	11	--> contains -- $file $__fish_git_custom_commands_completion
3	3	--> continue
8	8	--> contains -- $file $__fish_git_custom_commands_completion
2	2	--> continue
8	8	--> contains -- $file $__fish_git_custom_commands_completion
2	2	--> continue
8	8	--> contains -- $file $__fish_git_custom_commands_completion
2	2	--> continue
61	107	> __fish_disable_bracketed_paste 'git commit -m "added: ff config"'
46	46	-> printf "\e[?2004l"
39	2005	> fish_title git\ commit\ -m\ \"added:\ ff\ config\"
23	1966	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
11	1893	--> if set -q argv[1]...
11	11	---> set -q argv[1]
289	1871	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
33	33	----> string sub -l 20 -- $argv[1]
87	1549	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
86	86	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
40	1213	-----> for path in $argv...
144	180	------> set -l realhome (string escape --style=regex -- ~)
36	36	-------> string escape --style=regex -- ~
139	206	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
67	67	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
22	787	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
27	27	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
21	474	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
170	385	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
179	215	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
36	36	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
184	251	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
67	67	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
93200	93200	> git commit -m "added: ff config"
23	56	> __fish_enable_bracketed_paste
33	33	-> printf "\e[?2004h"
12	57	> fish_mode_prompt
17	45	-> fish_default_mode_prompt
3	28	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
31	225348	> fish_prompt
13	13	-> set -l last_status $status
42	54	-> set -l normal (set_color normal)
12	12	--> set_color normal
39	48	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
39	49	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
36	44	-> set -l vcs_color (set_color brpurple)
8	8	--> set_color brpurple
5	5	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	77	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
14	64	--> fish_is_root_user
2	37	---> if test "$EUID" = 0 2>/dev/null...
35	35	----> test "$EUID" = 0 2>/dev/null
1	10	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
3	3	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
200	224993	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
53	713	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
387	637	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
14	14	----> set_color normal
48	48	----> set_color $color_host
18	129	----> prompt_hostname
111	111	-----> string replace -r -- "\..*" "" $hostname
48	48	----> set_color normal
23	444	--> prompt_pwd
43	43	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
19	330	---> for path in $argv...
62	73	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
142	220	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
78	78	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
11	223636	--> fish_vcs_prompt
100	223625	---> fish_git_prompt $argv
11	52515	----> if not command -sq git...
52504	52504	-----> not command -sq git
2	33	----> if functions -q __fish_git_prompt_ready...
31	31	-----> functions -q __fish_git_prompt_ready
127	56612	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56485	56485	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
87	56750	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	56663	-----> __fish_git_prompt_operation_branch_bare $repo_info
11	11	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	94	------> if test -d $git_dir/rebase-merge...
17	17	-------> test -d $git_dir/rebase-merge
5	53	-------> if test -d $git_dir/rebase-apply...
14	14	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
9	9	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
8	17	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
12	56415	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56399	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	56397	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56309	56309	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
23	23	----> set -l r $rbc[1]
7	7	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
20	20	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
51120	56984	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5864	5864	-----> read -lz key value
7	51	----> if not set -q dirty[1]...
23	23	-----> not set -q dirty[1]
21	21	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
19	19	----> contains dirtystate $__fish_git_prompt_status_order
4	19	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
10	10	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	77	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
7	47	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
4	13	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
4	13	-----> if set -q __fish_git_prompt_showupstream...
3	3	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
20	52	----> for i in $__fish_git_prompt_status_order...
1	12	-----> if test -n "$$i"...
11	11	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
65	79	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
1	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	34	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
3	6	----> if test -n "$p"...
3	3	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
36	36	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
10	571	> fish_title
7	561	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
3	3	--> set -q SSH_TTY
5	542	--> if set -q argv[1]...
4	4	---> set -q argv[1]
39	44	---> set -l command (status current-command)
5	5	----> status current-command
2	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
5	5	----> set command
63	476	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
6	6	----> string sub -l 20 -- $command
22	407	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	313	-----> for path in $argv...
37	47	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
39	60	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	194	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	109	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	87	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	51	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
40	62	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
22	22	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
111	188	> __fish_disable_bracketed_paste 'git push'
77	77	-> printf "\e[?2004l"
53	2491	> fish_title git\ push
32	2438	-> if not set -q INSIDE_EMACS...
35	35	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
16	16	--> set -q SSH_TTY
24	2330	--> if set -q argv[1]...
16	16	---> set -q argv[1]
606	2290	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
47	47	----> string sub -l 20 -- $argv[1]
133	1637	----> prompt_pwd -d 1 -D 1
47	47	-----> set -l options h/help d/dir-length= D/full-length-dirs=
96	96	-----> argparse -n prompt_pwd $options -- $argv
7	26	-----> if set -q _flag_help...
19	19	------> set -q _flag_help
15	15	-----> set -q argv[1]
28	28	-----> set argv $PWD
14	14	-----> set -ql _flag_d
29	29	-----> set -l fish_prompt_pwd_dir_length $_flag_d
14	14	-----> set -q fish_prompt_pwd_dir_length
18	18	-----> set -l fulldirs 0
12	12	-----> set -ql _flag_D
23	23	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
14	14	-----> set -q fish_prompt_pwd_full_dirs
53	1168	-----> for path in $argv...
211	243	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
167	242	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
75	75	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
33	630	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
31	31	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
19	364	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
134	294	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
122	160	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
38	38	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
14	14	--------> set full $all[2..]
134	189	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
55	55	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
27357050	27357050	> git push
51	230	> __fish_enable_bracketed_paste
179	179	-> printf "\e[?2004h"
27	176	> fish_mode_prompt
80	149	-> fish_default_mode_prompt
11	69	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
40	40	---> test "$fish_key_bindings" = fish_vi_key_bindings
18	18	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
53	238292	> fish_prompt
32	32	-> set -l last_status $status
102	171	-> set -l normal (set_color normal)
69	69	--> set_color normal
92	112	-> set -l status_color (set_color brgreen)
20	20	--> set_color brgreen
164	187	-> set -l cwd_color (set_color $fish_color_cwd)
23	23	--> set_color $fish_color_cwd
157	186	-> set -l vcs_color (set_color brpurple)
29	29	--> set_color brpurple
16	16	-> set -l prompt_status ""
9	9	-> set -q fish_prompt_pwd_dir_length
11	11	-> set -lx fish_prompt_pwd_dir_length 0
11	11	-> set -l suffix '❯'
6	364	-> if functions -q fish_is_root_user...
150	150	--> functions -q fish_is_root_user
35	208	--> fish_is_root_user
7	95	---> if test "$EUID" = 0 2>/dev/null...
88	88	----> test "$EUID" = 0 2>/dev/null
4	70	---> if contains -- $USER root toor Administrator...
66	66	----> contains -- $USER root toor Administrator
8	8	---> return 1
3	19	-> if test $last_status -ne 0...
16	16	--> test $last_status -ne 0
429	237108	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
240	1591	--> prompt_login
7	49	---> if not set -q __fish_machine...
42	42	----> not set -q __fish_machine
2	13	---> if set -q __fish_machine[1]...
11	11	----> set -q __fish_machine[1]
23	23	---> set -l color_host $fish_color_host
2	10	---> if set -q SSH_TTY...
8	8	----> set -q SSH_TTY
890	1256	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
30	30	----> set_color $fish_color_user
52	52	----> set_color normal
46	46	----> set_color $color_host
126	203	----> prompt_hostname
77	77	-----> string replace -r -- "\..*" "" $hostname
35	35	----> set_color normal
286	867	--> prompt_pwd
36	36	---> set -l options h/help d/dir-length= D/full-length-dirs=
38	38	---> argparse -n prompt_pwd $options -- $argv
3	13	---> if set -q _flag_help...
10	10	----> set -q _flag_help
18	18	---> set -q argv[1]
15	15	---> set argv $PWD
7	7	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
7	7	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
41	411	---> for path in $argv...
128	159	----> set -l realhome (string escape --style=regex -- ~)
31	31	-----> string escape --style=regex -- ~
105	162	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
57	57	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	49	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
22	22	-----> test "$fish_prompt_pwd_dir_length" -eq 0
18	18	-----> echo $tmp
135	234221	--> fish_vcs_prompt
223	234086	---> fish_git_prompt $argv
13	59794	----> if not command -sq git...
59781	59781	-----> not command -sq git
5	73	----> if functions -q __fish_git_prompt_ready...
68	68	-----> functions -q __fish_git_prompt_ready
136	57446	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57310	57310	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
61	57645	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	57584	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	77	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	42	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
9	57367	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
6	57354	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
92	57348	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57256	57256	---------> command git symbolic-ref HEAD 2>/dev/null
2	15	------> if test true = $inside_gitdir...
13	13	-------> test true = $inside_gitdir
10	10	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
52307	58325	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6018	6018	-----> read -lz key value
6	40	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
11	73	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	14	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	6	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
1	12	-----> if set -q __fish_git_prompt_showupstream...
5	5	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	45	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
65	82	----> set b (string replace refs/heads/ '' -- $b)
17	17	-----> string replace refs/heads/ '' -- $b
2	29	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
27	27	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	34	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
8	8	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
26	26	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
11	720	> fish_title
7	709	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
10	688	--> if set -q argv[1]...
4	4	---> set -q argv[1]
47	53	---> set -l command (status current-command)
6	6	----> status current-command
3	20	---> if test "$command" = fish...
11	11	----> test "$command" = fish
6	6	----> set command
99	601	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
29	493	----> prompt_pwd -d 1 -D 1
10	10	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
3	3	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	385	-----> for path in $argv...
43	58	------> set -l realhome (string escape --style=regex -- ~)
15	15	-------> string escape --style=regex -- ~
41	66	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	247	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
11	160	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
44	125	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
41	81	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
40	40	----------> math $fish_prompt_pwd_full_dirs - 1
13	13	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
46	67	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
90	171	> __fish_disable_bracketed_paste ls
81	81	-> printf "\e[?2004l"
42	3136	> fish_title ls
30	3094	-> if not set -q INSIDE_EMACS...
33	33	--> not set -q INSIDE_EMACS
24	24	--> set -l ssh
16	16	--> set -q SSH_TTY
16	2991	--> if set -q argv[1]...
16	16	---> set -q argv[1]
506	2959	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
52	52	----> string sub -l 20 -- $argv[1]
136	2401	----> prompt_pwd -d 1 -D 1
48	48	-----> set -l options h/help d/dir-length= D/full-length-dirs=
101	101	-----> argparse -n prompt_pwd $options -- $argv
6	26	-----> if set -q _flag_help...
20	20	------> set -q _flag_help
16	16	-----> set -q argv[1]
29	29	-----> set argv $PWD
14	14	-----> set -ql _flag_d
30	30	-----> set -l fish_prompt_pwd_dir_length $_flag_d
15	15	-----> set -q fish_prompt_pwd_dir_length
18	18	-----> set -l fulldirs 0
13	13	-----> set -ql _flag_D
24	24	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
14	14	-----> set -q fish_prompt_pwd_full_dirs
68	1917	-----> for path in $argv...
171	220	------> set -l realhome (string escape --style=regex -- ~)
49	49	-------> string escape --style=regex -- ~
269	365	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
96	96	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
57	1264	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
54	54	-------> test "$fish_prompt_pwd_dir_length" -eq 0
22	22	-------> set -l full
39	839	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
25	25	--------> test $fish_prompt_pwd_full_dirs -gt 0
339	732	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
332	393	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
61	61	----------> math $fish_prompt_pwd_full_dirs - 1
28	28	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
225	292	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
67	67	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
81	82068	> ls
81987	81987	-> eza -lha $argv
24	56	> __fish_enable_bracketed_paste
32	32	-> printf "\e[?2004h"
10	52	> fish_mode_prompt
11	42	-> fish_default_mode_prompt
5	31	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
28	226744	> fish_prompt
13	13	-> set -l last_status $status
41	52	-> set -l normal (set_color normal)
11	11	--> set_color normal
51	59	-> set -l status_color (set_color brgreen)
8	8	--> set_color brgreen
49	59	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
35	42	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	77	-> if functions -q fish_is_root_user...
9	9	--> functions -q fish_is_root_user
14	65	--> fish_is_root_user
2	37	---> if test "$EUID" = 0 2>/dev/null...
35	35	----> test "$EUID" = 0 2>/dev/null
1	10	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
118	226373	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
20	351	--> prompt_login
2	6	---> if not set -q __fish_machine...
4	4	----> not set -q __fish_machine
2	5	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
222	307	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
6	6	----> set_color normal
21	21	----> set_color $color_host
13	40	----> prompt_hostname
27	27	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
22	230	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
2	2	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
19	151	---> for path in $argv...
37	48	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
45	66	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
10	225674	--> fish_vcs_prompt
96	225664	---> fish_git_prompt $argv
11	51232	----> if not command -sq git...
51221	51221	-----> not command -sq git
7	35	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
136	57193	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57057	57057	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
10	10	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
60	59942	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
37	59882	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
30	87	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
5	44	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
10	10	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
14	59650	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	59632	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
102	59629	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
59527	59527	---------> command git symbolic-ref HEAD 2>/dev/null
2	20	------> if test true = $inside_gitdir...
18	18	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
7	7	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
5	5	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
22	22	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50696	56589	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5893	5893	-----> read -lz key value
6	40	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	70	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	47	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
61	76	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
1	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	33	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
8	8	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
2	12	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
8	683	> fish_title
8	675	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
9	653	--> if set -q argv[1]...
3	3	---> set -q argv[1]
36	41	---> set -l command (status current-command)
5	5	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
67	588	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
6	6	----> string sub -l 20 -- $command
21	515	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
19	423	-----> for path in $argv...
50	60	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
58	91	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
33	33	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	253	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
10	152	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
53	121	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
52	68	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
55	78	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
23	23	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
58	102	> __fish_disable_bracketed_paste 'cd ..'
44	44	-> printf "\e[?2004l"
37	2251	> fish_title cd\ ..
23	2214	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
17	2140	--> if set -q argv[1]...
11	11	---> set -q argv[1]
335	2112	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
49	49	----> string sub -l 20 -- $argv[1]
89	1728	----> prompt_pwd -d 1 -D 1
41	41	-----> set -l options h/help d/dir-length= D/full-length-dirs=
66	66	-----> argparse -n prompt_pwd $options -- $argv
4	16	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
10	10	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
46	1402	-----> for path in $argv...
112	144	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
167	231	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
64	64	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
32	981	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
36	36	-------> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-------> set -l full
26	625	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
291	537	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
207	246	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
39	39	----------> math $fish_prompt_pwd_full_dirs - 1
28	28	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
196	272	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
76	76	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
204	1387	> cd ..
24	24	-> set -l MAX_DIR_HIST 25
9	428	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)...
265	419	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
109	109	---> count $argv
29	29	---> test "$argv[1]" = "--"
16	16	---> echo 1
6	20	-> if status --is-command-substitution...
14	14	--> status --is-command-substitution
33	33	-> set -l previous $PWD
5	20	-> if test "$argv" = -...
15	15	--> test "$argv" = -
128	408	-> builtin cd $argv
33	280	--> __update_cwd_osc VARIABLE SET PWD
8	32	---> if status --is-command-substitution...
13	13	----> status --is-command-substitution
11	11	----> set -q INSIDE_EMACS
188	215	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
27	27	----> string escape --style=url $PWD
26	26	-> set -l cd_status $status
54	211	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"...
46	46	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
15	15	--> set -q dirprev
16	16	--> set -q dirprev[$MAX_DIR_HIST]
10	10	--> set -U -q dirprev
28	28	--> set -g -a dirprev $previous
9	9	--> set -U -q dirnext
11	11	--> set -e dirnext
8	8	--> set -U -q __fish_cd_direction
14	14	--> set -g __fish_cd_direction prev
13	13	-> return $cd_status
24	50	> __fish_enable_bracketed_paste
26	26	-> printf "\e[?2004h"
21	112	> fish_mode_prompt
31	91	-> fish_default_mode_prompt
8	60	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
25	25	---> test "$fish_key_bindings" = fish_vi_key_bindings
27	27	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
95	241019	> fish_prompt
40	40	-> set -l last_status $status
230	259	-> set -l normal (set_color normal)
29	29	--> set_color normal
168	204	-> set -l status_color (set_color brgreen)
36	36	--> set_color brgreen
165	196	-> set -l cwd_color (set_color $fish_color_cwd)
31	31	--> set_color $fish_color_cwd
186	221	-> set -l vcs_color (set_color brpurple)
35	35	--> set_color brpurple
25	25	-> set -l prompt_status ""
14	14	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
15	15	-> set -l suffix '❯'
7	281	-> if functions -q fish_is_root_user...
28	28	--> functions -q fish_is_root_user
49	246	--> fish_is_root_user
6	121	---> if test "$EUID" = 0 2>/dev/null...
115	115	----> test "$EUID" = 0 2>/dev/null
3	66	---> if contains -- $USER root toor Administrator...
63	63	----> contains -- $USER root toor Administrator
10	10	---> return 1
3	24	-> if test $last_status -ne 0...
21	21	--> test $last_status -ne 0
309	239615	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
43	1233	--> prompt_login
4	18	---> if not set -q __fish_machine...
14	14	----> not set -q __fish_machine
8	118	---> if set -q __fish_machine[1]...
110	110	----> set -q __fish_machine[1]
30	30	---> set -l color_host $fish_color_host
2	11	---> if set -q SSH_TTY...
9	9	----> set -q SSH_TTY
792	1013	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
45	45	----> set_color $fish_color_user
32	32	----> set_color normal
26	26	----> set_color $color_host
36	88	----> prompt_hostname
52	52	-----> string replace -r -- "\..*" "" $hostname
30	30	----> set_color normal
53	690	--> prompt_pwd
23	23	---> set -l options h/help d/dir-length= D/full-length-dirs=
56	56	---> argparse -n prompt_pwd $options -- $argv
5	76	---> if set -q _flag_help...
71	71	----> set -q _flag_help
11	11	---> set -q argv[1]
16	16	---> set argv $PWD
8	8	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
8	8	---> set -q fish_prompt_pwd_full_dirs
11	11	---> set -l fish_prompt_pwd_full_dirs 1
45	402	---> for path in $argv...
118	152	----> set -l realhome (string escape --style=regex -- ~)
34	34	-----> string escape --style=regex -- ~
110	157	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
47	47	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	48	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
23	23	-----> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-----> echo $tmp
20	237383	--> fish_vcs_prompt
91	237363	---> fish_git_prompt $argv
13	63090	----> if not command -sq git...
63077	63077	-----> not command -sq git
2	29	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
129	57184	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57055	57055	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
57	58560	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	58503	-----> __fish_git_prompt_operation_branch_bare $repo_info
7	7	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
23	74	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	39	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
7	58291	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	58280	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
87	58277	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58190	58190	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
9	9	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
2	5	----> if not set -q ___fish_git_prompt_init...
3	3	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
3	3	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
51883	57842	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5959	5959	-----> read -lz key value
7	41	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
6	6	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
3	3	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	57	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	15	-----> if test -n "$$i"...
14	14	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
59	73	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
2	21	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
19	19	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
4	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
4	4	-----> set format " (%s)"
25	25	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
16	16	-> echo -n -s $status_color $suffix ' ' $normal
12	653	> fish_title
8	641	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
3	3	--> set -q SSH_TTY
6	617	--> if set -q argv[1]...
4	4	---> set -q argv[1]
39	45	---> set -l command (status current-command)
6	6	----> status current-command
2	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
5	5	----> set command
75	547	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
24	464	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
26	26	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
19	362	-----> for path in $argv...
51	62	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
54	85	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
31	31	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	196	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
6	116	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	92	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	53	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
39	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
74	142	> __fish_disable_bracketed_paste ls
68	68	-> printf "\e[?2004l"
35	1908	> fish_title ls
28	1873	-> if not set -q INSIDE_EMACS...
31	31	--> not set -q INSIDE_EMACS
24	24	--> set -l ssh
16	16	--> set -q SSH_TTY
14	1774	--> if set -q argv[1]...
16	16	---> set -q argv[1]
365	1744	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
42	42	----> string sub -l 20 -- $argv[1]
89	1337	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
66	66	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
18	18	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
38	1022	-----> for path in $argv...
148	181	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
134	199	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
65	65	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
20	604	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
12	12	-------> set -l full
17	349	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
115	281	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
130	166	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
129	195	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
66	66	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
88	83497	> ls
83409	83409	-> eza -lha $argv
23	52	> __fish_enable_bracketed_paste
29	29	-> printf "\e[?2004h"
11	56	> fish_mode_prompt
17	45	-> fish_default_mode_prompt
4	28	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
18	18	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
27	226163	> fish_prompt
12	12	-> set -l last_status $status
41	51	-> set -l normal (set_color normal)
10	10	--> set_color normal
35	44	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
37	47	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
34	41	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	82	-> if functions -q fish_is_root_user...
8	8	--> functions -q fish_is_root_user
18	72	--> fish_is_root_user
2	37	---> if test "$EUID" = 0 2>/dev/null...
35	35	----> test "$EUID" = 0 2>/dev/null
4	13	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
131	225820	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
15	369	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
2	5	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
2	6	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
242	329	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
14	14	----> set_color normal
11	11	----> set_color $color_host
14	45	----> prompt_hostname
31	31	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
27	239	--> prompt_pwd
9	9	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
14	152	---> for path in $argv...
41	53	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
43	67	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
10	225081	--> fish_vcs_prompt
83	225071	---> fish_git_prompt $argv
13	52404	----> if not command -sq git...
52391	52391	-----> not command -sq git
2	29	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
137	57142	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57005	57005	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
58	58023	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
48	57965	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
30	82	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
5	39	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
2	10	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
7	57733	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	57722	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
83	57719	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57636	57636	---------> command git symbolic-ref HEAD 2>/dev/null
3	17	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
3	3	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50940	56765	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5825	5825	-----> read -lz key value
7	38	----> if not set -q dirty[1]...
15	15	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
15	15	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
10	71	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
104	116	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
4	33	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
29	29	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	39	----> if test -n "$b"...
8	8	-----> test -n "$b"
9	9	-----> set b "$branch_color$b$branch_done"
3	17	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
8	8	----> set -l format $argv[1]
9	20	----> if test -z "$format"...
5	5	-----> test -z "$format"
6	6	-----> set format " (%s)"
30	30	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	574	> fish_title
6	565	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
8	544	--> if set -q argv[1]...
3	3	---> set -q argv[1]
36	42	---> set -l command (status current-command)
6	6	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
63	479	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
23	409	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	315	-----> for path in $argv...
39	50	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
38	61	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	191	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	113	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	91	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	51	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
40	59	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
46	642	> __fish_git_using_command upload-pack
72	524	-> set -l cmd (__fish_git_needs_command)
33	452	--> __fish_git_needs_command
77	130	---> set -l cmdline "$(commandline -c)"
53	53	----> commandline -c
3	9	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
11	11	---> set -g __fish_git_cmdline $cmdline
42	51	---> set -l cmd (commandline -opc)
9	9	----> commandline -opc
7	7	---> set -e cmd[1]
123	163	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
14	40	----> __fish_git_global_optspecs
26	26	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
9	33	---> if set -q argv[1]...
3	3	----> set -q argv[1]
10	10	----> set -g __fish_git_cmd $argv[1]
8	8	----> echo $argv[1]
3	3	----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
41	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	245	> __fish_git_using_command upload-archive
56	165	-> set -l cmd (__fish_git_needs_command)
8	109	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	41	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	229	> __fish_git_using_command shell
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	230	> __fish_git_using_command receive-pack
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
23	314	> __fish_git_using_command flow
71	169	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
4	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
11	11	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
76	92	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
16	16	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
26	302	> __fish_git_using_command cvsserver
60	198	-> set -l cmd (__fish_git_needs_command)
14	138	--> __fish_git_needs_command
66	74	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	50	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
6	23	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
46	55	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
12	112	> __fish_git_needs_command
57	64	-> set -l cmdline "$(commandline -c)"
7	7	--> commandline -c
6	36	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
8	8	--> test "$cmdline" = "$__fish_git_cmdline"
6	18	--> if set -q __fish_git_cmd[1]...
4	4	---> set -q __fish_git_cmd[1]
6	6	---> echo -- $__fish_git_cmd
2	2	---> return 1
58	134	> __fish_seen_subcommand_from branch for-each-ref tag
40	48	-> set -l cmd (commandline -poc)
8	8	--> commandline -poc
6	6	-> set -e cmd[1]
8	19	-> for i in $cmd...
3	11	--> if contains -- $i $argv...
8	8	---> contains -- $i $argv
3	3	-> return 1
19	240	> __fish_git_using_command for-each-ref
52	155	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
28	290	> __fish_git_using_command config
63	164	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
12	12	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
56	66	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
20	248	> __fish_git_using_command help
53	159	-> set -l cmd (__fish_git_needs_command)
8	106	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
42	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	294	> __fish_git_using_command blame
73	208	-> set -l cmd (__fish_git_needs_command)
26	135	--> __fish_git_needs_command
64	73	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
40	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	242	> __fish_git_using_command clean
52	159	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
40	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	346	> __fish_git_using_command submodule
102	259	-> set -l cmd (__fish_git_needs_command)
17	157	--> __fish_git_needs_command
84	95	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
7	45	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
14	14	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	233	> __fish_git_using_command format-patch
51	154	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command format-patch log
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	229	> __fish_git_using_command stash
50	149	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	222	> __fish_git_using_command worktree
50	147	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	223	> __fish_git_using_command update-index
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	222	> __fish_git_using_command tag
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	231	> __fish_git_using_command stripspace
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
4	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
25	359	> __fish_git_using_command status
78	200	-> set -l cmd (__fish_git_needs_command)
14	122	--> __fish_git_needs_command
63	71	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
73	95	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
22	22	--> string escape --style=var -- $cmd
22	22	-> set -q $varname
5	5	-> return 1
21	272	> __fish_git_using_command rm
59	163	-> set -l cmd (__fish_git_needs_command)
10	104	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
58	66	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
25	331	> __fish_git_using_command revert
93	244	-> set -l cmd (__fish_git_needs_command)
26	151	--> __fish_git_needs_command
77	86	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	39	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
22	315	> __fish_git_using_command rev-parse
71	192	-> set -l cmd (__fish_git_needs_command)
8	121	--> __fish_git_needs_command
72	79	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
12	12	-> contains -- $cmd $argv
63	71	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
17	250	> __fish_git_using_command restore switch
52	162	-> set -l cmd (__fish_git_needs_command)
10	110	--> __fish_git_needs_command
53	61	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	39	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
42	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
22	236	> __fish_git_using_command switch
53	155	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	224	> __fish_git_using_command restore
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	247	> __fish_git_using_command reset
73	170	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	220	> __fish_git_using_command reflog
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	227	> __fish_git_using_command rebase
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
20	268	> __fish_git_using_command push
50	178	-> set -l cmd (__fish_git_needs_command)
8	128	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	65	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	48	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
37	37	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
45	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
2	2	-> return 1
22	263	> __fish_git_using_command range-diff
56	159	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
50	60	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
3	3	-> return 1
20	249	> __fish_git_using_command pull
55	162	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	232	> __fish_git_using_command prune
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	231	> __fish_git_using_command notes
52	155	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
9	21	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	222	> __fish_git_using_command mv
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	223	> __fish_git_using_command mergetool
52	148	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	223	> __fish_git_using_command merge-base
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	223	> __fish_git_using_command merge
49	146	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	228	> __fish_git_using_command maintenance
49	149	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	222	> __fish_git_using_command mailsplit
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
23	237	> __fish_git_using_command mailsplit am
51	155	-> set -l cmd (__fish_git_needs_command)
10	104	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	223	> __fish_git_using_command mailinfo
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	221	> __fish_git_using_command mailinfo am
50	146	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
14	230	> __fish_git_using_command ls-files
53	155	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	250	> __fish_git_using_command log
65	162	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
41	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
15	230	> __fish_git_using_command init
51	154	-> set -l cmd (__fish_git_needs_command)
10	103	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
5	5	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
15	221	> __fish_git_using_command grep
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	232	> __fish_git_using_command gc
51	154	-> set -l cmd (__fish_git_needs_command)
11	103	--> __fish_git_needs_command
49	57	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	221	> __fish_git_using_command difftool
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	220	> __fish_git_using_command diff
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	229	> __fish_git_using_command describe
50	150	-> set -l cmd (__fish_git_needs_command)
10	100	--> __fish_git_needs_command
50	58	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
4	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	233	> __fish_git_using_command daemon
50	158	-> set -l cmd (__fish_git_needs_command)
13	108	--> __fish_git_needs_command
49	57	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	38	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	229	> __fish_git_using_command count-objects
51	153	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	220	> __fish_git_using_command commit
49	145	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	223	> __fish_git_using_command clone
50	149	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	222	> __fish_git_using_command cherry-pick
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	221	> __fish_git_using_command cherry
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
22	229	> __fish_git_using_command bundle
50	150	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
49	56	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	220	> __fish_git_using_command branch
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command bisect
50	151	-> set -l cmd (__fish_git_needs_command)
10	101	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	222	> __fish_git_using_command archive
50	148	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	227	> __fish_git_using_command apply
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	230	> __fish_git_using_command apply am
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	237	> __fish_git_using_command checkout
52	156	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
50	58	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
9	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
40	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	219	> __fish_git_using_command am
49	144	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
12	170	> __fish_git_using_command add
49	144	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
3	3	-> return 0
69	179651	> __fish_git_files modified untracked deleted unmerged modified-staged-deleted
69	58180	-> set -l root (__fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null)
71	58111	--> __fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null
11	11	---> set -l saved_args $argv
5	5	---> set -l global_args
35	45	---> set -l cmd (commandline -opc)
10	10	----> commandline -opc
6	6	---> set -e cmd[1]
9	311	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
101	136	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
13	35	-----> __fish_git_global_optspecs
22	22	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
40	157	----> set -l num_global_args (math (count $cmd) - (count $argv))
96	117	-----> math (count $cmd) - (count $argv)
14	14	------> count $cmd
7	7	------> count $argv
2	9	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
60	57662	---> eval command git $global_args \$saved_args 2>/dev/null
57602	57602	----> command git $saved_args
18	18	-> test "$root[2]" = true
7	7	-> set -e root[2]
14	14	-> contains -- all-staged $argv
7	7	-> contains -- unmerged $argv
5	5	-> set -l unmerged
6	6	-> set -l unmerged_desc "Unmerged File"
7	7	-> contains -- added $argv
3	3	-> set -ql all_staged
7	7	-> contains -- modified $argv
4	4	-> set -l modified
6	6	-> set -l modified_desc "Modified file"
6	6	-> contains -- untracked $argv
4	4	-> set -l untracked
5	5	-> set -l untracked_desc "Untracked file"
6	6	-> contains -- modified-staged $argv
3	3	-> set -ql all_staged
6	6	-> contains -- modified-staged-deleted $argv
5	5	-> set -l modified_staged_deleted
7	7	-> set -l modified_staged_deleted_desc "Staged modified and deleted file"
6	6	-> contains -- deleted $argv
4	4	-> set -l deleted
5	5	-> set -l deleted_desc "Deleted file"
6	6	-> contains -- deleted-staged $argv
3	3	-> set -ql all_staged
6	6	-> contains -- ignored $argv
6	6	-> contains -- renamed $argv
6	6	-> contains -- copied $argv
5	5	-> set -l q '\\?'
2	7	-> if status test-feature qmark-noglob...
5	5	--> status test-feature qmark-noglob
4	4	-> set -l use_next
5	5	-> set -l status_opt --ignore-submodules=all
3	3	-> set -q ignored
4	4	-> set -q untracked
5	5	-> set -a status_opt -uall
6	6	-> set -l git_opt -c status.relativePaths -c core.quotePath=
82	56925	-> set -l ver (__fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2')
108	56843	--> __fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2'
8	8	---> set -l saved_args $argv
4	4	---> set -l global_args
58	69	---> set -l cmd (commandline -opc)
11	11	----> commandline -opc
12	12	---> set -e cmd[1]
9	308	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
117	165	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
15	48	-----> __fish_git_global_optspecs
33	33	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
40	126	----> set -l num_global_args (math (count $cmd) - (count $argv))
67	86	-----> math (count $cmd) - (count $argv)
12	12	------> count $cmd
7	7	------> count $argv
1	8	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
53	56334	---> eval command git $global_args \$saved_args 2>/dev/null
56281	56281	----> command git $saved_args
67	64270	-> if test "$ver[1]" -gt 2 2>/dev/null...
43	43	--> test "$ver[1]" -gt 2 2>/dev/null
27	27	--> test "$ver[1]" -eq 2 -a "$ver[2]" -ge 11 2>/dev/null
301	64133	--> __fish_git $git_opt status --porcelain=2 $status_opt \
            | while read -la -d ' ' line
            set -l file
            set -l desc
            # The basic status format is "XY", where X is "our" state (meaning the staging area),
            # and "Y" is "their" state.
            # A "." means it's unmodified.
            switch "$line[1..2]"
                case 'u *'
                    # Unmerged
                    # "Unmerged entries have the following format; the first character is a "u" to distinguish from ordinary changed entries."
                    # "u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>"
                    # This is first to distinguish it from normal modifications et al.
                    set -ql unmerged
                    and set file "$line[11..-1]"
                    and set desc $unmerged_desc
                case '2 .R*' '2 R.*'
                    # Renamed/Copied
                    # From the docs: "Renamed or copied entries have the following format:"
                    # "2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>"
                    # Since <sep> is \t, we can't really parse it unambiguously.
                    # The "-z" format would be great here!
                    set -ql renamed
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    and set desc $renamed_desc
                case '2 RM*' '2 RT*'
                    # Staged as renamed, with unstaged modifications (issue #6031)
                    set -ql renamed
                    or set -ql modified
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql modified
                    and set --append desc $modified_desc
                case '2 RD*'
                    # Staged as renamed, but deleted in the worktree
                    set -ql renamed
                    or set -ql deleted
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql deleted
                    and set --append desc $deleted_desc
                case '2 .C*' '2 C.*'
                    set -ql copied
                    and set file (string replace -r '\t[^\t].*' '' -- "$line[10..-1]")
                    and set desc $copied_desc
                case '1 A.*'
                    # Additions are only shown here if they are staged.
                    # Otherwise it's an untracked file.
                    set -ql added
                    and set file "$line[9..-1]"
                    and set desc $added_desc
                case '1 AD*'
                    # Added files that were since deleted
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql deleted
                        set file "$line[9..-1]"
                        set desc $deleted_desc
                    end
                case "1 AM*" "1 AT*"
                    # Added files with additional modifications
                    # ("T" is type-changed. As of git 2.33 this appears to be undocumented.
                    # it happens when e.g. a file is replaced with a symlink.
                    # For our purposes it's the same as modified)
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    end
                case '1 .A*'
                    # Files added with git add --intent-to-add.
                    set -ql untracked
                    and set file "$line[9..-1]"
                    and set desc $untracked_desc
                case '1 .M*' '1 .T*'
                    # Modified
                    # From the docs: "Ordinary changed entries have the following format:"
                    # "1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>"
                    # Since <path> can contain spaces, print from element 9 onwards
                    set -ql modified
                    and set file "$line[9..-1]"
                    and set desc $modified_desc
                case '1 MD*' '1 TD*'
                    set -ql modified_staged_deleted
                    and set file "$line[9..-1]"
                    and set desc $modified_staged_deleted_desc
                case '1 M.*' '1 T.*'
                    # If the character is first ("M."), then that means it's "our" change,
                    # which means it is staged.
                    # This is useless for many commands - e.g. `checkout` won't do anything with this.
                    # So it needs to be requested explicitly.
                    set -ql modified_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_modified_desc
                case '1 MM*' '1 MT*' '1 TM*' '1 TT*'
                    # Staged-modified with unstaged modifications
                    # These need to be offered for both kinds of modified.
                    if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    else if set -ql modified_staged
                        set file "$line[9..-1]"
                        set desc $staged_modified_desc
                    end
                case '1 .D*'
                    set -ql deleted
                    and set file "$line[9..-1]"
                    and set desc $deleted_desc
                case '1 D.*'
                    # TODO: The docs are unclear on this.
                    # There is both X unmodified and Y either M or D ("not updated")
                    # and Y is D and X is unmodified or [MARC] ("deleted in work tree").
                    # For our purposes, we assume this is a staged deletion.
                    set -ql deleted_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_deleted_desc
                case "$q"' *'
                    # Untracked
                    # "? <path>" - print from element 2 on.
                    set -ql untracked
                    and set file "$line[2..-1]"
                    and set desc $untracked_desc
                case '! *'
                    # Ignored
                    # "! <path>" - print from element 2 on.
                    set -ql ignored
                    and set file "$line[2..-1]"
                    and set desc $ignored_desc
            end
            # Only try printing if the file was selected.
            if set -q file[1]
                for d in $desc
                    # Without "-z", git sometimes _quotes_ filenames.
                    # It adds quotes around it _and_ escapes the character.
                    # e.g. `"a\\b"`.
                    # We just remove the quotes and hope it works out.
                    # If this contains newlines or tabs,
                    # there is nothing we can do, but that's a general issue with scripted completions.
                    set file (string trim -c \" -- $file)
                    # The relative filename.
                    if string match -q './*' -- (commandline -ct)
                        printf './%s\t%s\n' $file $d
                    else
                        printf '%s\t%s\n' "$file" $d
                    end
                    # Now from repo root.
                    # Only do this if the filename isn't a simple child,
                    # or the current token starts with ":"
                    if string match -q '../*' -- $file
                        or string match -q ':*' -- (commandline -ct)
                        set -l fromroot (builtin realpath -- $file 2>/dev/null)
                        # `:` starts pathspec "magic", and the second `:` terminates it.
                        # `/` is the magic letter for "from repo root".
                        # If we didn't terminate it we'd have to escape any special chars
                        # (non-alphanumeric, glob or regex special characters, in whatever dialect git uses)
                        and set fromroot (string replace -- "$root/" ":/:" "$fromroot")
                        and printf '%s\t%s\n' "$fromroot" $d
                    end
                end
            end
        end
16	16	---> set -l saved_args $argv
6	6	---> set -l global_args
44	57	---> set -l cmd (commandline -opc)
13	13	----> commandline -opc
7	7	---> set -e cmd[1]
12	326	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
120	163	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
13	43	-----> __fish_git_global_optspecs
30	30	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
45	142	----> set -l num_global_args (math (count $cmd) - (count $argv))
74	97	-----> math (count $cmd) - (count $argv)
15	15	------> count $cmd
8	8	------> count $argv
1	9	----> if test $num_global_args -ne 0...
8	8	-----> test $num_global_args -ne 0
60	59767	---> eval command git $global_args \$saved_args 2>/dev/null
59707	59707	----> command git $saved_args
110	110	---> read -la -d ' ' line
8	8	---> set -l file
4	4	---> set -l desc
34	51	---> switch "$line[1..2]"...
4	4	----> set -ql modified
7	7	----> set file "$line[9..-1]"
6	6	----> set desc $modified_desc
9	205	---> if set -q file[1]...
4	4	----> set -q file[1]
9	192	----> for d in $desc...
51	63	-----> set file (string trim -c \" -- $file)
12	12	------> string trim -c \" -- $file
4	70	-----> if string match -q './*' -- (commandline -ct)...
38	51	------> string match -q './*' -- (commandline -ct)
13	13	-------> commandline -ct
15	15	------> printf '%s\t%s\n' "$file" $d
4	50	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
34	40	------> string match -q ':*' -- (commandline -ct)
6	6	-------> commandline -ct
98	98	---> read -la -d ' ' line
5	5	---> set -l file
3	3	---> set -l desc
33	48	---> switch "$line[1..2]"...
3	3	----> set -ql deleted
6	6	----> set file "$line[9..-1]"
6	6	----> set desc $deleted_desc
10	214	---> if set -q file[1]...
3	3	----> set -q file[1]
10	201	----> for d in $desc...
50	58	-----> set file (string trim -c \" -- $file)
8	8	------> string trim -c \" -- $file
4	81	-----> if string match -q './*' -- (commandline -ct)...
51	62	------> string match -q './*' -- (commandline -ct)
11	11	-------> commandline -ct
15	15	------> printf '%s\t%s\n' "$file" $d
3	52	-----> if string match -q '../*' -- $file...
7	7	------> string match -q '../*' -- $file
36	42	------> string match -q ':*' -- (commandline -ct)
6	6	-------> commandline -ct
102	102	---> read -la -d ' ' line
6	6	---> set -l file
3	3	---> set -l desc
36	51	---> switch "$line[1..2]"...
3	3	----> set -ql deleted
6	6	----> set file "$line[9..-1]"
6	6	----> set desc $deleted_desc
8	189	---> if set -q file[1]...
3	3	----> set -q file[1]
9	178	----> for d in $desc...
56	66	-----> set file (string trim -c \" -- $file)
10	10	------> string trim -c \" -- $file
4	57	-----> if string match -q './*' -- (commandline -ct)...
35	41	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
12	12	------> printf '%s\t%s\n' "$file" $d
2	46	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
33	38	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
96	96	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
35	48	---> switch "$line[1..2]"...
3	3	----> set -ql deleted
5	5	----> set file "$line[9..-1]"
5	5	----> set desc $deleted_desc
8	165	---> if set -q file[1]...
3	3	----> set -q file[1]
8	154	----> for d in $desc...
41	49	-----> set file (string trim -c \" -- $file)
8	8	------> string trim -c \" -- $file
3	53	-----> if string match -q './*' -- (commandline -ct)...
33	39	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
2	44	-----> if string match -q '../*' -- $file...
5	5	------> string match -q '../*' -- $file
32	37	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
92	92	---> read -la -d ' ' line
3	3	---> set -l file
3	3	---> set -l desc
36	49	---> switch "$line[1..2]"...
3	3	----> set -ql deleted
5	5	----> set file "$line[9..-1]"
5	5	----> set desc $deleted_desc
8	160	---> if set -q file[1]...
3	3	----> set -q file[1]
7	149	----> for d in $desc...
37	44	-----> set file (string trim -c \" -- $file)
7	7	------> string trim -c \" -- $file
4	53	-----> if string match -q './*' -- (commandline -ct)...
32	38	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
2	45	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
32	37	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
93	93	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
35	48	---> switch "$line[1..2]"...
3	3	----> set -ql deleted
5	5	----> set file "$line[9..-1]"
5	5	----> set desc $deleted_desc
7	156	---> if set -q file[1]...
3	3	----> set -q file[1]
8	146	----> for d in $desc...
36	43	-----> set file (string trim -c \" -- $file)
7	7	------> string trim -c \" -- $file
3	51	-----> if string match -q './*' -- (commandline -ct)...
32	38	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
10	10	------> printf '%s\t%s\n' "$file" $d
2	44	-----> if string match -q '../*' -- $file...
5	5	------> string match -q '../*' -- $file
32	37	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
91	91	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
26	39	---> switch "$line[1..2]"...
4	4	----> set -ql modified
4	4	----> set file "$line[9..-1]"
5	5	----> set desc $modified_desc
7	155	---> if set -q file[1]...
3	3	----> set -q file[1]
7	145	----> for d in $desc...
34	41	-----> set file (string trim -c \" -- $file)
7	7	------> string trim -c \" -- $file
3	52	-----> if string match -q './*' -- (commandline -ct)...
33	38	------> string match -q './*' -- (commandline -ct)
5	5	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
1	45	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
33	38	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
98	98	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
23	38	---> switch "$line[1..2]"...
4	4	----> set -ql modified
6	6	----> set file "$line[9..-1]"
5	5	----> set desc $modified_desc
7	155	---> if set -q file[1]...
3	3	----> set -q file[1]
7	145	----> for d in $desc...
34	42	-----> set file (string trim -c \" -- $file)
8	8	------> string trim -c \" -- $file
3	51	-----> if string match -q './*' -- (commandline -ct)...
32	38	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
10	10	------> printf '%s\t%s\n' "$file" $d
3	45	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
32	36	------> string match -q ':*' -- (commandline -ct)
4	4	-------> commandline -ct
101	101	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
34	46	---> switch "$line[1..2]"...
3	3	----> set -ql deleted
5	5	----> set file "$line[9..-1]"
4	4	----> set desc $deleted_desc
8	221	---> if set -q file[1]...
3	3	----> set -q file[1]
9	210	----> for d in $desc...
52	60	-----> set file (string trim -c \" -- $file)
8	8	------> string trim -c \" -- $file
5	87	-----> if string match -q './*' -- (commandline -ct)...
54	65	------> string match -q './*' -- (commandline -ct)
11	11	-------> commandline -ct
17	17	------> printf '%s\t%s\n' "$file" $d
3	54	-----> if string match -q '../*' -- $file...
7	7	------> string match -q '../*' -- $file
38	44	------> string match -q ':*' -- (commandline -ct)
6	6	-------> commandline -ct
106	106	---> read -la -d ' ' line
6	6	---> set -l file
4	4	---> set -l desc
37	60	---> switch "$line[1..2]"...
4	4	----> set -ql deleted
13	13	----> set file "$line[9..-1]"
6	6	----> set desc $deleted_desc
7	178	---> if set -q file[1]...
4	4	----> set -q file[1]
10	167	----> for d in $desc...
41	51	-----> set file (string trim -c \" -- $file)
10	10	------> string trim -c \" -- $file
3	59	-----> if string match -q './*' -- (commandline -ct)...
36	43	------> string match -q './*' -- (commandline -ct)
7	7	-------> commandline -ct
13	13	------> printf '%s\t%s\n' "$file" $d
2	47	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
33	39	------> string match -q ':*' -- (commandline -ct)
6	6	-------> commandline -ct
91	91	---> read -la -d ' ' line
5	5	---> set -l file
3	3	---> set -l desc
27	41	---> switch "$line[1..2]"...
4	4	----> set -ql modified
5	5	----> set file "$line[9..-1]"
5	5	----> set desc $modified_desc
9	162	---> if set -q file[1]...
3	3	----> set -q file[1]
7	150	----> for d in $desc...
36	44	-----> set file (string trim -c \" -- $file)
8	8	------> string trim -c \" -- $file
3	54	-----> if string match -q './*' -- (commandline -ct)...
33	40	------> string match -q './*' -- (commandline -ct)
7	7	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
2	45	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
32	37	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
8	8	---> read -la -d ' ' line
22	268	> __fish_git_using_command show-branch
57	174	-> set -l cmd (__fish_git_needs_command)
11	117	--> __fish_git_needs_command
56	64	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	42	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
42	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
21	231	> __fish_git_using_command show
51	151	-> set -l cmd (__fish_git_needs_command)
10	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
7	255	> __fish_git_needs_rev_files
34	248	-> __fish_git_using_command show
55	155	--> set -l cmd (__fish_git_needs_command)
9	100	---> __fish_git_needs_command
52	58	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
6	33	----> if set -q __fish_git_cmdline...
3	3	-----> set -q __fish_git_cmdline
7	7	-----> test "$cmdline" = "$__fish_git_cmdline"
6	17	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
5	5	------> echo -- $__fish_git_cmd
3	3	------> return 1
5	5	--> test -z "$cmd"
6	6	--> contains -- $cmd $argv
35	41	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	---> string escape --style=var -- $cmd
5	5	--> set -q $varname
2	2	--> return 1
17	225	> __fish_git_using_command remote
51	149	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	226	> __fish_git_using_command filter-branch
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	225	> __fish_git_using_command fetch
52	150	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
4	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	237	> __fish_git_using_command fetch pull
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
41	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	227	> __fish_git_using_command diff log show range-diff
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	223	> __fish_git_using_command diff show range-diff
50	146	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
4	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	223	> __fish_git_using_command diff show range-diff apply
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command log show diff-tree rev-list
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
53	58	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
4	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
26	43	> __fish_disable_bracketed_paste 'git add .gitignore '
17	17	-> printf "\e[?2004l"
15	942	> fish_title git\ add\ .gitignore\ 
10	927	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
4	898	--> if set -q argv[1]...
4	4	---> set -q argv[1]
183	890	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
39	39	----> string sub -l 20 -- $argv[1]
67	668	----> prompt_pwd -d 1 -D 1
14	14	-----> set -l options h/help d/dir-length= D/full-length-dirs=
30	30	-----> argparse -n prompt_pwd $options -- $argv
2	7	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
3	3	-----> set -q argv[1]
9	9	-----> set argv $PWD
4	4	-----> set -ql _flag_d
10	10	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
6	6	-----> set -l fulldirs 0
4	4	-----> set -ql _flag_D
9	9	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
4	4	-----> set -q fish_prompt_pwd_full_dirs
37	497	-----> for path in $argv...
102	127	------> set -l realhome (string escape --style=regex -- ~)
25	25	-------> string escape --style=regex -- ~
51	83	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
32	32	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	250	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
8	149	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
60	122	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
47	62	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
53	77	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
24	24	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
63724	63724	> git add .gitignore
34	72	> __fish_enable_bracketed_paste
38	38	-> printf "\e[?2004h"
14	61	> fish_mode_prompt
16	47	-> fish_default_mode_prompt
3	31	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
22	22	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
51	242117	> fish_prompt
20	20	-> set -l last_status $status
112	125	-> set -l normal (set_color normal)
13	13	--> set_color normal
68	81	-> set -l status_color (set_color brgreen)
13	13	--> set_color brgreen
97	122	-> set -l cwd_color (set_color $fish_color_cwd)
25	25	--> set_color $fish_color_cwd
117	133	-> set -l vcs_color (set_color brpurple)
16	16	--> set_color brpurple
10	10	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
5	97	-> if functions -q fish_is_root_user...
13	13	--> functions -q fish_is_root_user
15	79	--> fish_is_root_user
3	46	---> if test "$EUID" = 0 2>/dev/null...
43	43	----> test "$EUID" = 0 2>/dev/null
4	14	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
188	241442	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
25	511	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
350	462	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
13	13	----> set_color normal
11	11	----> set_color $color_host
26	67	----> prompt_hostname
41	41	-----> string replace -r -- "\..*" "" $hostname
9	9	----> set_color normal
31	370	--> prompt_pwd
9	9	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
6	6	---> set -l fish_prompt_pwd_full_dirs 1
33	280	---> for path in $argv...
68	82	----> set -l realhome (string escape --style=regex -- ~)
14	14	-----> string escape --style=regex -- ~
96	132	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
36	36	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	33	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
15	15	-----> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-----> echo $tmp
14	240373	--> fish_vcs_prompt
91	240359	---> fish_git_prompt $argv
10	58587	----> if not command -sq git...
58577	58577	-----> not command -sq git
3	30	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
129	61500	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
61371	61371	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
12	12	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
8	8	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
62	59889	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	59827	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
3	3	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
5	5	------> set -l total
24	98	------> if test -d $git_dir/rebase-merge...
20	20	-------> test -d $git_dir/rebase-merge
6	54	-------> if test -d $git_dir/rebase-apply...
10	10	--------> test -d $git_dir/rebase-apply
10	10	--------> test -f $git_dir/MERGE_HEAD
9	9	--------> test -f $git_dir/CHERRY_PICK_HEAD
8	8	--------> test -f $git_dir/REVERT_HEAD
11	11	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
9	59579	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	59566	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
97	59564	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
59467	59467	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
19	19	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
53598	59613	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6015	6015	-----> read -lz key value
6	41	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
10	73	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
101	113	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
5	37	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
32	32	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
9	45	----> if test -n "$b"...
8	8	-----> test -n "$b"
9	9	-----> set b "$branch_color$b$branch_done"
4	19	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
8	8	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
8	8	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
6	6	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
10	700	> fish_title
9	690	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
7	668	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
2	13	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
86	601	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
28	506	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
19	405	-----> for path in $argv...
59	71	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
56	88	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
32	32	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
10	227	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
13	13	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
10	132	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
46	104	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	58	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
48	67	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
72	123	> __fish_disable_bracketed_paste 'git commit -m "changed: ff config to gitignore"'
51	51	-> printf "\e[?2004l"
57	1937	> fish_title git\ commit\ -m\ \"changed:\ ff\ config\ to\ gitignore\"
24	1880	-> if not set -q INSIDE_EMACS...
28	28	--> not set -q INSIDE_EMACS
18	18	--> set -l ssh
11	11	--> set -q SSH_TTY
12	1799	--> if set -q argv[1]...
11	11	---> set -q argv[1]
325	1776	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
34	34	----> string sub -l 20 -- $argv[1]
107	1417	----> prompt_pwd -d 1 -D 1
31	31	-----> set -l options h/help d/dir-length= D/full-length-dirs=
68	68	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
28	28	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
43	1073	-----> for path in $argv...
137	169	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
124	205	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
81	81	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
28	656	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
17	330	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
113	263	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
115	150	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
35	35	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
14	14	--------> set full $all[2..]
202	256	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
54	54	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
91864	91864	> git commit -m "changed: ff config to gitignore"
25	58	> __fish_enable_bracketed_paste
33	33	-> printf "\e[?2004h"
11	52	> fish_mode_prompt
10	41	-> fish_default_mode_prompt
4	31	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
22	22	---> test "$fish_key_bindings" = fish_vi_key_bindings
5	5	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
111	231624	> fish_prompt
49	49	-> set -l last_status $status
159	171	-> set -l normal (set_color normal)
12	12	--> set_color normal
179	194	-> set -l status_color (set_color brgreen)
15	15	--> set_color brgreen
50	104	-> set -l cwd_color (set_color $fish_color_cwd)
54	54	--> set_color $fish_color_cwd
137	145	-> set -l vcs_color (set_color brpurple)
8	8	--> set_color brpurple
8	8	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
48	48	-> set -lx fish_prompt_pwd_dir_length 0
16	16	-> set -l suffix '❯'
2	89	-> if functions -q fish_is_root_user...
13	13	--> functions -q fish_is_root_user
17	74	--> fish_is_root_user
2	40	---> if test "$EUID" = 0 2>/dev/null...
38	38	----> test "$EUID" = 0 2>/dev/null
3	14	---> if contains -- $USER root toor Administrator...
11	11	----> contains -- $USER root toor Administrator
3	3	---> return 1
2	9	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
194	230663	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
23	518	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
2	5	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
299	470	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
16	16	----> set_color $fish_color_user
11	11	----> set_color normal
9	9	----> set_color $color_host
28	123	----> prompt_hostname
95	95	-----> string replace -r -- "\..*" "" $hostname
12	12	----> set_color normal
33	449	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
17	17	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
3	3	---> set -q argv[1]
8	8	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
33	347	---> for path in $argv...
116	131	----> set -l realhome (string escape --style=regex -- ~)
15	15	-----> string escape --style=regex -- ~
92	134	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
42	42	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	49	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
16	16	-----> test "$fish_prompt_pwd_dir_length" -eq 0
26	26	-----> echo $tmp
32	229502	--> fish_vcs_prompt
95	229470	---> fish_git_prompt $argv
10	52476	----> if not command -sq git...
52466	52466	-----> not command -sq git
1	25	----> if functions -q __fish_git_prompt_ready...
24	24	-----> functions -q __fish_git_prompt_ready
133	59835	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
59702	59702	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
61	58401	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	58340	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
23	97	------> if test -d $git_dir/rebase-merge...
17	17	-------> test -d $git_dir/rebase-merge
10	57	-------> if test -d $git_dir/rebase-apply...
10	10	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
9	9	--------> test -f $git_dir/REVERT_HEAD
10	10	--------> test -f $git_dir/BISECT_LOG
1	15	------> if test -n "$step" -a -n "$total"...
14	14	-------> test -n "$step" -a -n "$total"
10	58092	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
4	58077	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
118	58073	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57955	57955	---------> command git symbolic-ref HEAD 2>/dev/null
1	17	------> if test true = $inside_gitdir...
16	16	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
5	5	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
20	20	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
51952	58045	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6093	6093	-----> read -lz key value
7	43	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
16	16	----> contains dirtystate $__fish_git_prompt_status_order
3	16	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
9	9	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	77	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	49	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
5	14	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	17	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
3	9	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	47	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
60	73	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
1	28	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
27	27	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	35	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
5	18	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
26	26	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	672	> fish_title
9	663	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
7	641	--> if set -q argv[1]...
3	3	---> set -q argv[1]
35	42	---> set -l command (status current-command)
7	7	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
65	576	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
23	504	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
8	8	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
20	409	-----> for path in $argv...
50	61	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
59	96	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
37	37	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	232	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
12	12	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
8	142	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
56	116	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
18	18	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
45	65	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
24	73	> __fish_disable_bracketed_paste 'git push'
49	49	-> printf "\e[?2004l"
57	1654	> fish_title git\ push
7	1597	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
5	1571	--> if set -q argv[1]...
3	3	---> set -q argv[1]
273	1563	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
50	50	----> string sub -l 20 -- $argv[1]
67	1240	----> prompt_pwd -d 1 -D 1
12	12	-----> set -l options h/help d/dir-length= D/full-length-dirs=
75	75	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
45	45	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
78	1003	-----> for path in $argv...
106	135	------> set -l realhome (string escape --style=regex -- ~)
29	29	-------> string escape --style=regex -- ~
191	261	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
70	70	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
16	529	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
43	241	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
68	177	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
94	109	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
10	10	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
149	256	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
107	107	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
12713584	12713584	> git push
51	181	> __fish_enable_bracketed_paste
130	130	-> printf "\e[?2004h"
45	222	> fish_mode_prompt
100	177	-> fish_default_mode_prompt
13	77	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
49	49	---> test "$fish_key_bindings" = fish_vi_key_bindings
15	15	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
84	240865	> fish_prompt
41	41	-> set -l last_status $status
126	210	-> set -l normal (set_color normal)
84	84	--> set_color normal
143	165	-> set -l status_color (set_color brgreen)
22	22	--> set_color brgreen
140	172	-> set -l cwd_color (set_color $fish_color_cwd)
32	32	--> set_color $fish_color_cwd
133	153	-> set -l vcs_color (set_color brpurple)
20	20	--> set_color brpurple
19	19	-> set -l prompt_status ""
11	11	-> set -q fish_prompt_pwd_dir_length
11	11	-> set -lx fish_prompt_pwd_dir_length 0
12	12	-> set -l suffix '❯'
4	361	-> if functions -q fish_is_root_user...
151	151	--> functions -q fish_is_root_user
39	206	--> fish_is_root_user
6	93	---> if test "$EUID" = 0 2>/dev/null...
87	87	----> test "$EUID" = 0 2>/dev/null
4	65	---> if contains -- $USER root toor Administrator...
61	61	----> contains -- $USER root toor Administrator
9	9	---> return 1
2	18	-> if test $last_status -ne 0...
16	16	--> test $last_status -ne 0
327	239596	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
102	1449	--> prompt_login
4	16	---> if not set -q __fish_machine...
12	12	----> not set -q __fish_machine
4	12	---> if set -q __fish_machine[1]...
8	8	----> set -q __fish_machine[1]
19	19	---> set -l color_host $fish_color_host
3	10	---> if set -q SSH_TTY...
7	7	----> set -q SSH_TTY
828	1290	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
42	42	----> set_color $fish_color_user
37	37	----> set_color normal
46	46	----> set_color $color_host
241	308	----> prompt_hostname
67	67	-----> string replace -r -- "\..*" "" $hostname
29	29	----> set_color normal
256	966	--> prompt_pwd
30	30	---> set -l options h/help d/dir-length= D/full-length-dirs=
79	79	---> argparse -n prompt_pwd $options -- $argv
4	18	---> if set -q _flag_help...
14	14	----> set -q _flag_help
9	9	---> set -q argv[1]
17	17	---> set argv $PWD
8	8	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
12	12	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
8	8	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
44	505	---> for path in $argv...
221	249	----> set -l realhome (string escape --style=regex -- ~)
28	28	-----> string escape --style=regex -- ~
98	148	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
50	50	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
21	64	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
19	19	-----> test "$fish_prompt_pwd_dir_length" -eq 0
24	24	-----> echo $tmp
93	236854	--> fish_vcs_prompt
138	236761	---> fish_git_prompt $argv
10	60646	----> if not command -sq git...
60636	60636	-----> not command -sq git
2	93	----> if functions -q __fish_git_prompt_ready...
91	91	-----> functions -q __fish_git_prompt_ready
134	57170	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57036	57036	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
9	9	----> set -l sha $repo_info[5]
59	57005	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	56946	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
31	82	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	40	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
11	56716	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	56701	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
90	56697	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56607	56607	---------> command git symbolic-ref HEAD 2>/dev/null
2	17	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
5	5	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
9	9	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
6	6	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
20	20	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
54931	61124	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6193	6193	-----> read -lz key value
9	47	----> if not set -q dirty[1]...
20	20	-----> not set -q dirty[1]
18	18	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
4	16	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	47	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
58	72	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
1	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	34	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	684	> fish_title
8	675	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
3	3	--> set -q SSH_TTY
6	653	--> if set -q argv[1]...
4	4	---> set -q argv[1]
38	43	---> set -l command (status current-command)
5	5	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
64	588	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
26	516	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
20	20	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	423	-----> for path in $argv...
38	48	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
38	62	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
13	301	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
26	26	-------> test "$fish_prompt_pwd_dir_length" -eq 0
18	18	-------> set -l full
12	175	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
10	10	--------> test $fish_prompt_pwd_full_dirs -gt 0
49	141	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
46	92	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
46	46	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	69	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
26	26	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
79	159	> __fish_disable_bracketed_paste ls
80	80	-> printf "\e[?2004l"
46	3584	> fish_title ls
33	3538	-> if not set -q INSIDE_EMACS...
39	39	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
27	27	--> set -q SSH_TTY
34	3414	--> if set -q argv[1]...
16	16	---> set -q argv[1]
572	3364	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
51	51	----> string sub -l 20 -- $argv[1]
178	2741	----> prompt_pwd -d 1 -D 1
49	49	-----> set -l options h/help d/dir-length= D/full-length-dirs=
100	100	-----> argparse -n prompt_pwd $options -- $argv
7	26	-----> if set -q _flag_help...
19	19	------> set -q _flag_help
15	15	-----> set -q argv[1]
28	28	-----> set argv $PWD
14	14	-----> set -ql _flag_d
30	30	-----> set -l fish_prompt_pwd_dir_length $_flag_d
16	16	-----> set -q fish_prompt_pwd_dir_length
18	18	-----> set -l fulldirs 0
13	13	-----> set -ql _flag_D
24	24	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
13	13	-----> set -q fish_prompt_pwd_full_dirs
72	2217	-----> for path in $argv...
226	274	------> set -l realhome (string escape --style=regex -- ~)
48	48	-------> string escape --style=regex -- ~
270	383	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
113	113	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
70	1488	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
52	52	-------> test "$fish_prompt_pwd_dir_length" -eq 0
22	22	-------> set -l full
43	920	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
26	26	--------> test $fish_prompt_pwd_full_dirs -gt 0
308	789	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
329	481	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
152	152	----------> math $fish_prompt_pwd_full_dirs - 1
39	39	--------> set tmp $all[1]
23	23	--------> set full $all[2..]
298	424	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
126	126	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
86	82575	> ls
82489	82489	-> eza -lha $argv
27	60	> __fish_enable_bracketed_paste
33	33	-> printf "\e[?2004h"
13	61	> fish_mode_prompt
15	48	-> fish_default_mode_prompt
4	33	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
24	222527	> fish_prompt
14	14	-> set -l last_status $status
46	59	-> set -l normal (set_color normal)
13	13	--> set_color normal
36	45	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
35	45	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
35	42	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
1	75	-> if functions -q fish_is_root_user...
9	9	--> functions -q fish_is_root_user
14	65	--> fish_is_root_user
2	37	---> if test "$EUID" = 0 2>/dev/null...
35	35	----> test "$EUID" = 0 2>/dev/null
2	11	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
3	3	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
119	222184	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
20	273	--> prompt_login
3	8	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
158	228	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
13	39	----> prompt_hostname
26	26	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
20	215	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
14	137	---> for path in $argv...
38	48	----> set -l realhome (string escape --style=regex -- ~)
10	10	-----> string escape --style=regex -- ~
37	58	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
12	221577	--> fish_vcs_prompt
95	221565	---> fish_git_prompt $argv
13	50596	----> if not command -sq git...
50583	50583	-----> not command -sq git
4	44	----> if functions -q __fish_git_prompt_ready...
40	40	-----> functions -q __fish_git_prompt_ready
143	56334	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56191	56191	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
58	57267	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
44	57209	-----> __fish_git_prompt_operation_branch_bare $repo_info
16	16	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
24	76	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
9	41	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
6	6	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
9	56980	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56967	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
90	56965	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56875	56875	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
10	10	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
9	9	----> set -q __fish_git_prompt_status_order
3	8	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
20	20	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50781	56646	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5865	5865	-----> read -lz key value
9	43	----> if not set -q dirty[1]...
15	15	-----> not set -q dirty[1]
19	19	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	74	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	46	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
5	17	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
4	4	----> set -l f ""
18	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
58	75	----> set b (string replace refs/heads/ '' -- $b)
17	17	-----> string replace refs/heads/ '' -- $b
3	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
9	561	> fish_title
7	552	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
6	531	--> if set -q argv[1]...
3	3	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
63	469	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
23	399	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
8	8	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	305	-----> for path in $argv...
37	48	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
37	57	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	187	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	112	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	90	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	54	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
40	57	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
29	46	> __fish_disable_bracketed_paste 'git status'
17	17	-> printf "\e[?2004l"
12	664	> fish_title git\ status
7	652	-> if not set -q INSIDE_EMACS...
10	10	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
8	625	--> if set -q argv[1]...
4	4	---> set -q argv[1]
84	613	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
11	11	----> string sub -l 20 -- $argv[1]
27	518	----> prompt_pwd -d 1 -D 1
10	10	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
3	6	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
18	412	-----> for path in $argv...
40	51	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
38	66	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
28	28	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	277	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
9	150	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
49	116	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
54	67	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
14	14	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
54	103	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
49	49	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
65871	65871	> git status
29	66	> __fish_enable_bracketed_paste
37	37	-> printf "\e[?2004h"
11	61	> fish_mode_prompt
14	50	-> fish_default_mode_prompt
6	36	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
24	24	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
44	225110	> fish_prompt
21	21	-> set -l last_status $status
51	66	-> set -l normal (set_color normal)
15	15	--> set_color normal
40	49	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
39	49	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
34	41	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	92	-> if functions -q fish_is_root_user...
19	19	--> functions -q fish_is_root_user
13	71	--> fish_is_root_user
3	43	---> if test "$EUID" = 0 2>/dev/null...
40	40	----> test "$EUID" = 0 2>/dev/null
1	11	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
145	224703	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
15	269	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
160	232	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
14	40	----> prompt_hostname
26	26	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
22	219	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
2	5	---> if set -q _flag_help...
3	3	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
15	139	---> for path in $argv...
38	49	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
37	58	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
15	224070	--> fish_vcs_prompt
123	224055	---> fish_git_prompt $argv
9	51572	----> if not command -sq git...
51563	51563	-----> not command -sq git
8	32	----> if functions -q __fish_git_prompt_ready...
24	24	-----> functions -q __fish_git_prompt_ready
131	58153	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58022	58022	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
12	12	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
61	56911	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
50	56850	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
3	3	------> set -l total
27	79	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	40	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
6	6	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
2	10	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	56616	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
6	56604	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
90	56598	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56508	56508	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
7	7	----> set -l untracked
50463	56422	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5959	5959	-----> read -lz key value
12	61	----> if not set -q dirty[1]...
25	25	-----> not set -q dirty[1]
24	24	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
51	51	----> contains dirtystate $__fish_git_prompt_status_order
7	33	----> if not set -q untracked[1]...
11	11	-----> not set -q untracked[1]
15	15	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
16	16	----> contains untrackedfiles $__fish_git_prompt_status_order
9	78	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	50	-----> if test "$informative" = true...
8	8	------> test "$informative" = true
2	11	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
2	10	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
8	8	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
6	6	----> set -l f ""
22	52	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
3	7	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
84	101	----> set b (string replace refs/heads/ '' -- $b)
17	17	-----> string replace refs/heads/ '' -- $b
9	64	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
55	55	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
8	59	----> if test -n "$b"...
15	15	-----> test -n "$b"
12	12	-----> set b "$branch_color$b$branch_done"
3	24	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
10	10	------> test -z "$dirtystate$untrackedfiles$stagedstate"
11	11	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	6	----> if test -n "$p"...
5	5	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
24	24	----> set -l format $argv[1]
6	30	----> if test -z "$format"...
14	14	-----> test -z "$format"
10	10	-----> set format " (%s)"
69	69	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
17	17	-> echo -n -s $status_color $suffix ' ' $normal
10	624	> fish_title
9	614	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	589	--> if set -q argv[1]...
4	4	---> set -q argv[1]
40	47	---> set -l command (status current-command)
7	7	----> status current-command
3	14	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
72	519	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
26	440	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	342	-----> for path in $argv...
37	48	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
39	66	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	216	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	115	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
38	90	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
37	52	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
64	82	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
45	706	> __fish_git_using_command upload-pack
70	587	-> set -l cmd (__fish_git_needs_command)
39	517	--> __fish_git_needs_command
78	131	---> set -l cmdline "$(commandline -c)"
53	53	----> commandline -c
4	22	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
13	13	----> test "$cmdline" = "$__fish_git_cmdline"
10	10	---> set -g __fish_git_cmdline $cmdline
59	66	---> set -l cmd (commandline -opc)
7	7	----> commandline -opc
11	11	---> set -e cmd[1]
140	187	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
17	47	----> __fish_git_global_optspecs
30	30	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
4	4	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
8	35	---> if set -q argv[1]...
3	3	----> set -q argv[1]
12	12	----> set -g __fish_git_cmd $argv[1]
8	8	----> echo $argv[1]
4	4	----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
43	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	244	> __fish_git_using_command upload-archive
54	162	-> set -l cmd (__fish_git_needs_command)
9	108	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	228	> __fish_git_using_command shell
51	151	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	228	> __fish_git_using_command receive-pack
51	152	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	222	> __fish_git_using_command flow
50	147	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	256	> __fish_git_using_command cvsserver
61	168	-> set -l cmd (__fish_git_needs_command)
10	107	--> __fish_git_needs_command
54	59	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
11	104	> __fish_git_needs_command
52	59	-> set -l cmdline "$(commandline -c)"
7	7	--> commandline -c
5	34	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
8	8	--> test "$cmdline" = "$__fish_git_cmdline"
5	17	--> if set -q __fish_git_cmd[1]...
4	4	---> set -q __fish_git_cmd[1]
5	5	---> echo -- $__fish_git_cmd
3	3	---> return 1
58	151	> __fish_seen_subcommand_from branch for-each-ref tag
55	62	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
6	6	-> set -e cmd[1]
11	22	-> for i in $cmd...
2	11	--> if contains -- $i $argv...
9	9	---> contains -- $i $argv
3	3	-> return 1
20	293	> __fish_git_using_command for-each-ref
56	207	-> set -l cmd (__fish_git_needs_command)
8	151	--> __fish_git_needs_command
99	107	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
17	232	> __fish_git_using_command config
51	153	-> set -l cmd (__fish_git_needs_command)
10	102	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	233	> __fish_git_using_command help
52	156	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	225	> __fish_git_using_command blame
50	150	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	222	> __fish_git_using_command clean
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
20	228	> __fish_git_using_command submodule
49	150	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	227	> __fish_git_using_command format-patch
54	152	-> set -l cmd (__fish_git_needs_command)
10	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	224	> __fish_git_using_command format-patch log
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	220	> __fish_git_using_command stash
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	226	> __fish_git_using_command worktree
50	151	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
5	5	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	219	> __fish_git_using_command update-index
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
4	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
27	294	> __fish_git_using_command tag
73	177	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	40	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
10	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
10	10	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
49	60	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
24	309	> __fish_git_using_command stripspace
62	204	-> set -l cmd (__fish_git_needs_command)
15	142	--> __fish_git_needs_command
71	79	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	48	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
6	22	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
46	58	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
12	12	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	250	> __fish_git_using_command status
54	164	-> set -l cmd (__fish_git_needs_command)
10	110	--> __fish_git_needs_command
54	64	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	231	> __fish_git_using_command rm
51	151	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	225	> __fish_git_using_command revert
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	233	> __fish_git_using_command rev-parse
51	157	-> set -l cmd (__fish_git_needs_command)
9	106	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
4	40	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
12	25	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	224	> __fish_git_using_command restore switch
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	223	> __fish_git_using_command switch
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	219	> __fish_git_using_command restore
49	145	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	219	> __fish_git_using_command reset
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	224	> __fish_git_using_command reflog
50	149	-> set -l cmd (__fish_git_needs_command)
10	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	219	> __fish_git_using_command rebase
49	144	-> set -l cmd (__fish_git_needs_command)
7	95	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	222	> __fish_git_using_command push
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	229	> __fish_git_using_command range-diff
50	154	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	221	> __fish_git_using_command pull
49	146	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	221	> __fish_git_using_command prune
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	224	> __fish_git_using_command notes
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
4	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	219	> __fish_git_using_command mv
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	221	> __fish_git_using_command mergetool
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
8	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
2	2	-> return 1
16	221	> __fish_git_using_command merge-base
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	217	> __fish_git_using_command merge
49	144	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	218	> __fish_git_using_command maintenance
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	224	> __fish_git_using_command mailsplit
49	144	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
41	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
5	5	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	222	> __fish_git_using_command mailsplit am
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	232	> __fish_git_using_command mailinfo
50	157	-> set -l cmd (__fish_git_needs_command)
8	107	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
16	43	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	252	> __fish_git_using_command mailinfo am
55	171	-> set -l cmd (__fish_git_needs_command)
10	116	--> __fish_git_needs_command
63	68	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	38	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
22	300	> __fish_git_using_command ls-files
57	198	-> set -l cmd (__fish_git_needs_command)
11	141	--> __fish_git_needs_command
81	88	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	42	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
7	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
49	57	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
3	3	-> return 1
19	248	> __fish_git_using_command log
56	163	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	226	> __fish_git_using_command init
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
21	264	> __fish_git_using_command grep
61	165	-> set -l cmd (__fish_git_needs_command)
12	104	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
8	8	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
45	53	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	245	> __fish_git_using_command gc
52	165	-> set -l cmd (__fish_git_needs_command)
10	113	--> __fish_git_needs_command
54	62	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	41	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
6	6	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	234	> __fish_git_using_command difftool
51	155	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
9	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	226	> __fish_git_using_command diff
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command describe
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
40	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	227	> __fish_git_using_command daemon
50	147	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	225	> __fish_git_using_command count-objects
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	222	> __fish_git_using_command commit
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	221	> __fish_git_using_command clone
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
5	5	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	220	> __fish_git_using_command cherry-pick
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
5	5	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
15	220	> __fish_git_using_command cherry
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	224	> __fish_git_using_command bundle
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	280	> __fish_git_using_command branch
55	199	-> set -l cmd (__fish_git_needs_command)
10	144	--> __fish_git_needs_command
89	95	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	228	> __fish_git_using_command bisect
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
23	281	> __fish_git_using_command archive
67	166	-> set -l cmd (__fish_git_needs_command)
11	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
60	70	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
33	295	> __fish_git_using_command apply
60	161	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
73	80	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	245	> __fish_git_using_command apply am
53	161	-> set -l cmd (__fish_git_needs_command)
9	108	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	41	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
9	22	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
20	392	> __fish_git_using_command checkout
58	303	-> set -l cmd (__fish_git_needs_command)
14	245	--> __fish_git_needs_command
130	137	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
11	94	---> if set -q __fish_git_cmdline...
34	34	----> set -q __fish_git_cmdline
25	25	----> test "$cmdline" = "$__fish_git_cmdline"
6	24	----> if set -q __fish_git_cmd[1]...
6	6	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
42	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	300	> __fish_git_using_command am
58	215	-> set -l cmd (__fish_git_needs_command)
12	157	--> __fish_git_needs_command
98	106	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
40	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	194	> __fish_git_using_command add
60	164	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
54	62	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
3	3	-> return 0
70	178457	> __fish_git_files modified untracked deleted unmerged modified-staged-deleted
72	58410	-> set -l root (__fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null)
76	58338	--> __fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null
15	15	---> set -l saved_args $argv
5	5	---> set -l global_args
41	49	---> set -l cmd (commandline -opc)
8	8	----> commandline -opc
6	6	---> set -e cmd[1]
6	334	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
118	154	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	36	-----> __fish_git_global_optspecs
26	26	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	165	----> set -l num_global_args (math (count $cmd) - (count $argv))
66	126	-----> math (count $cmd) - (count $argv)
53	53	------> count $cmd
7	7	------> count $argv
2	9	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
56	57853	---> eval command git $global_args \$saved_args 2>/dev/null
57797	57797	----> command git $saved_args
17	17	-> test "$root[2]" = true
7	7	-> set -e root[2]
15	15	-> contains -- all-staged $argv
7	7	-> contains -- unmerged $argv
6	6	-> set -l unmerged
6	6	-> set -l unmerged_desc "Unmerged File"
7	7	-> contains -- added $argv
3	3	-> set -ql all_staged
6	6	-> contains -- modified $argv
4	4	-> set -l modified
8	8	-> set -l modified_desc "Modified file"
7	7	-> contains -- untracked $argv
4	4	-> set -l untracked
5	5	-> set -l untracked_desc "Untracked file"
6	6	-> contains -- modified-staged $argv
3	3	-> set -ql all_staged
7	7	-> contains -- modified-staged-deleted $argv
4	4	-> set -l modified_staged_deleted
11	11	-> set -l modified_staged_deleted_desc "Staged modified and deleted file"
7	7	-> contains -- deleted $argv
4	4	-> set -l deleted
5	5	-> set -l deleted_desc "Deleted file"
7	7	-> contains -- deleted-staged $argv
4	4	-> set -ql all_staged
6	6	-> contains -- ignored $argv
7	7	-> contains -- renamed $argv
6	6	-> contains -- copied $argv
5	5	-> set -l q '\\?'
1	6	-> if status test-feature qmark-noglob...
5	5	--> status test-feature qmark-noglob
4	4	-> set -l use_next
5	5	-> set -l status_opt --ignore-submodules=all
4	4	-> set -q ignored
3	3	-> set -q untracked
5	5	-> set -a status_opt -uall
5	5	-> set -l git_opt -c status.relativePaths -c core.quotePath=
81	56848	-> set -l ver (__fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2')
106	56767	--> __fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2'
7	7	---> set -l saved_args $argv
4	4	---> set -l global_args
36	47	---> set -l cmd (commandline -opc)
11	11	----> commandline -opc
5	5	---> set -e cmd[1]
7	276	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
101	134	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	33	-----> __fish_git_global_optspecs
22	22	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
38	126	----> set -l num_global_args (math (count $cmd) - (count $argv))
71	88	-----> math (count $cmd) - (count $argv)
10	10	------> count $cmd
7	7	------> count $argv
1	9	----> if test $num_global_args -ne 0...
8	8	-----> test $num_global_args -ne 0
53	56322	---> eval command git $global_args \$saved_args 2>/dev/null
56269	56269	----> command git $saved_args
68	62913	-> if test "$ver[1]" -gt 2 2>/dev/null...
46	46	--> test "$ver[1]" -gt 2 2>/dev/null
27	27	--> test "$ver[1]" -eq 2 -a "$ver[2]" -ge 11 2>/dev/null
229	62772	--> __fish_git $git_opt status --porcelain=2 $status_opt \
            | while read -la -d ' ' line
            set -l file
            set -l desc
            # The basic status format is "XY", where X is "our" state (meaning the staging area),
            # and "Y" is "their" state.
            # A "." means it's unmodified.
            switch "$line[1..2]"
                case 'u *'
                    # Unmerged
                    # "Unmerged entries have the following format; the first character is a "u" to distinguish from ordinary changed entries."
                    # "u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>"
                    # This is first to distinguish it from normal modifications et al.
                    set -ql unmerged
                    and set file "$line[11..-1]"
                    and set desc $unmerged_desc
                case '2 .R*' '2 R.*'
                    # Renamed/Copied
                    # From the docs: "Renamed or copied entries have the following format:"
                    # "2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>"
                    # Since <sep> is \t, we can't really parse it unambiguously.
                    # The "-z" format would be great here!
                    set -ql renamed
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    and set desc $renamed_desc
                case '2 RM*' '2 RT*'
                    # Staged as renamed, with unstaged modifications (issue #6031)
                    set -ql renamed
                    or set -ql modified
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql modified
                    and set --append desc $modified_desc
                case '2 RD*'
                    # Staged as renamed, but deleted in the worktree
                    set -ql renamed
                    or set -ql deleted
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql deleted
                    and set --append desc $deleted_desc
                case '2 .C*' '2 C.*'
                    set -ql copied
                    and set file (string replace -r '\t[^\t].*' '' -- "$line[10..-1]")
                    and set desc $copied_desc
                case '1 A.*'
                    # Additions are only shown here if they are staged.
                    # Otherwise it's an untracked file.
                    set -ql added
                    and set file "$line[9..-1]"
                    and set desc $added_desc
                case '1 AD*'
                    # Added files that were since deleted
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql deleted
                        set file "$line[9..-1]"
                        set desc $deleted_desc
                    end
                case "1 AM*" "1 AT*"
                    # Added files with additional modifications
                    # ("T" is type-changed. As of git 2.33 this appears to be undocumented.
                    # it happens when e.g. a file is replaced with a symlink.
                    # For our purposes it's the same as modified)
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    end
                case '1 .A*'
                    # Files added with git add --intent-to-add.
                    set -ql untracked
                    and set file "$line[9..-1]"
                    and set desc $untracked_desc
                case '1 .M*' '1 .T*'
                    # Modified
                    # From the docs: "Ordinary changed entries have the following format:"
                    # "1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>"
                    # Since <path> can contain spaces, print from element 9 onwards
                    set -ql modified
                    and set file "$line[9..-1]"
                    and set desc $modified_desc
                case '1 MD*' '1 TD*'
                    set -ql modified_staged_deleted
                    and set file "$line[9..-1]"
                    and set desc $modified_staged_deleted_desc
                case '1 M.*' '1 T.*'
                    # If the character is first ("M."), then that means it's "our" change,
                    # which means it is staged.
                    # This is useless for many commands - e.g. `checkout` won't do anything with this.
                    # So it needs to be requested explicitly.
                    set -ql modified_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_modified_desc
                case '1 MM*' '1 MT*' '1 TM*' '1 TT*'
                    # Staged-modified with unstaged modifications
                    # These need to be offered for both kinds of modified.
                    if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    else if set -ql modified_staged
                        set file "$line[9..-1]"
                        set desc $staged_modified_desc
                    end
                case '1 .D*'
                    set -ql deleted
                    and set file "$line[9..-1]"
                    and set desc $deleted_desc
                case '1 D.*'
                    # TODO: The docs are unclear on this.
                    # There is both X unmodified and Y either M or D ("not updated")
                    # and Y is D and X is unmodified or [MARC] ("deleted in work tree").
                    # For our purposes, we assume this is a staged deletion.
                    set -ql deleted_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_deleted_desc
                case "$q"' *'
                    # Untracked
                    # "? <path>" - print from element 2 on.
                    set -ql untracked
                    and set file "$line[2..-1]"
                    and set desc $untracked_desc
                case '! *'
                    # Ignored
                    # "! <path>" - print from element 2 on.
                    set -ql ignored
                    and set file "$line[2..-1]"
                    and set desc $ignored_desc
            end
            # Only try printing if the file was selected.
            if set -q file[1]
                for d in $desc
                    # Without "-z", git sometimes _quotes_ filenames.
                    # It adds quotes around it _and_ escapes the character.
                    # e.g. `"a\\b"`.
                    # We just remove the quotes and hope it works out.
                    # If this contains newlines or tabs,
                    # there is nothing we can do, but that's a general issue with scripted completions.
                    set file (string trim -c \" -- $file)
                    # The relative filename.
                    if string match -q './*' -- (commandline -ct)
                        printf './%s\t%s\n' $file $d
                    else
                        printf '%s\t%s\n' "$file" $d
                    end
                    # Now from repo root.
                    # Only do this if the filename isn't a simple child,
                    # or the current token starts with ":"
                    if string match -q '../*' -- $file
                        or string match -q ':*' -- (commandline -ct)
                        set -l fromroot (builtin realpath -- $file 2>/dev/null)
                        # `:` starts pathspec "magic", and the second `:` terminates it.
                        # `/` is the magic letter for "from repo root".
                        # If we didn't terminate it we'd have to escape any special chars
                        # (non-alphanumeric, glob or regex special characters, in whatever dialect git uses)
                        and set fromroot (string replace -- "$root/" ":/:" "$fromroot")
                        and printf '%s\t%s\n' "$fromroot" $d
                    end
                end
            end
        end
19	19	---> set -l saved_args $argv
5	5	---> set -l global_args
45	57	---> set -l cmd (commandline -opc)
12	12	----> commandline -opc
6	6	---> set -e cmd[1]
8	273	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
98	133	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	35	-----> __fish_git_global_optspecs
24	24	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	124	----> set -l num_global_args (math (count $cmd) - (count $argv))
65	85	-----> math (count $cmd) - (count $argv)
14	14	------> count $cmd
6	6	------> count $argv
1	8	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
52	59044	---> eval command git $global_args \$saved_args 2>/dev/null
58992	58992	----> command git $saved_args
121	121	---> read -la -d ' ' line
9	9	---> set -l file
4	4	---> set -l desc
44	60	---> switch "$line[1..2]"...
4	4	----> set -ql deleted
7	7	----> set file "$line[9..-1]"
5	5	----> set desc $deleted_desc
9	205	---> if set -q file[1]...
3	3	----> set -q file[1]
10	193	----> for d in $desc...
51	63	-----> set file (string trim -c \" -- $file)
12	12	------> string trim -c \" -- $file
3	71	-----> if string match -q './*' -- (commandline -ct)...
39	51	------> string match -q './*' -- (commandline -ct)
12	12	-------> commandline -ct
17	17	------> printf '%s\t%s\n' "$file" $d
2	49	-----> if string match -q '../*' -- $file...
7	7	------> string match -q '../*' -- $file
34	40	------> string match -q ':*' -- (commandline -ct)
6	6	-------> commandline -ct
100	100	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
34	48	---> switch "$line[1..2]"...
4	4	----> set -ql deleted
5	5	----> set file "$line[9..-1]"
5	5	----> set desc $deleted_desc
8	165	---> if set -q file[1]...
3	3	----> set -q file[1]
8	154	----> for d in $desc...
37	46	-----> set file (string trim -c \" -- $file)
9	9	------> string trim -c \" -- $file
3	55	-----> if string match -q './*' -- (commandline -ct)...
34	40	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
12	12	------> printf '%s\t%s\n' "$file" $d
2	45	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
32	37	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
97	97	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
33	46	---> switch "$line[1..2]"...
3	3	----> set -ql deleted
5	5	----> set file "$line[9..-1]"
5	5	----> set desc $deleted_desc
9	159	---> if set -q file[1]...
3	3	----> set -q file[1]
7	147	----> for d in $desc...
36	43	-----> set file (string trim -c \" -- $file)
7	7	------> string trim -c \" -- $file
3	51	-----> if string match -q './*' -- (commandline -ct)...
32	38	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
10	10	------> printf '%s\t%s\n' "$file" $d
2	46	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
33	38	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
93	93	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
31	45	---> switch "$line[1..2]"...
4	4	----> set -ql deleted
6	6	----> set file "$line[9..-1]"
4	4	----> set desc $deleted_desc
7	157	---> if set -q file[1]...
3	3	----> set -q file[1]
7	147	----> for d in $desc...
35	43	-----> set file (string trim -c \" -- $file)
8	8	------> string trim -c \" -- $file
3	52	-----> if string match -q './*' -- (commandline -ct)...
32	38	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
2	45	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
32	37	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
89	89	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
33	47	---> switch "$line[1..2]"...
4	4	----> set -ql deleted
6	6	----> set file "$line[9..-1]"
4	4	----> set desc $deleted_desc
7	155	---> if set -q file[1]...
3	3	----> set -q file[1]
6	145	----> for d in $desc...
35	42	-----> set file (string trim -c \" -- $file)
7	7	------> string trim -c \" -- $file
3	52	-----> if string match -q './*' -- (commandline -ct)...
32	38	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
2	45	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
32	37	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
91	91	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
26	40	---> switch "$line[1..2]"...
3	3	----> set -ql modified
5	5	----> set file "$line[9..-1]"
6	6	----> set desc $modified_desc
7	156	---> if set -q file[1]...
3	3	----> set -q file[1]
7	146	----> for d in $desc...
36	43	-----> set file (string trim -c \" -- $file)
7	7	------> string trim -c \" -- $file
3	51	-----> if string match -q './*' -- (commandline -ct)...
32	38	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
10	10	------> printf '%s\t%s\n' "$file" $d
2	45	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
32	37	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
97	97	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
26	40	---> switch "$line[1..2]"...
4	4	----> set -ql modified
5	5	----> set file "$line[9..-1]"
5	5	----> set desc $modified_desc
7	155	---> if set -q file[1]...
3	3	----> set -q file[1]
6	145	----> for d in $desc...
36	43	-----> set file (string trim -c \" -- $file)
7	7	------> string trim -c \" -- $file
3	51	-----> if string match -q './*' -- (commandline -ct)...
32	37	------> string match -q './*' -- (commandline -ct)
5	5	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
3	45	-----> if string match -q '../*' -- $file...
5	5	------> string match -q '../*' -- $file
32	37	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
100	100	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
30	45	---> switch "$line[1..2]"...
4	4	----> set -ql deleted
6	6	----> set file "$line[9..-1]"
5	5	----> set desc $deleted_desc
7	156	---> if set -q file[1]...
3	3	----> set -q file[1]
8	146	----> for d in $desc...
36	43	-----> set file (string trim -c \" -- $file)
7	7	------> string trim -c \" -- $file
3	51	-----> if string match -q './*' -- (commandline -ct)...
32	37	------> string match -q './*' -- (commandline -ct)
5	5	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
2	44	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
32	36	------> string match -q ':*' -- (commandline -ct)
4	4	-------> commandline -ct
102	102	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
33	46	---> switch "$line[1..2]"...
3	3	----> set -ql deleted
5	5	----> set file "$line[9..-1]"
5	5	----> set desc $deleted_desc
7	157	---> if set -q file[1]...
3	3	----> set -q file[1]
7	147	----> for d in $desc...
36	44	-----> set file (string trim -c \" -- $file)
8	8	------> string trim -c \" -- $file
4	52	-----> if string match -q './*' -- (commandline -ct)...
32	37	------> string match -q './*' -- (commandline -ct)
5	5	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
2	44	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
31	36	------> string match -q ':*' -- (commandline -ct)
5	5	-------> commandline -ct
89	89	---> read -la -d ' ' line
4	4	---> set -l file
3	3	---> set -l desc
27	39	---> switch "$line[1..2]"...
3	3	----> set -ql modified
5	5	----> set file "$line[9..-1]"
4	4	----> set desc $modified_desc
8	155	---> if set -q file[1]...
3	3	----> set -q file[1]
7	144	----> for d in $desc...
35	42	-----> set file (string trim -c \" -- $file)
7	7	------> string trim -c \" -- $file
3	51	-----> if string match -q './*' -- (commandline -ct)...
31	37	------> string match -q './*' -- (commandline -ct)
6	6	-------> commandline -ct
11	11	------> printf '%s\t%s\n' "$file" $d
2	44	-----> if string match -q '../*' -- $file...
6	6	------> string match -q '../*' -- $file
32	36	------> string match -q ':*' -- (commandline -ct)
4	4	-------> commandline -ct
8	8	---> read -la -d ' ' line
28	312	> __fish_git_using_command show-branch
67	193	-> set -l cmd (__fish_git_needs_command)
15	126	--> __fish_git_needs_command
58	66	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	45	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
13	13	----> test "$cmdline" = "$__fish_git_cmdline"
5	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
10	10	-> test -z "$cmd"
11	11	-> contains -- $cmd $argv
50	60	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
21	268	> __fish_git_using_command show
55	182	-> set -l cmd (__fish_git_needs_command)
10	127	--> __fish_git_needs_command
61	70	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	47	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
15	15	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
8	261	> __fish_git_needs_rev_files
38	253	-> __fish_git_using_command show
51	154	--> set -l cmd (__fish_git_needs_command)
8	103	---> __fish_git_needs_command
52	58	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
7	37	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
8	8	-----> test "$cmdline" = "$__fish_git_cmdline"
5	18	-----> if set -q __fish_git_cmd[1]...
4	4	------> set -q __fish_git_cmd[1]
6	6	------> echo -- $__fish_git_cmd
3	3	------> return 1
5	5	--> test -z "$cmd"
6	6	--> contains -- $cmd $argv
35	42	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	---> string escape --style=var -- $cmd
5	5	--> set -q $varname
3	3	--> return 1
22	237	> __fish_git_using_command remote
51	156	-> set -l cmd (__fish_git_needs_command)
9	105	--> __fish_git_needs_command
51	62	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	229	> __fish_git_using_command filter-branch
51	153	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
4	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command fetch
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	228	> __fish_git_using_command fetch pull
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
22	232	> __fish_git_using_command diff log show range-diff
50	150	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	230	> __fish_git_using_command diff show range-diff
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	229	> __fish_git_using_command diff show range-diff apply
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
33	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	233	> __fish_git_using_command log show diff-tree rev-list
52	153	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
62	107	> __fish_disable_bracketed_paste 'git add fish/'
45	45	-> printf "\e[?2004l"
140	2293	> fish_title git\ add\ fish/
40	2153	-> if not set -q INSIDE_EMACS...
31	31	--> not set -q INSIDE_EMACS
21	21	--> set -l ssh
59	59	--> set -q SSH_TTY
27	2002	--> if set -q argv[1]...
73	73	---> set -q argv[1]
320	1902	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
40	40	----> string sub -l 20 -- $argv[1]
79	1542	----> prompt_pwd -d 1 -D 1
25	25	-----> set -l options h/help d/dir-length= D/full-length-dirs=
63	63	-----> argparse -n prompt_pwd $options -- $argv
4	16	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
11	11	-----> set -q argv[1]
18	18	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
44	1248	-----> for path in $argv...
166	198	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
180	255	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
75	75	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
24	751	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
31	457	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
184	368	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
148	184	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
26	26	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
154	228	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
74	74	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
79750	79750	> git add fish/
27	62	> __fish_enable_bracketed_paste
35	35	-> printf "\e[?2004h"
12	64	> fish_mode_prompt
15	52	-> fish_default_mode_prompt
9	37	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
24	225451	> fish_prompt
15	15	-> set -l last_status $status
42	54	-> set -l normal (set_color normal)
12	12	--> set_color normal
39	48	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
35	45	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
32	39	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	78	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
13	64	--> fish_is_root_user
2	36	---> if test "$EUID" = 0 2>/dev/null...
34	34	----> test "$EUID" = 0 2>/dev/null
2	11	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
121	225108	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
20	276	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
160	233	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
6	6	----> set_color normal
7	7	----> set_color $color_host
13	42	----> prompt_hostname
29	29	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
22	224	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
9	9	---> set -l fish_prompt_pwd_full_dirs 1
13	140	---> for path in $argv...
36	48	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
39	61	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
11	224487	--> fish_vcs_prompt
98	224476	---> fish_git_prompt $argv
19	51374	----> if not command -sq git...
51355	51355	-----> not command -sq git
2	42	----> if functions -q __fish_git_prompt_ready...
40	40	-----> functions -q __fish_git_prompt_ready
141	57594	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57453	57453	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
8	8	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
72	58362	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
45	58290	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
5	5	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
3	3	------> set -l total
24	94	------> if test -d $git_dir/rebase-merge...
17	17	-------> test -d $git_dir/rebase-merge
5	53	-------> if test -d $git_dir/rebase-apply...
9	9	--------> test -d $git_dir/rebase-apply
14	14	--------> test -f $git_dir/MERGE_HEAD
9	9	--------> test -f $git_dir/CHERRY_PICK_HEAD
8	8	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
9	57977	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
6	57964	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
138	57958	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57820	57820	---------> command git symbolic-ref HEAD 2>/dev/null
4	80	------> if test true = $inside_gitdir...
76	76	-------> test true = $inside_gitdir
16	16	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50551	56425	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5874	5874	-----> read -lz key value
8	42	----> if not set -q dirty[1]...
15	15	-----> not set -q dirty[1]
19	19	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	70	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
2	8	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
69	81	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
6	6	-----> set format " (%s)"
31	31	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	568	> fish_title
7	559	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
3	3	--> set -q SSH_TTY
6	539	--> if set -q argv[1]...
3	3	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
5	15	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
63	474	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
25	404	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	306	-----> for path in $argv...
37	47	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
35	59	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	186	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	111	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	88	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	52	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
39	56	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
88	276	> __fish_disable_bracketed_paste 'git commit -m "chore: cleaning fish config..."'
188	188	-> printf "\e[?2004l"
159	3773	> fish_title git\ commit\ -m\ \"chore:\ cleaning\ fish\ config...\"
38	3614	-> if not set -q INSIDE_EMACS...
42	42	--> not set -q INSIDE_EMACS
24	24	--> set -l ssh
16	16	--> set -q SSH_TTY
14	3494	--> if set -q argv[1]...
17	17	---> set -q argv[1]
739	3463	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
51	51	----> string sub -l 20 -- $argv[1]
269	2673	----> prompt_pwd -d 1 -D 1
48	48	-----> set -l options h/help d/dir-length= D/full-length-dirs=
100	100	-----> argparse -n prompt_pwd $options -- $argv
7	26	-----> if set -q _flag_help...
19	19	------> set -q _flag_help
15	15	-----> set -q argv[1]
28	28	-----> set argv $PWD
14	14	-----> set -ql _flag_d
29	29	-----> set -l fish_prompt_pwd_dir_length $_flag_d
15	15	-----> set -q fish_prompt_pwd_dir_length
18	18	-----> set -l fulldirs 0
13	13	-----> set -ql _flag_D
24	24	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
14	14	-----> set -q fish_prompt_pwd_full_dirs
55	2060	-----> for path in $argv...
234	281	------> set -l realhome (string escape --style=regex -- ~)
47	47	-------> string escape --style=regex -- ~
231	326	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
95	95	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
33	1398	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
42	42	-------> test "$fish_prompt_pwd_dir_length" -eq 0
19	19	-------> set -l full
71	908	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
25	25	--------> test $fish_prompt_pwd_full_dirs -gt 0
224	770	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
375	546	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
171	171	----------> math $fish_prompt_pwd_full_dirs - 1
26	26	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
250	396	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
146	146	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
101612	101612	> git commit -m "chore: cleaning fish config..."
48	99	> __fish_enable_bracketed_paste
51	51	-> printf "\e[?2004h"
34	139	> fish_mode_prompt
56	105	-> fish_default_mode_prompt
5	49	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
39	39	---> test "$fish_key_bindings" = fish_vi_key_bindings
5	5	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
88	225920	> fish_prompt
37	37	-> set -l last_status $status
173	249	-> set -l normal (set_color normal)
76	76	--> set_color normal
182	207	-> set -l status_color (set_color brgreen)
25	25	--> set_color brgreen
139	182	-> set -l cwd_color (set_color $fish_color_cwd)
43	43	--> set_color $fish_color_cwd
124	145	-> set -l vcs_color (set_color brpurple)
21	21	--> set_color brpurple
12	12	-> set -l prompt_status ""
13	13	-> set -q fish_prompt_pwd_dir_length
8	8	-> set -lx fish_prompt_pwd_dir_length 0
7	7	-> set -l suffix '❯'
3	281	-> if functions -q fish_is_root_user...
120	120	--> functions -q fish_is_root_user
27	158	--> fish_is_root_user
2	87	---> if test "$EUID" = 0 2>/dev/null...
85	85	----> test "$EUID" = 0 2>/dev/null
4	39	---> if contains -- $USER root toor Administrator...
35	35	----> contains -- $USER root toor Administrator
5	5	---> return 1
0	9	-> if test $last_status -ne 0...
9	9	--> test $last_status -ne 0
280	224669	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
87	692	--> prompt_login
2	25	---> if not set -q __fish_machine...
23	23	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
10	10	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
361	560	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
48	48	----> set_color $fish_color_user
13	13	----> set_color normal
11	11	----> set_color $color_host
80	118	----> prompt_hostname
38	38	-----> string replace -r -- "\..*" "" $hostname
9	9	----> set_color normal
28	291	--> prompt_pwd
13	13	---> set -l options h/help d/dir-length= D/full-length-dirs=
30	30	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
18	183	---> for path in $argv...
62	73	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
39	68	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
29	29	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	24	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
11	11	-----> echo $tmp
74	223406	--> fish_vcs_prompt
141	223332	---> fish_git_prompt $argv
11	51002	----> if not command -sq git...
50991	50991	-----> not command -sq git
2	76	----> if functions -q __fish_git_prompt_ready...
74	74	-----> functions -q __fish_git_prompt_ready
142	56837	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56695	56695	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
72	57806	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
59	57734	-----> __fish_git_prompt_operation_branch_bare $repo_info
13	13	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
5	5	------> set -l branch
3	3	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
27	96	------> if test -d $git_dir/rebase-merge...
18	18	-------> test -d $git_dir/rebase-merge
6	51	-------> if test -d $git_dir/rebase-apply...
11	11	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
9	9	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
10	57443	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
6	57429	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	57423	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57334	57334	---------> command git symbolic-ref HEAD 2>/dev/null
4	41	------> if test true = $inside_gitdir...
37	37	-------> test true = $inside_gitdir
12	12	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
5	5	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
5	5	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
2	8	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
22	22	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50778	56866	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6088	6088	-----> read -lz key value
6	41	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	72	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	44	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	47	----> for i in $__fish_git_prompt_status_order...
3	9	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
73	88	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
3	31	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
28	28	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	40	----> if test -n "$b"...
7	7	-----> test -n "$b"
9	9	-----> set b "$branch_color$b$branch_done"
2	18	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
8	8	------> test -z "$dirtystate$untrackedfiles$stagedstate"
8	8	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
10	577	> fish_title
8	567	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
5	544	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
2	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
5	5	----> set command
65	479	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
25	407	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	310	-----> for path in $argv...
41	51	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
40	60	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	186	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
6	110	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	88	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	51	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
40	57	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
60	254	> __fish_disable_bracketed_paste ls
194	194	-> printf "\e[?2004l"
42	2368	> fish_title ls
24	2326	-> if not set -q INSIDE_EMACS...
24	24	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
11	11	--> set -q SSH_TTY
20	2251	--> if set -q argv[1]...
11	11	---> set -q argv[1]
345	2220	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
30	30	----> string sub -l 20 -- $argv[1]
100	1845	----> prompt_pwd -d 1 -D 1
35	35	-----> set -l options h/help d/dir-length= D/full-length-dirs=
74	74	-----> argparse -n prompt_pwd $options -- $argv
3	17	-----> if set -q _flag_help...
14	14	------> set -q _flag_help
11	11	-----> set -q argv[1]
18	18	-----> set argv $PWD
10	10	-----> set -ql _flag_d
54	54	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
51	1471	-----> for path in $argv...
172	205	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
199	272	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
73	73	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
31	943	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
44	44	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
25	545	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
224	462	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
197	238	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
41	41	----------> math $fish_prompt_pwd_full_dirs - 1
27	27	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
232	308	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
76	76	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
94	79807	> ls
79713	79713	-> eza -lha $argv
27	61	> __fish_enable_bracketed_paste
34	34	-> printf "\e[?2004h"
12	52	> fish_mode_prompt
13	40	-> fish_default_mode_prompt
3	27	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
18	18	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
24	223708	> fish_prompt
12	12	-> set -l last_status $status
43	56	-> set -l normal (set_color normal)
13	13	--> set_color normal
35	43	-> set -l status_color (set_color brgreen)
8	8	--> set_color brgreen
41	50	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
35	41	-> set -l vcs_color (set_color brpurple)
6	6	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
4	4	-> set -l suffix '❯'
3	76	-> if functions -q fish_is_root_user...
7	7	--> functions -q fish_is_root_user
13	66	--> fish_is_root_user
2	37	---> if test "$EUID" = 0 2>/dev/null...
35	35	----> test "$EUID" = 0 2>/dev/null
3	12	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
0	7	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
180	223368	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
17	267	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
3	6	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
159	226	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
10	35	----> prompt_hostname
25	25	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
27	236	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
2	5	---> if set -q _flag_help...
3	3	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
16	153	---> for path in $argv...
44	55	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
38	65	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
22	222685	--> fish_vcs_prompt
94	222663	---> fish_git_prompt $argv
9	51967	----> if not command -sq git...
51958	51958	-----> not command -sq git
3	27	----> if functions -q __fish_git_prompt_ready...
24	24	-----> functions -q __fish_git_prompt_ready
124	56027	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
55903	55903	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
59	56952	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	56893	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
5	5	------> set -l total
35	88	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
7	42	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	56661	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
6	56649	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
85	56643	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56558	56558	---------> command git symbolic-ref HEAD 2>/dev/null
2	15	------> if test true = $inside_gitdir...
13	13	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
9	9	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
20	20	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
6	6	----> set -l untracked
51059	56985	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5926	5926	-----> read -lz key value
9	46	----> if not set -q dirty[1]...
20	20	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
26	26	----> contains dirtystate $__fish_git_prompt_status_order
4	18	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
10	10	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	81	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	50	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
5	14	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
4	14	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
2	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	47	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
61	75	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
2	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
7	35	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
3	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
2	5	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	573	> fish_title
6	564	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
8	544	--> if set -q argv[1]...
3	3	---> set -q argv[1]
43	51	---> set -l command (status current-command)
8	8	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
62	470	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
6	6	----> string sub -l 20 -- $command
29	402	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	305	-----> for path in $argv...
37	47	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
36	59	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	187	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
5	111	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	89	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	52	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
41	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
26	44	> __fish_disable_bracketed_paste 'git status'
18	18	-> printf "\e[?2004l"
12	582	> fish_title git\ status
9	570	-> if not set -q INSIDE_EMACS...
10	10	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
3	541	--> if set -q argv[1]...
4	4	---> set -q argv[1]
83	534	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
14	14	----> string sub -l 20 -- $argv[1]
31	437	----> prompt_pwd -d 1 -D 1
9	9	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
9	9	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	329	-----> for path in $argv...
40	51	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
40	70	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
30	30	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	195	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	113	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	90	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	49	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	60	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
63827	63827	> git status
28	64	> __fish_enable_bracketed_paste
36	36	-> printf "\e[?2004h"
10	52	> fish_mode_prompt
14	42	-> fish_default_mode_prompt
3	28	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
30	224884	> fish_prompt
13	13	-> set -l last_status $status
46	58	-> set -l normal (set_color normal)
12	12	--> set_color normal
35	44	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
35	45	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
33	40	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	80	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
17	67	--> fish_is_root_user
2	34	---> if test "$EUID" = 0 2>/dev/null...
32	32	----> test "$EUID" = 0 2>/dev/null
2	12	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
209	224528	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	266	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	4	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
155	230	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
14	44	----> prompt_hostname
30	30	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
57	309	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
20	196	---> for path in $argv...
40	51	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
38	59	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	66	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
35	35	-----> test "$fish_prompt_pwd_dir_length" -eq 0
20	20	-----> echo $tmp
18	223744	--> fish_vcs_prompt
100	223726	---> fish_git_prompt $argv
12	51247	----> if not command -sq git...
51235	51235	-----> not command -sq git
2	35	----> if functions -q __fish_git_prompt_ready...
33	33	-----> functions -q __fish_git_prompt_ready
138	58211	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58073	58073	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
26	26	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
8	8	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
60	56808	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
39	56748	-----> __fish_git_prompt_operation_branch_bare $repo_info
13	13	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	73	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	39	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
13	56528	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56511	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	56509	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56420	56420	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
19	19	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50693	56720	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6027	6027	-----> read -lz key value
5	45	----> if not set -q dirty[1]...
20	20	-----> not set -q dirty[1]
20	20	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
18	18	----> contains dirtystate $__fish_git_prompt_status_order
3	17	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
9	9	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
10	10	----> contains untrackedfiles $__fish_git_prompt_status_order
9	83	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
7	52	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
4	16	------> begin...
12	12	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	16	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	13	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
6	6	----> set -l f ""
17	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
64	76	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
2	5	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
4	14	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
19	19	-> echo -n -s $status_color $suffix ' ' $normal
17	683	> fish_title
6	666	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
8	641	--> if set -q argv[1]...
3	3	---> set -q argv[1]
70	78	---> set -l command (status current-command)
8	8	----> status current-command
9	25	---> if test "$command" = fish...
10	10	----> test "$command" = fish
6	6	----> set command
82	527	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
29	436	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
25	25	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	330	-----> for path in $argv...
43	54	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
44	70	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	193	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
5	114	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
38	91	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	53	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	60	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
46	761	> __fish_git_using_command upload-pack
78	609	-> set -l cmd (__fish_git_needs_command)
38	531	--> __fish_git_needs_command
80	127	---> set -l cmdline "$(commandline -c)"
47	47	----> commandline -c
4	28	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
18	18	----> test "$cmdline" = "$__fish_git_cmdline"
9	9	---> set -g __fish_git_cmdline $cmdline
55	65	---> set -l cmd (commandline -opc)
10	10	----> commandline -opc
10	10	---> set -e cmd[1]
133	179	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
15	46	----> __fish_git_global_optspecs
31	31	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
7	7	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
10	59	---> if set -q argv[1]...
3	3	----> set -q argv[1]
9	9	----> set -g __fish_git_cmd $argv[1]
33	33	----> echo $argv[1]
4	4	----> return 1
8	8	-> test -z "$cmd"
32	32	-> contains -- $cmd $argv
49	57	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
26	350	> __fish_git_using_command upload-archive
87	233	-> set -l cmd (__fish_git_needs_command)
14	146	--> __fish_git_needs_command
73	81	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	51	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
6	23	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
10	10	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
52	61	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
25	297	> __fish_git_using_command shell
61	199	-> set -l cmd (__fish_git_needs_command)
12	138	--> __fish_git_needs_command
70	80	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
12	46	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
46	53	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
2	2	-> return 1
22	265	> __fish_git_using_command receive-pack
57	173	-> set -l cmd (__fish_git_needs_command)
9	116	--> __fish_git_needs_command
59	67	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	40	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	246	> __fish_git_using_command flow
57	166	-> set -l cmd (__fish_git_needs_command)
10	109	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	235	> __fish_git_using_command cvsserver
51	151	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
41	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
10	101	> __fish_git_needs_command
52	58	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
5	33	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
7	7	--> test "$cmdline" = "$__fish_git_cmdline"
6	17	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
5	5	---> echo -- $__fish_git_cmd
3	3	---> return 1
75	160	> __fish_seen_subcommand_from branch for-each-ref tag
46	56	-> set -l cmd (commandline -poc)
10	10	--> commandline -poc
6	6	-> set -e cmd[1]
8	20	-> for i in $cmd...
2	12	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
3	3	-> return 1
18	250	> __fish_git_using_command for-each-ref
51	163	-> set -l cmd (__fish_git_needs_command)
10	112	--> __fish_git_needs_command
54	62	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	40	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	234	> __fish_git_using_command config
51	153	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command help
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	232	> __fish_git_using_command blame
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	227	> __fish_git_using_command clean
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	233	> __fish_git_using_command submodule
56	158	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	60	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	223	> __fish_git_using_command format-patch
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	220	> __fish_git_using_command format-patch log
49	145	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command stash
49	150	-> set -l cmd (__fish_git_needs_command)
10	101	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	231	> __fish_git_using_command worktree
50	155	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	40	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	227	> __fish_git_using_command update-index
50	149	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	229	> __fish_git_using_command tag
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
43	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	251	> __fish_git_using_command stripspace
65	170	-> set -l cmd (__fish_git_needs_command)
9	105	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
26	277	> __fish_git_using_command status
58	184	-> set -l cmd (__fish_git_needs_command)
11	126	--> __fish_git_needs_command
64	74	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
7	41	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
5	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	232	> __fish_git_using_command rm
51	153	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	232	> __fish_git_using_command revert
50	155	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	40	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
12	23	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	228	> __fish_git_using_command rev-parse
51	150	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	232	> __fish_git_using_command restore switch
51	153	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
22	271	> __fish_git_using_command switch
59	182	-> set -l cmd (__fish_git_needs_command)
9	123	--> __fish_git_needs_command
68	76	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
2	2	-> return 1
24	271	> __fish_git_using_command restore
56	159	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
58	64	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
9	9	-> set -q $varname
4	4	-> return 1
24	300	> __fish_git_using_command reset
76	196	-> set -l cmd (__fish_git_needs_command)
12	120	--> __fish_git_needs_command
60	69	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
45	54	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
25	315	> __fish_git_using_command reflog
75	206	-> set -l cmd (__fish_git_needs_command)
12	131	--> __fish_git_needs_command
72	81	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
7	38	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
9	9	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
49	57	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
32	287	> __fish_git_using_command rebase
67	172	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
52	64	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
12	12	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
22	303	> __fish_git_using_command push
63	178	-> set -l cmd (__fish_git_needs_command)
8	115	--> __fish_git_needs_command
65	73	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
9	9	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
64	77	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
13	13	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
21	270	> __fish_git_using_command range-diff
57	180	-> set -l cmd (__fish_git_needs_command)
11	123	--> __fish_git_needs_command
67	75	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
24	299	> __fish_git_using_command pull
62	175	-> set -l cmd (__fish_git_needs_command)
8	113	--> __fish_git_needs_command
59	65	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	40	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	24	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
9	9	-----> return 1
26	26	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
46	54	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
23	264	> __fish_git_using_command prune
64	169	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
43	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	230	> __fish_git_using_command notes
50	152	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	234	> __fish_git_using_command mv
51	157	-> set -l cmd (__fish_git_needs_command)
8	106	--> __fish_git_needs_command
59	65	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
20	291	> __fish_git_using_command mergetool
64	206	-> set -l cmd (__fish_git_needs_command)
11	142	--> __fish_git_needs_command
77	82	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	49	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
7	25	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
9	9	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	244	> __fish_git_using_command merge-base
52	161	-> set -l cmd (__fish_git_needs_command)
9	109	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	254	> __fish_git_using_command merge
55	174	-> set -l cmd (__fish_git_needs_command)
10	119	--> __fish_git_needs_command
68	74	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
24	269	> __fish_git_using_command maintenance
63	163	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
9	9	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
47	55	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
4	4	-> return 1
22	297	> __fish_git_using_command mailsplit
66	181	-> set -l cmd (__fish_git_needs_command)
10	115	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
13	44	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
61	68	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
26	265	> __fish_git_using_command mailsplit am
60	167	-> set -l cmd (__fish_git_needs_command)
10	107	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
42	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
23	294	> __fish_git_using_command mailinfo
63	201	-> set -l cmd (__fish_git_needs_command)
12	138	--> __fish_git_needs_command
74	81	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	45	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
5	21	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
42	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
22	246	> __fish_git_using_command mailinfo am
54	159	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
56	62	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
22	316	> __fish_git_using_command ls-files
71	210	-> set -l cmd (__fish_git_needs_command)
11	139	--> __fish_git_needs_command
84	90	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
11	11	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
47	55	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
21	282	> __fish_git_using_command log
63	190	-> set -l cmd (__fish_git_needs_command)
11	127	--> __fish_git_needs_command
69	78	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
41	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
22	280	> __fish_git_using_command init
73	183	-> set -l cmd (__fish_git_needs_command)
9	110	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
13	41	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
42	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
18	238	> __fish_git_using_command grep
55	157	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
40	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
20	235	> __fish_git_using_command gc
50	156	-> set -l cmd (__fish_git_needs_command)
9	106	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
10	22	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	253	> __fish_git_using_command difftool
58	156	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
48	55	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
4	4	-> return 1
21	241	> __fish_git_using_command diff
52	160	-> set -l cmd (__fish_git_needs_command)
10	108	--> __fish_git_needs_command
52	63	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
6	6	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	228	> __fish_git_using_command describe
51	152	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	232	> __fish_git_using_command daemon
51	154	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	229	> __fish_git_using_command count-objects
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	221	> __fish_git_using_command commit
49	146	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	228	> __fish_git_using_command clone
50	152	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
2	2	-> return 1
17	228	> __fish_git_using_command cherry-pick
51	153	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	227	> __fish_git_using_command cherry
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
15	231	> __fish_git_using_command bundle
52	156	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	225	> __fish_git_using_command branch
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command bisect
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	223	> __fish_git_using_command archive
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	230	> __fish_git_using_command apply
54	156	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
55	60	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
5	5	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	260	> __fish_git_using_command apply am
55	165	-> set -l cmd (__fish_git_needs_command)
10	110	--> __fish_git_needs_command
58	64	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
43	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	243	> __fish_git_using_command checkout
54	163	-> set -l cmd (__fish_git_needs_command)
10	109	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	230	> __fish_git_using_command am
51	152	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
13	175	> __fish_git_using_command add
50	148	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
3	3	-> return 0
76	176386	> __fish_git_files modified untracked deleted unmerged modified-staged-deleted
74	58915	-> set -l root (__fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null)
61	58841	--> __fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null
13	13	---> set -l saved_args $argv
5	5	---> set -l global_args
38	45	---> set -l cmd (commandline -opc)
7	7	----> commandline -opc
6	6	---> set -e cmd[1]
9	357	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
109	148	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
12	39	-----> __fish_git_global_optspecs
27	27	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	191	----> set -l num_global_args (math (count $cmd) - (count $argv))
108	152	-----> math (count $cmd) - (count $argv)
37	37	------> count $cmd
7	7	------> count $argv
2	9	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
57	58354	---> eval command git $global_args \$saved_args 2>/dev/null
58297	58297	----> command git $saved_args
17	17	-> test "$root[2]" = true
7	7	-> set -e root[2]
15	15	-> contains -- all-staged $argv
7	7	-> contains -- unmerged $argv
5	5	-> set -l unmerged
7	7	-> set -l unmerged_desc "Unmerged File"
7	7	-> contains -- added $argv
3	3	-> set -ql all_staged
6	6	-> contains -- modified $argv
4	4	-> set -l modified
6	6	-> set -l modified_desc "Modified file"
7	7	-> contains -- untracked $argv
4	4	-> set -l untracked
5	5	-> set -l untracked_desc "Untracked file"
6	6	-> contains -- modified-staged $argv
3	3	-> set -ql all_staged
6	6	-> contains -- modified-staged-deleted $argv
5	5	-> set -l modified_staged_deleted
6	6	-> set -l modified_staged_deleted_desc "Staged modified and deleted file"
6	6	-> contains -- deleted $argv
3	3	-> set -l deleted
6	6	-> set -l deleted_desc "Deleted file"
7	7	-> contains -- deleted-staged $argv
3	3	-> set -ql all_staged
7	7	-> contains -- ignored $argv
6	6	-> contains -- renamed $argv
6	6	-> contains -- copied $argv
5	5	-> set -l q '\\?'
2	7	-> if status test-feature qmark-noglob...
5	5	--> status test-feature qmark-noglob
3	3	-> set -l use_next
5	5	-> set -l status_opt --ignore-submodules=all
3	3	-> set -q ignored
4	4	-> set -q untracked
5	5	-> set -a status_opt -uall
6	6	-> set -l git_opt -c status.relativePaths -c core.quotePath=
75	55934	-> set -l ver (__fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2')
127	55859	--> __fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2'
12	12	---> set -l saved_args $argv
7	7	---> set -l global_args
44	55	---> set -l cmd (commandline -opc)
11	11	----> commandline -opc
5	5	---> set -e cmd[1]
8	295	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
109	146	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	37	-----> __fish_git_global_optspecs
27	27	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
40	132	----> set -l num_global_args (math (count $cmd) - (count $argv))
71	92	-----> math (count $cmd) - (count $argv)
14	14	------> count $cmd
7	7	------> count $argv
1	9	----> if test $num_global_args -ne 0...
8	8	-----> test $num_global_args -ne 0
52	55358	---> eval command git $global_args \$saved_args 2>/dev/null
55306	55306	----> command git $saved_args
61	61253	-> if test "$ver[1]" -gt 2 2>/dev/null...
41	41	--> test "$ver[1]" -gt 2 2>/dev/null
26	26	--> test "$ver[1]" -eq 2 -a "$ver[2]" -ge 11 2>/dev/null
163	61125	--> __fish_git $git_opt status --porcelain=2 $status_opt \
            | while read -la -d ' ' line
            set -l file
            set -l desc
            # The basic status format is "XY", where X is "our" state (meaning the staging area),
            # and "Y" is "their" state.
            # A "." means it's unmodified.
            switch "$line[1..2]"
                case 'u *'
                    # Unmerged
                    # "Unmerged entries have the following format; the first character is a "u" to distinguish from ordinary changed entries."
                    # "u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>"
                    # This is first to distinguish it from normal modifications et al.
                    set -ql unmerged
                    and set file "$line[11..-1]"
                    and set desc $unmerged_desc
                case '2 .R*' '2 R.*'
                    # Renamed/Copied
                    # From the docs: "Renamed or copied entries have the following format:"
                    # "2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>"
                    # Since <sep> is \t, we can't really parse it unambiguously.
                    # The "-z" format would be great here!
                    set -ql renamed
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    and set desc $renamed_desc
                case '2 RM*' '2 RT*'
                    # Staged as renamed, with unstaged modifications (issue #6031)
                    set -ql renamed
                    or set -ql modified
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql modified
                    and set --append desc $modified_desc
                case '2 RD*'
                    # Staged as renamed, but deleted in the worktree
                    set -ql renamed
                    or set -ql deleted
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql deleted
                    and set --append desc $deleted_desc
                case '2 .C*' '2 C.*'
                    set -ql copied
                    and set file (string replace -r '\t[^\t].*' '' -- "$line[10..-1]")
                    and set desc $copied_desc
                case '1 A.*'
                    # Additions are only shown here if they are staged.
                    # Otherwise it's an untracked file.
                    set -ql added
                    and set file "$line[9..-1]"
                    and set desc $added_desc
                case '1 AD*'
                    # Added files that were since deleted
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql deleted
                        set file "$line[9..-1]"
                        set desc $deleted_desc
                    end
                case "1 AM*" "1 AT*"
                    # Added files with additional modifications
                    # ("T" is type-changed. As of git 2.33 this appears to be undocumented.
                    # it happens when e.g. a file is replaced with a symlink.
                    # For our purposes it's the same as modified)
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    end
                case '1 .A*'
                    # Files added with git add --intent-to-add.
                    set -ql untracked
                    and set file "$line[9..-1]"
                    and set desc $untracked_desc
                case '1 .M*' '1 .T*'
                    # Modified
                    # From the docs: "Ordinary changed entries have the following format:"
                    # "1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>"
                    # Since <path> can contain spaces, print from element 9 onwards
                    set -ql modified
                    and set file "$line[9..-1]"
                    and set desc $modified_desc
                case '1 MD*' '1 TD*'
                    set -ql modified_staged_deleted
                    and set file "$line[9..-1]"
                    and set desc $modified_staged_deleted_desc
                case '1 M.*' '1 T.*'
                    # If the character is first ("M."), then that means it's "our" change,
                    # which means it is staged.
                    # This is useless for many commands - e.g. `checkout` won't do anything with this.
                    # So it needs to be requested explicitly.
                    set -ql modified_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_modified_desc
                case '1 MM*' '1 MT*' '1 TM*' '1 TT*'
                    # Staged-modified with unstaged modifications
                    # These need to be offered for both kinds of modified.
                    if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    else if set -ql modified_staged
                        set file "$line[9..-1]"
                        set desc $staged_modified_desc
                    end
                case '1 .D*'
                    set -ql deleted
                    and set file "$line[9..-1]"
                    and set desc $deleted_desc
                case '1 D.*'
                    # TODO: The docs are unclear on this.
                    # There is both X unmodified and Y either M or D ("not updated")
                    # and Y is D and X is unmodified or [MARC] ("deleted in work tree").
                    # For our purposes, we assume this is a staged deletion.
                    set -ql deleted_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_deleted_desc
                case "$q"' *'
                    # Untracked
                    # "? <path>" - print from element 2 on.
                    set -ql untracked
                    and set file "$line[2..-1]"
                    and set desc $untracked_desc
                case '! *'
                    # Ignored
                    # "! <path>" - print from element 2 on.
                    set -ql ignored
                    and set file "$line[2..-1]"
                    and set desc $ignored_desc
            end
            # Only try printing if the file was selected.
            if set -q file[1]
                for d in $desc
                    # Without "-z", git sometimes _quotes_ filenames.
                    # It adds quotes around it _and_ escapes the character.
                    # e.g. `"a\\b"`.
                    # We just remove the quotes and hope it works out.
                    # If this contains newlines or tabs,
                    # there is nothing we can do, but that's a general issue with scripted completions.
                    set file (string trim -c \" -- $file)
                    # The relative filename.
                    if string match -q './*' -- (commandline -ct)
                        printf './%s\t%s\n' $file $d
                    else
                        printf '%s\t%s\n' "$file" $d
                    end
                    # Now from repo root.
                    # Only do this if the filename isn't a simple child,
                    # or the current token starts with ":"
                    if string match -q '../*' -- $file
                        or string match -q ':*' -- (commandline -ct)
                        set -l fromroot (builtin realpath -- $file 2>/dev/null)
                        # `:` starts pathspec "magic", and the second `:` terminates it.
                        # `/` is the magic letter for "from repo root".
                        # If we didn't terminate it we'd have to escape any special chars
                        # (non-alphanumeric, glob or regex special characters, in whatever dialect git uses)
                        and set fromroot (string replace -- "$root/" ":/:" "$fromroot")
                        and printf '%s\t%s\n' "$fromroot" $d
                    end
                end
            end
        end
15	15	---> set -l saved_args $argv
5	5	---> set -l global_args
45	61	---> set -l cmd (commandline -opc)
16	16	----> commandline -opc
6	6	---> set -e cmd[1]
7	271	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
97	132	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	35	-----> __fish_git_global_optspecs
25	25	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	124	----> set -l num_global_args (math (count $cmd) - (count $argv))
65	85	-----> math (count $cmd) - (count $argv)
13	13	------> count $cmd
7	7	------> count $argv
1	8	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
54	60176	---> eval command git $global_args \$saved_args 2>/dev/null
60122	60122	----> command git $saved_args
112	112	---> read -la -d ' ' line
7	7	---> set -l file
4	4	---> set -l desc
34	52	---> switch "$line[1..2]"...
5	5	----> set -ql modified
7	7	----> set file "$line[9..-1]"
6	6	----> set desc $modified_desc
10	244	---> if set -q file[1]...
3	3	----> set -q file[1]
9	231	----> for d in $desc...
51	63	-----> set file (string trim -c \" -- $file)
12	12	------> string trim -c \" -- $file
5	107	-----> if string match -q './*' -- (commandline -ct)...
39	52	------> string match -q './*' -- (commandline -ct)
13	13	-------> commandline -ct
50	50	------> printf '%s\t%s\n' "$file" $d
3	52	-----> if string match -q '../*' -- $file...
7	7	------> string match -q '../*' -- $file
36	42	------> string match -q ':*' -- (commandline -ct)
6	6	-------> commandline -ct
9	9	---> read -la -d ' ' line
23	264	> __fish_git_using_command show-branch
56	173	-> set -l cmd (__fish_git_needs_command)
10	117	--> __fish_git_needs_command
57	65	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	42	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	231	> __fish_git_using_command show
52	153	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
9	252	> __fish_git_needs_rev_files
34	243	-> __fish_git_using_command show
50	150	--> set -l cmd (__fish_git_needs_command)
9	100	---> __fish_git_needs_command
51	57	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
7	34	----> if set -q __fish_git_cmdline...
3	3	-----> set -q __fish_git_cmdline
7	7	-----> test "$cmdline" = "$__fish_git_cmdline"
5	17	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
6	6	------> echo -- $__fish_git_cmd
3	3	------> return 1
5	5	--> test -z "$cmd"
5	5	--> contains -- $cmd $argv
34	41	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	---> string escape --style=var -- $cmd
5	5	--> set -q $varname
3	3	--> return 1
24	266	> __fish_git_using_command remote
51	153	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
57	63	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
12	12	-> set -q $varname
4	4	-> return 1
18	226	> __fish_git_using_command filter-branch
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	222	> __fish_git_using_command fetch
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	224	> __fish_git_using_command fetch pull
51	147	-> set -l cmd (__fish_git_needs_command)
7	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
15	232	> __fish_git_using_command diff log show range-diff
50	156	-> set -l cmd (__fish_git_needs_command)
8	106	--> __fish_git_needs_command
59	65	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	226	> __fish_git_using_command diff show range-diff
51	150	-> set -l cmd (__fish_git_needs_command)
7	99	--> __fish_git_needs_command
54	59	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
2	2	-> return 1
20	224	> __fish_git_using_command diff show range-diff apply
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	223	> __fish_git_using_command log show diff-tree rev-list
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
33	575	> __fish_git_using_command upload-pack
71	463	-> set -l cmd (__fish_git_needs_command)
28	392	--> __fish_git_needs_command
72	87	---> set -l cmdline "$(commandline -c)"
15	15	----> commandline -c
5	22	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
8	8	---> set -g __fish_git_cmdline $cmdline
45	53	---> set -l cmd (commandline -opc)
8	8	----> commandline -opc
7	7	---> set -e cmd[1]
108	141	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	33	----> __fish_git_global_optspecs
22	22	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
10	31	---> if set -q argv[1]...
3	3	----> set -q argv[1]
8	8	----> set -g __fish_git_cmd $argv[1]
7	7	----> echo $argv[1]
3	3	----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
47	55	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
4	4	-> return 1
20	255	> __fish_git_using_command upload-archive
56	171	-> set -l cmd (__fish_git_needs_command)
14	115	--> __fish_git_needs_command
55	63	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
57	360	> __fish_git_using_command shell
81	239	-> set -l cmd (__fish_git_needs_command)
16	158	--> __fish_git_needs_command
93	104	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
26	303	> __fish_git_using_command receive-pack
76	180	-> set -l cmd (__fish_git_needs_command)
10	104	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
13	13	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
54	65	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
25	280	> __fish_git_using_command flow
60	177	-> set -l cmd (__fish_git_needs_command)
9	117	--> __fish_git_needs_command
60	69	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
48	55	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
3	3	-> return 1
22	281	> __fish_git_using_command cvsserver
53	179	-> set -l cmd (__fish_git_needs_command)
9	126	--> __fish_git_needs_command
70	81	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
55	62	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
10	106	> __fish_git_needs_command
56	62	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
6	34	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
8	8	--> test "$cmdline" = "$__fish_git_cmdline"
4	16	--> if set -q __fish_git_cmd[1]...
4	4	---> set -q __fish_git_cmd[1]
5	5	---> echo -- $__fish_git_cmd
3	3	---> return 1
22	92	> __fish_seen_subcommand_from branch for-each-ref tag
36	43	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
6	6	-> set -e cmd[1]
8	18	-> for i in $cmd...
2	10	--> if contains -- $i $argv...
8	8	---> contains -- $i $argv
3	3	-> return 1
28	298	> __fish_git_using_command for-each-ref
67	184	-> set -l cmd (__fish_git_needs_command)
9	117	--> __fish_git_needs_command
61	70	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
10	10	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
48	58	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
28	336	> __fish_git_using_command config
88	201	-> set -l cmd (__fish_git_needs_command)
10	113	--> __fish_git_needs_command
58	66	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
8	8	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
71	81	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
29	345	> __fish_git_using_command help
74	222	-> set -l cmd (__fish_git_needs_command)
13	148	--> __fish_git_needs_command
83	95	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
6	40	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
9	9	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
60	67	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
28	343	> __fish_git_using_command blame
73	217	-> set -l cmd (__fish_git_needs_command)
11	144	--> __fish_git_needs_command
80	91	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
7	42	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
64	71	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
4	4	-> return 1
21	255	> __fish_git_using_command clean
54	170	-> set -l cmd (__fish_git_needs_command)
10	116	--> __fish_git_needs_command
55	66	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
10	40	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	231	> __fish_git_using_command submodule
52	153	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	358	> __fish_git_using_command format-patch
95	263	-> set -l cmd (__fish_git_needs_command)
12	168	--> __fish_git_needs_command
96	111	---> set -l cmdline "$(commandline -c)"
15	15	----> commandline -c
7	45	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
46	54	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	248	> __fish_git_using_command format-patch log
53	162	-> set -l cmd (__fish_git_needs_command)
9	109	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	258	> __fish_git_using_command stash
56	175	-> set -l cmd (__fish_git_needs_command)
10	119	--> __fish_git_needs_command
59	66	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
11	43	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	235	> __fish_git_using_command worktree
51	154	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	228	> __fish_git_using_command update-index
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	231	> __fish_git_using_command tag
51	154	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	231	> __fish_git_using_command stripspace
52	153	-> set -l cmd (__fish_git_needs_command)
10	101	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	232	> __fish_git_using_command status
52	156	-> set -l cmd (__fish_git_needs_command)
10	104	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	235	> __fish_git_using_command rm
53	155	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
2	2	-> return 1
23	371	> __fish_git_using_command revert
52	157	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
137	168	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
31	31	--> string escape --style=var -- $cmd
9	9	-> set -q $varname
3	3	-> return 1
28	329	> __fish_git_using_command rev-parse
68	229	-> set -l cmd (__fish_git_needs_command)
12	161	--> __fish_git_needs_command
95	108	---> set -l cmdline "$(commandline -c)"
13	13	----> commandline -c
8	41	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
42	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
4	4	-> return 1
27	283	> __fish_git_using_command restore switch
69	193	-> set -l cmd (__fish_git_needs_command)
17	124	--> __fish_git_needs_command
63	72	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	237	> __fish_git_using_command switch
60	160	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	223	> __fish_git_using_command restore
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	233	> __fish_git_using_command reset
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
40	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
20	280	> __fish_git_using_command reflog
56	187	-> set -l cmd (__fish_git_needs_command)
13	131	--> __fish_git_needs_command
67	73	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	45	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
45	53	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
25	287	> __fish_git_using_command rebase
57	169	-> set -l cmd (__fish_git_needs_command)
8	112	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	42	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
9	22	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
62	69	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
9	9	-> set -q $varname
4	4	-> return 1
22	272	> __fish_git_using_command push
59	183	-> set -l cmd (__fish_git_needs_command)
10	124	--> __fish_git_needs_command
63	72	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	42	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
2	2	-> return 1
26	303	> __fish_git_using_command range-diff
59	189	-> set -l cmd (__fish_git_needs_command)
11	130	--> __fish_git_needs_command
67	78	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
7	41	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
53	62	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
9	9	-> set -q $varname
4	4	-> return 1
24	274	> __fish_git_using_command pull
58	172	-> set -l cmd (__fish_git_needs_command)
11	114	--> __fish_git_needs_command
57	65	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
47	54	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
4	4	-> return 1
23	350	> __fish_git_using_command prune
72	188	-> set -l cmd (__fish_git_needs_command)
10	116	--> __fish_git_needs_command
60	68	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
26	26	-> contains -- $cmd $argv
81	95	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
14	14	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
4	4	-> return 1
19	309	> __fish_git_using_command notes
58	221	-> set -l cmd (__fish_git_needs_command)
11	163	--> __fish_git_needs_command
94	103	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
16	49	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
41	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
27	272	> __fish_git_using_command mv
65	178	-> set -l cmd (__fish_git_needs_command)
11	113	--> __fish_git_needs_command
56	64	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
41	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
23	277	> __fish_git_using_command mergetool
51	156	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
65	73	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
10	10	-> set -q $varname
4	4	-> return 1
23	290	> __fish_git_using_command merge-base
60	181	-> set -l cmd (__fish_git_needs_command)
10	121	--> __fish_git_needs_command
59	68	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	43	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
54	62	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
21	252	> __fish_git_using_command merge
55	167	-> set -l cmd (__fish_git_needs_command)
8	112	--> __fish_git_needs_command
57	65	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
28	268	> __fish_git_using_command maintenance
54	173	-> set -l cmd (__fish_git_needs_command)
12	119	--> __fish_git_needs_command
61	69	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
23	321	> __fish_git_using_command mailsplit
70	214	-> set -l cmd (__fish_git_needs_command)
13	144	--> __fish_git_needs_command
80	86	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	45	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
5	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
9	9	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
50	59	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
22	262	> __fish_git_using_command mailsplit am
56	174	-> set -l cmd (__fish_git_needs_command)
11	118	--> __fish_git_needs_command
60	68	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	241	> __fish_git_using_command mailinfo
53	160	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	272	> __fish_git_using_command mailinfo am
59	182	-> set -l cmd (__fish_git_needs_command)
14	123	--> __fish_git_needs_command
61	68	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	41	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
22	308	> __fish_git_using_command ls-files
76	211	-> set -l cmd (__fish_git_needs_command)
12	135	--> __fish_git_needs_command
72	79	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	44	---> if set -q __fish_git_cmdline...
12	12	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
9	9	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
43	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
22	285	> __fish_git_using_command log
59	197	-> set -l cmd (__fish_git_needs_command)
12	138	--> __fish_git_needs_command
73	85	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
7	41	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
25	293	> __fish_git_using_command init
64	173	-> set -l cmd (__fish_git_needs_command)
9	109	--> __fish_git_needs_command
57	64	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
9	9	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
55	66	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
4	4	-> return 1
31	356	> __fish_git_using_command grep
76	212	-> set -l cmd (__fish_git_needs_command)
11	136	--> __fish_git_needs_command
71	79	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	46	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
9	26	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
10	10	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
59	68	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
20	20	-> set -q $varname
6	6	-> return 1
41	395	> __fish_git_using_command gc
72	261	-> set -l cmd (__fish_git_needs_command)
29	189	--> __fish_git_needs_command
97	109	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
5	51	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
11	31	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
13	13	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
61	69	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
9	9	-> set -q $varname
4	4	-> return 1
21	262	> __fish_git_using_command difftool
59	170	-> set -l cmd (__fish_git_needs_command)
10	111	--> __fish_git_needs_command
58	65	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
45	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	241	> __fish_git_using_command diff
53	155	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	237	> __fish_git_using_command describe
53	154	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
41	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
26	282	> __fish_git_using_command daemon
58	184	-> set -l cmd (__fish_git_needs_command)
11	126	--> __fish_git_needs_command
60	70	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
8	45	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
41	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	251	> __fish_git_using_command count-objects
54	164	-> set -l cmd (__fish_git_needs_command)
10	110	--> __fish_git_needs_command
53	61	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	234	> __fish_git_using_command commit
52	155	-> set -l cmd (__fish_git_needs_command)
11	103	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
4	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	234	> __fish_git_using_command clone
52	156	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	234	> __fish_git_using_command cherry-pick
51	154	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	232	> __fish_git_using_command cherry
52	153	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	234	> __fish_git_using_command bundle
51	155	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
9	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command branch
52	151	-> set -l cmd (__fish_git_needs_command)
10	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	233	> __fish_git_using_command bisect
52	153	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	229	> __fish_git_using_command archive
52	151	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	229	> __fish_git_using_command apply
52	153	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
5	5	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	240	> __fish_git_using_command apply am
51	155	-> set -l cmd (__fish_git_needs_command)
13	104	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	292	> __fish_git_using_command checkout
58	197	-> set -l cmd (__fish_git_needs_command)
16	139	--> __fish_git_needs_command
70	76	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	47	---> if set -q __fish_git_cmdline...
7	7	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
7	22	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
43	52	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	250	> __fish_git_using_command am
54	167	-> set -l cmd (__fish_git_needs_command)
9	113	--> __fish_git_needs_command
56	64	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	40	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
14	186	> __fish_git_using_command add
52	160	-> set -l cmd (__fish_git_needs_command)
8	108	--> __fish_git_needs_command
54	63	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
2	2	-> return 0
73	176640	> __fish_git_files modified untracked deleted unmerged modified-staged-deleted
97	58513	-> set -l root (__fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null)
56	58416	--> __fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null
12	12	---> set -l saved_args $argv
5	5	---> set -l global_args
36	44	---> set -l cmd (commandline -opc)
8	8	----> commandline -opc
6	6	---> set -e cmd[1]
8	331	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
126	162	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	36	-----> __fish_git_global_optspecs
26	26	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
44	152	----> set -l num_global_args (math (count $cmd) - (count $argv))
85	108	-----> math (count $cmd) - (count $argv)
12	12	------> count $cmd
11	11	------> count $argv
1	9	----> if test $num_global_args -ne 0...
8	8	-----> test $num_global_args -ne 0
76	57962	---> eval command git $global_args \$saved_args 2>/dev/null
57886	57886	----> command git $saved_args
17	17	-> test "$root[2]" = true
7	7	-> set -e root[2]
14	14	-> contains -- all-staged $argv
8	8	-> contains -- unmerged $argv
5	5	-> set -l unmerged
8	8	-> set -l unmerged_desc "Unmerged File"
7	7	-> contains -- added $argv
3	3	-> set -ql all_staged
6	6	-> contains -- modified $argv
4	4	-> set -l modified
5	5	-> set -l modified_desc "Modified file"
7	7	-> contains -- untracked $argv
4	4	-> set -l untracked
5	5	-> set -l untracked_desc "Untracked file"
7	7	-> contains -- modified-staged $argv
2	2	-> set -ql all_staged
7	7	-> contains -- modified-staged-deleted $argv
5	5	-> set -l modified_staged_deleted
7	7	-> set -l modified_staged_deleted_desc "Staged modified and deleted file"
6	6	-> contains -- deleted $argv
4	4	-> set -l deleted
7	7	-> set -l deleted_desc "Deleted file"
6	6	-> contains -- deleted-staged $argv
3	3	-> set -ql all_staged
7	7	-> contains -- ignored $argv
6	6	-> contains -- renamed $argv
7	7	-> contains -- copied $argv
5	5	-> set -l q '\\?'
1	7	-> if status test-feature qmark-noglob...
6	6	--> status test-feature qmark-noglob
4	4	-> set -l use_next
7	7	-> set -l status_opt --ignore-submodules=all
4	4	-> set -q ignored
3	3	-> set -q untracked
5	5	-> set -a status_opt -uall
7	7	-> set -l git_opt -c status.relativePaths -c core.quotePath=
84	54260	-> set -l ver (__fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2')
107	54176	--> __fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2'
14	14	---> set -l saved_args $argv
4	4	---> set -l global_args
41	52	---> set -l cmd (commandline -opc)
11	11	----> commandline -opc
12	12	---> set -e cmd[1]
11	341	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
137	175	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
15	38	-----> __fish_git_global_optspecs
23	23	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
49	143	----> set -l num_global_args (math (count $cmd) - (count $argv))
74	94	-----> math (count $cmd) - (count $argv)
12	12	------> count $cmd
8	8	------> count $argv
1	12	----> if test $num_global_args -ne 0...
11	11	-----> test $num_global_args -ne 0
59	53646	---> eval command git $global_args \$saved_args 2>/dev/null
53587	53587	----> command git $saved_args
49	63578	-> if test "$ver[1]" -gt 2 2>/dev/null...
43	43	--> test "$ver[1]" -gt 2 2>/dev/null
27	27	--> test "$ver[1]" -eq 2 -a "$ver[2]" -ge 11 2>/dev/null
164	63459	--> __fish_git $git_opt status --porcelain=2 $status_opt \
            | while read -la -d ' ' line
            set -l file
            set -l desc
            # The basic status format is "XY", where X is "our" state (meaning the staging area),
            # and "Y" is "their" state.
            # A "." means it's unmodified.
            switch "$line[1..2]"
                case 'u *'
                    # Unmerged
                    # "Unmerged entries have the following format; the first character is a "u" to distinguish from ordinary changed entries."
                    # "u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>"
                    # This is first to distinguish it from normal modifications et al.
                    set -ql unmerged
                    and set file "$line[11..-1]"
                    and set desc $unmerged_desc
                case '2 .R*' '2 R.*'
                    # Renamed/Copied
                    # From the docs: "Renamed or copied entries have the following format:"
                    # "2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>"
                    # Since <sep> is \t, we can't really parse it unambiguously.
                    # The "-z" format would be great here!
                    set -ql renamed
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    and set desc $renamed_desc
                case '2 RM*' '2 RT*'
                    # Staged as renamed, with unstaged modifications (issue #6031)
                    set -ql renamed
                    or set -ql modified
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql modified
                    and set --append desc $modified_desc
                case '2 RD*'
                    # Staged as renamed, but deleted in the worktree
                    set -ql renamed
                    or set -ql deleted
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql deleted
                    and set --append desc $deleted_desc
                case '2 .C*' '2 C.*'
                    set -ql copied
                    and set file (string replace -r '\t[^\t].*' '' -- "$line[10..-1]")
                    and set desc $copied_desc
                case '1 A.*'
                    # Additions are only shown here if they are staged.
                    # Otherwise it's an untracked file.
                    set -ql added
                    and set file "$line[9..-1]"
                    and set desc $added_desc
                case '1 AD*'
                    # Added files that were since deleted
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql deleted
                        set file "$line[9..-1]"
                        set desc $deleted_desc
                    end
                case "1 AM*" "1 AT*"
                    # Added files with additional modifications
                    # ("T" is type-changed. As of git 2.33 this appears to be undocumented.
                    # it happens when e.g. a file is replaced with a symlink.
                    # For our purposes it's the same as modified)
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    end
                case '1 .A*'
                    # Files added with git add --intent-to-add.
                    set -ql untracked
                    and set file "$line[9..-1]"
                    and set desc $untracked_desc
                case '1 .M*' '1 .T*'
                    # Modified
                    # From the docs: "Ordinary changed entries have the following format:"
                    # "1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>"
                    # Since <path> can contain spaces, print from element 9 onwards
                    set -ql modified
                    and set file "$line[9..-1]"
                    and set desc $modified_desc
                case '1 MD*' '1 TD*'
                    set -ql modified_staged_deleted
                    and set file "$line[9..-1]"
                    and set desc $modified_staged_deleted_desc
                case '1 M.*' '1 T.*'
                    # If the character is first ("M."), then that means it's "our" change,
                    # which means it is staged.
                    # This is useless for many commands - e.g. `checkout` won't do anything with this.
                    # So it needs to be requested explicitly.
                    set -ql modified_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_modified_desc
                case '1 MM*' '1 MT*' '1 TM*' '1 TT*'
                    # Staged-modified with unstaged modifications
                    # These need to be offered for both kinds of modified.
                    if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    else if set -ql modified_staged
                        set file "$line[9..-1]"
                        set desc $staged_modified_desc
                    end
                case '1 .D*'
                    set -ql deleted
                    and set file "$line[9..-1]"
                    and set desc $deleted_desc
                case '1 D.*'
                    # TODO: The docs are unclear on this.
                    # There is both X unmodified and Y either M or D ("not updated")
                    # and Y is D and X is unmodified or [MARC] ("deleted in work tree").
                    # For our purposes, we assume this is a staged deletion.
                    set -ql deleted_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_deleted_desc
                case "$q"' *'
                    # Untracked
                    # "? <path>" - print from element 2 on.
                    set -ql untracked
                    and set file "$line[2..-1]"
                    and set desc $untracked_desc
                case '! *'
                    # Ignored
                    # "! <path>" - print from element 2 on.
                    set -ql ignored
                    and set file "$line[2..-1]"
                    and set desc $ignored_desc
            end
            # Only try printing if the file was selected.
            if set -q file[1]
                for d in $desc
                    # Without "-z", git sometimes _quotes_ filenames.
                    # It adds quotes around it _and_ escapes the character.
                    # e.g. `"a\\b"`.
                    # We just remove the quotes and hope it works out.
                    # If this contains newlines or tabs,
                    # there is nothing we can do, but that's a general issue with scripted completions.
                    set file (string trim -c \" -- $file)
                    # The relative filename.
                    if string match -q './*' -- (commandline -ct)
                        printf './%s\t%s\n' $file $d
                    else
                        printf '%s\t%s\n' "$file" $d
                    end
                    # Now from repo root.
                    # Only do this if the filename isn't a simple child,
                    # or the current token starts with ":"
                    if string match -q '../*' -- $file
                        or string match -q ':*' -- (commandline -ct)
                        set -l fromroot (builtin realpath -- $file 2>/dev/null)
                        # `:` starts pathspec "magic", and the second `:` terminates it.
                        # `/` is the magic letter for "from repo root".
                        # If we didn't terminate it we'd have to escape any special chars
                        # (non-alphanumeric, glob or regex special characters, in whatever dialect git uses)
                        and set fromroot (string replace -- "$root/" ":/:" "$fromroot")
                        and printf '%s\t%s\n' "$fromroot" $d
                    end
                end
            end
        end
18	18	---> set -l saved_args $argv
5	5	---> set -l global_args
54	67	---> set -l cmd (commandline -opc)
13	13	----> commandline -opc
7	7	---> set -e cmd[1]
9	324	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
126	168	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
12	42	-----> __fish_git_global_optspecs
30	30	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
45	138	----> set -l num_global_args (math (count $cmd) - (count $argv))
73	93	-----> math (count $cmd) - (count $argv)
12	12	------> count $cmd
8	8	------> count $argv
1	9	----> if test $num_global_args -ne 0...
8	8	-----> test $num_global_args -ne 0
57	62407	---> eval command git $global_args \$saved_args 2>/dev/null
62350	62350	----> command git $saved_args
128	128	---> read -la -d ' ' line
8	8	---> set -l file
4	4	---> set -l desc
34	52	---> switch "$line[1..2]"...
5	5	----> set -ql modified
7	7	----> set file "$line[9..-1]"
6	6	----> set desc $modified_desc
10	264	---> if set -q file[1]...
4	4	----> set -q file[1]
11	250	----> for d in $desc...
54	66	-----> set file (string trim -c \" -- $file)
12	12	------> string trim -c \" -- $file
8	109	-----> if string match -q './*' -- (commandline -ct)...
64	79	------> string match -q './*' -- (commandline -ct)
15	15	-------> commandline -ct
22	22	------> printf '%s\t%s\n' "$file" $d
2	64	-----> if string match -q '../*' -- $file...
8	8	------> string match -q '../*' -- $file
45	54	------> string match -q ':*' -- (commandline -ct)
9	9	-------> commandline -ct
11	11	---> read -la -d ' ' line
25	293	> __fish_git_using_command show-branch
58	200	-> set -l cmd (__fish_git_needs_command)
11	142	--> __fish_git_needs_command
59	67	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	64	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
5	41	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
28	28	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
39	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	245	> __fish_git_using_command show
55	163	-> set -l cmd (__fish_git_needs_command)
9	108	--> __fish_git_needs_command
54	62	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
9	260	> __fish_git_needs_rev_files
34	251	-> __fish_git_using_command show
52	154	--> set -l cmd (__fish_git_needs_command)
10	102	---> __fish_git_needs_command
51	58	----> set -l cmdline "$(commandline -c)"
7	7	-----> commandline -c
7	34	----> if set -q __fish_git_cmdline...
3	3	-----> set -q __fish_git_cmdline
7	7	-----> test "$cmdline" = "$__fish_git_cmdline"
7	17	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
5	5	------> echo -- $__fish_git_cmd
2	2	------> return 1
4	4	--> test -z "$cmd"
6	6	--> contains -- $cmd $argv
39	45	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	---> string escape --style=var -- $cmd
5	5	--> set -q $varname
3	3	--> return 1
16	229	> __fish_git_using_command remote
51	154	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	228	> __fish_git_using_command filter-branch
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
26	325	> __fish_git_using_command fetch
82	190	-> set -l cmd (__fish_git_needs_command)
9	108	--> __fish_git_needs_command
52	64	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
10	10	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
65	76	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
10	10	-> set -q $varname
3	3	-> return 1
21	307	> __fish_git_using_command fetch pull
88	216	-> set -l cmd (__fish_git_needs_command)
12	128	--> __fish_git_needs_command
64	73	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	43	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	245	> __fish_git_using_command diff log show range-diff
54	160	-> set -l cmd (__fish_git_needs_command)
8	106	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	241	> __fish_git_using_command diff show range-diff
53	158	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	237	> __fish_git_using_command diff show range-diff apply
53	155	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
20	239	> __fish_git_using_command log show diff-tree rev-list
54	156	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
4	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
34	69	> __fish_disable_bracketed_paste 'git add kitty/kitty.conf '
35	35	-> printf "\e[?2004l"
20	1176	> fish_title git\ add\ kitty/kitty.conf\ 
13	1156	-> if not set -q INSIDE_EMACS...
14	14	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
8	8	--> set -q SSH_TTY
5	1105	--> if set -q argv[1]...
4	4	---> set -q argv[1]
145	1096	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
23	23	----> string sub -l 20 -- $argv[1]
98	928	----> prompt_pwd -d 1 -D 1
13	13	-----> set -l options h/help d/dir-length= D/full-length-dirs=
33	33	-----> argparse -n prompt_pwd $options -- $argv
1	9	-----> if set -q _flag_help...
8	8	------> set -q _flag_help
5	5	-----> set -q argv[1]
46	46	-----> set argv $PWD
8	8	-----> set -ql _flag_d
14	14	-----> set -l fish_prompt_pwd_dir_length $_flag_d
6	6	-----> set -q fish_prompt_pwd_dir_length
24	24	-----> set -l fulldirs 0
4	4	-----> set -ql _flag_D
8	8	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
41	657	-----> for path in $argv...
69	85	------> set -l realhome (string escape --style=regex -- ~)
16	16	-------> string escape --style=regex -- ~
80	119	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
39	39	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
16	412	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
27	27	-------> test "$fish_prompt_pwd_dir_length" -eq 0
19	19	-------> set -l full
15	255	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
15	15	--------> test $fish_prompt_pwd_full_dirs -gt 0
66	210	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
94	144	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
50	50	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
67	95	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
28	28	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
68620	68620	> git add kitty/kitty.conf
27	59	> __fish_enable_bracketed_paste
32	32	-> printf "\e[?2004h"
15	94	> fish_mode_prompt
37	79	-> fish_default_mode_prompt
8	42	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
26	26	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
44	226051	> fish_prompt
15	15	-> set -l last_status $status
47	82	-> set -l normal (set_color normal)
35	35	--> set_color normal
60	69	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
80	100	-> set -l cwd_color (set_color $fish_color_cwd)
20	20	--> set_color $fish_color_cwd
42	53	-> set -l vcs_color (set_color brpurple)
11	11	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	151	-> if functions -q fish_is_root_user...
71	71	--> functions -q fish_is_root_user
19	78	--> fish_is_root_user
2	42	---> if test "$EUID" = 0 2>/dev/null...
40	40	----> test "$EUID" = 0 2>/dev/null
4	13	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
231	225495	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
44	361	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
183	292	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
44	71	----> prompt_hostname
27	27	-----> string replace -r -- "\..*" "" $hostname
11	11	----> set_color normal
39	293	--> prompt_pwd
15	15	---> set -l options h/help d/dir-length= D/full-length-dirs=
19	19	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
18	183	---> for path in $argv...
50	70	----> set -l realhome (string escape --style=regex -- ~)
20	20	-----> string escape --style=regex -- ~
44	75	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
31	31	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	20	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
53	224610	--> fish_vcs_prompt
115	224557	---> fish_git_prompt $argv
11	52211	----> if not command -sq git...
52200	52200	-----> not command -sq git
2	68	----> if functions -q __fish_git_prompt_ready...
66	66	-----> functions -q __fish_git_prompt_ready
131	58083	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57952	57952	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
63	57328	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
45	57265	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
23	92	------> if test -d $git_dir/rebase-merge...
19	19	-------> test -d $git_dir/rebase-merge
7	50	-------> if test -d $git_dir/rebase-apply...
9	9	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
9	9	--------> test -f $git_dir/CHERRY_PICK_HEAD
8	8	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
2	10	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
11	57026	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	57011	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
87	57009	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56922	56922	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
6	6	----> set -l dirtystate
5	5	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
6	6	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
6	6	----> set -l untracked
50483	56160	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5677	5677	-----> read -lz key value
11	47	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
15	15	----> contains dirtystate $__fish_git_prompt_status_order
4	18	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
10	10	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	77	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
6	48	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	14	------> begin...
11	11	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
5	5	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	46	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
60	72	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
3	27	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
14	14	-> echo -n -s $status_color $suffix ' ' $normal
18	753	> fish_title
17	735	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
9	699	--> if set -q argv[1]...
5	5	---> set -q argv[1]
53	60	---> set -l command (status current-command)
7	7	----> status current-command
3	14	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
84	611	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
10	10	----> string sub -l 20 -- $command
31	517	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
20	413	-----> for path in $argv...
58	69	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
75	109	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
34	34	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	215	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
14	14	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
5	127	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
8	8	--------> test $fish_prompt_pwd_full_dirs -gt 0
42	102	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
18	18	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	61	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
90	279	> __fish_disable_bracketed_paste 'git commit -m "changed: cursor config for kitty"'
189	189	-> printf "\e[?2004l"
62	2392	> fish_title git\ commit\ -m\ \"changed:\ cursor\ config\ for\ kitty\"
38	2330	-> if not set -q INSIDE_EMACS...
36	36	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
16	16	--> set -q SSH_TTY
23	2215	--> if set -q argv[1]...
16	16	---> set -q argv[1]
537	2176	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
34	34	----> string sub -l 20 -- $argv[1]
189	1605	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
66	66	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
11	11	-----> set -q argv[1]
19	19	-----> set argv $PWD
10	10	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
41	1184	-----> for path in $argv...
119	150	------> set -l realhome (string escape --style=regex -- ~)
31	31	-------> string escape --style=regex -- ~
134	210	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
76	76	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
31	783	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
12	12	-------> set -l full
18	416	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
114	347	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
141	233	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
92	92	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
240	296	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
56	56	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
92658	92658	> git commit -m "changed: cursor config for kitty"
26	57	> __fish_enable_bracketed_paste
31	31	-> printf "\e[?2004h"
15	88	> fish_mode_prompt
36	73	-> fish_default_mode_prompt
6	37	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
25	25	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
69	226670	> fish_prompt
17	17	-> set -l last_status $status
174	246	-> set -l normal (set_color normal)
72	72	--> set_color normal
57	98	-> set -l status_color (set_color brgreen)
41	41	--> set_color brgreen
41	53	-> set -l cwd_color (set_color $fish_color_cwd)
12	12	--> set_color $fish_color_cwd
64	71	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
31	31	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
35	35	-> set -l suffix '❯'
5	183	-> if functions -q fish_is_root_user...
89	89	--> functions -q fish_is_root_user
14	89	--> fish_is_root_user
2	40	---> if test "$EUID" = 0 2>/dev/null...
38	38	----> test "$EUID" = 0 2>/dev/null
2	31	---> if contains -- $USER root toor Administrator...
29	29	----> contains -- $USER root toor Administrator
4	4	---> return 1
0	8	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
140	225836	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
72	870	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
0	5	---> if set -q __fish_machine[1]...
5	5	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
337	774	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
35	35	----> set_color $fish_color_user
7	7	----> set_color normal
9	9	----> set_color $color_host
292	371	----> prompt_hostname
79	79	-----> string replace -r -- "\..*" "" $hostname
15	15	----> set_color normal
28	299	--> prompt_pwd
9	9	---> set -l options h/help d/dir-length= D/full-length-dirs=
17	17	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
8	8	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
19	205	---> for path in $argv...
54	66	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
59	96	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
37	37	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	24	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-----> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-----> echo $tmp
51	224527	--> fish_vcs_prompt
119	224476	---> fish_git_prompt $argv
12	50801	----> if not command -sq git...
50789	50789	-----> not command -sq git
1	77	----> if functions -q __fish_git_prompt_ready...
76	76	-----> functions -q __fish_git_prompt_ready
135	57382	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57247	57247	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
8	8	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
58	58671	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	58613	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
12	12	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
6	6	------> set -l operation
10	10	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
30	97	------> if test -d $git_dir/rebase-merge...
16	16	-------> test -d $git_dir/rebase-merge
6	51	-------> if test -d $git_dir/rebase-apply...
11	11	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
9	9	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	58357	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	58345	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	58342	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58254	58254	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
5	5	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50527	56858	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6331	6331	-----> read -lz key value
8	42	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
11	11	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	43	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	14	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
1	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
2	8	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
59	73	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
2	30	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
28	28	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
11	570	> fish_title
7	559	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	539	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	45	---> set -l command (status current-command)
7	7	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
68	473	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
23	398	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	305	-----> for path in $argv...
38	49	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
37	57	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	187	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	111	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	89	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
37	53	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
88	152	> __fish_disable_bracketed_paste 'git push'
64	64	-> printf "\e[?2004l"
152	2761	> fish_title git\ push
49	2609	-> if not set -q INSIDE_EMACS...
109	109	--> not set -q INSIDE_EMACS
38	38	--> set -l ssh
24	24	--> set -q SSH_TTY
50	2389	--> if set -q argv[1]...
12	12	---> set -q argv[1]
434	2327	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
32	32	----> string sub -l 20 -- $argv[1]
100	1861	----> prompt_pwd -d 1 -D 1
25	25	-----> set -l options h/help d/dir-length= D/full-length-dirs=
158	158	-----> argparse -n prompt_pwd $options -- $argv
5	31	-----> if set -q _flag_help...
26	26	------> set -q _flag_help
11	11	-----> set -q argv[1]
24	24	-----> set argv $PWD
10	10	-----> set -ql _flag_d
22	22	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
49	1424	-----> for path in $argv...
185	221	------> set -l realhome (string escape --style=regex -- ~)
36	36	-------> string escape --style=regex -- ~
147	221	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
74	74	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
35	933	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
30	499	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
223	401	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
142	178	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
35	35	--------> set tmp $all[1]
17	17	--------> set full $all[2..]
247	357	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
110	110	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
13458800	13458800	> git push
45	175	> __fish_enable_bracketed_paste
130	130	-> printf "\e[?2004h"
25	117	> fish_mode_prompt
27	92	-> fish_default_mode_prompt
11	65	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
40	40	---> test "$fish_key_bindings" = fish_vi_key_bindings
14	14	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
84	234873	> fish_prompt
34	34	-> set -l last_status $status
113	142	-> set -l normal (set_color normal)
29	29	--> set_color normal
133	154	-> set -l status_color (set_color brgreen)
21	21	--> set_color brgreen
140	172	-> set -l cwd_color (set_color $fish_color_cwd)
32	32	--> set_color $fish_color_cwd
146	167	-> set -l vcs_color (set_color brpurple)
21	21	--> set_color brpurple
27	27	-> set -l prompt_status ""
11	11	-> set -q fish_prompt_pwd_dir_length
11	11	-> set -lx fish_prompt_pwd_dir_length 0
12	12	-> set -l suffix '❯'
5	191	-> if functions -q fish_is_root_user...
22	22	--> functions -q fish_is_root_user
37	164	--> fish_is_root_user
4	94	---> if test "$EUID" = 0 2>/dev/null...
90	90	----> test "$EUID" = 0 2>/dev/null
3	24	---> if contains -- $USER root toor Administrator...
21	21	----> contains -- $USER root toor Administrator
9	9	---> return 1
3	18	-> if test $last_status -ne 0...
15	15	--> test $last_status -ne 0
347	233838	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
37	1206	--> prompt_login
4	15	---> if not set -q __fish_machine...
11	11	----> not set -q __fish_machine
2	11	---> if set -q __fish_machine[1]...
9	9	----> set -q __fish_machine[1]
22	22	---> set -l color_host $fish_color_host
3	11	---> if set -q SSH_TTY...
8	8	----> set -q SSH_TTY
851	1110	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
41	41	----> set_color $fish_color_user
38	38	----> set_color normal
42	42	----> set_color $color_host
48	108	----> prompt_hostname
60	60	-----> string replace -r -- "\..*" "" $hostname
30	30	----> set_color normal
137	1283	--> prompt_pwd
23	23	---> set -l options h/help d/dir-length= D/full-length-dirs=
33	33	---> argparse -n prompt_pwd $options -- $argv
4	14	---> if set -q _flag_help...
10	10	----> set -q _flag_help
8	8	---> set -q argv[1]
14	14	---> set argv $PWD
7	7	---> set -ql _flag_d
7	7	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
7	7	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
61	1005	---> for path in $argv...
257	413	----> set -l realhome (string escape --style=regex -- ~)
156	156	-----> string escape --style=regex -- ~
324	470	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
146	146	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
14	61	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-----> test "$fish_prompt_pwd_dir_length" -eq 0
19	19	-----> echo $tmp
24	231002	--> fish_vcs_prompt
103	230978	---> fish_git_prompt $argv
11	61069	----> if not command -sq git...
61058	61058	-----> not command -sq git
2	30	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
136	56265	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56129	56129	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
24	24	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
59	56672	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
42	56613	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
13	13	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
5	5	------> set -l operation
6	6	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
30	80	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	39	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	56377	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56365	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
90	56363	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56273	56273	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
9	9	----> set -l untrackedfiles
8	8	----> set -l c $rbc[4]
5	5	----> set -l p
8	8	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
20	20	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50334	56158	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5824	5824	-----> read -lz key value
8	79	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
53	53	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
6	20	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
9	9	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	82	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
10	52	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	12	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	17	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	13	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	8	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
7	7	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	50	----> for i in $__fish_git_prompt_status_order...
2	9	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
2	7	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
72	86	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	35	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	22	----> if test -z "$format"...
4	4	-----> test -z "$format"
14	14	-----> set format " (%s)"
31	31	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
12	696	> fish_title
7	684	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
6	660	--> if set -q argv[1]...
4	4	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
2	14	---> if test "$command" = fish...
7	7	----> test "$command" = fish
5	5	----> set command
69	592	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
29	514	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
7	7	-----> set argv $PWD
4	4	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
18	410	-----> for path in $argv...
51	62	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
54	86	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
32	32	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	244	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
13	13	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
6	158	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
44	134	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
47	90	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
43	43	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	61	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
31	57	> __fish_disable_bracketed_paste ls
26	26	-> printf "\e[?2004l"
17	1098	> fish_title ls
12	1081	-> if not set -q INSIDE_EMACS...
13	13	--> not set -q INSIDE_EMACS
9	9	--> set -l ssh
6	6	--> set -q SSH_TTY
35	1041	--> if set -q argv[1]...
6	6	---> set -q argv[1]
197	1000	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
16	16	----> string sub -l 20 -- $argv[1]
48	787	----> prompt_pwd -d 1 -D 1
13	13	-----> set -l options h/help d/dir-length= D/full-length-dirs=
34	34	-----> argparse -n prompt_pwd $options -- $argv
2	8	-----> if set -q _flag_help...
6	6	------> set -q _flag_help
5	5	-----> set -q argv[1]
9	9	-----> set argv $PWD
5	5	-----> set -ql _flag_d
10	10	-----> set -l fish_prompt_pwd_dir_length $_flag_d
5	5	-----> set -q fish_prompt_pwd_dir_length
7	7	-----> set -l fulldirs 0
4	4	-----> set -ql _flag_D
9	9	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
4	4	-----> set -q fish_prompt_pwd_full_dirs
44	626	-----> for path in $argv...
86	102	------> set -l realhome (string escape --style=regex -- ~)
16	16	-------> string escape --style=regex -- ~
86	135	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
49	49	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
13	345	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
16	16	-------> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-------> set -l full
11	198	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
8	8	--------> test $fish_prompt_pwd_full_dirs -gt 0
72	161	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
69	89	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
20	20	----------> math $fish_prompt_pwd_full_dirs - 1
10	10	--------> set tmp $all[1]
8	8	--------> set full $all[2..]
83	111	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
28	28	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
86	70381	> ls
70295	70295	-> eza -lha $argv
26	57	> __fish_enable_bracketed_paste
31	31	-> printf "\e[?2004h"
15	87	> fish_mode_prompt
38	72	-> fish_default_mode_prompt
3	34	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
23	23	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
45	225156	> fish_prompt
13	13	-> set -l last_status $status
65	97	-> set -l normal (set_color normal)
32	32	--> set_color normal
58	73	-> set -l status_color (set_color brgreen)
15	15	--> set_color brgreen
45	56	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
36	43	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
7	7	-> set -l suffix '❯'
3	138	-> if functions -q fish_is_root_user...
62	62	--> functions -q fish_is_root_user
15	73	--> fish_is_root_user
1	42	---> if test "$EUID" = 0 2>/dev/null...
41	41	----> test "$EUID" = 0 2>/dev/null
3	12	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
0	8	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
220	224629	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
45	349	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
179	279	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
42	68	----> prompt_hostname
26	26	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
36	342	--> prompt_pwd
14	14	---> set -l options h/help d/dir-length= D/full-length-dirs=
17	17	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
3	3	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
5	5	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
32	237	---> for path in $argv...
59	73	----> set -l realhome (string escape --style=regex -- ~)
14	14	-----> string escape --style=regex -- ~
72	105	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
33	33	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	27	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
14	14	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
51	223718	--> fish_vcs_prompt
126	223667	---> fish_git_prompt $argv
11	52099	----> if not command -sq git...
52088	52088	-----> not command -sq git
3	66	----> if functions -q __fish_git_prompt_ready...
63	63	-----> functions -q __fish_git_prompt_ready
136	57431	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57295	57295	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
9	9	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
69	56443	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
38	56374	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
28	82	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
6	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
11	56145	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	56130	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
83	56126	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56043	56043	---------> command git symbolic-ref HEAD 2>/dev/null
3	17	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
11	11	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
9	9	----> set -q __fish_git_prompt_status_order
2	8	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
23	23	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50929	56871	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5942	5942	-----> read -lz key value
9	47	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
20	20	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
17	17	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
17	86	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	50	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
4	15	------> begin...
11	11	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
7	7	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
2	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
67	79	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	27	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
25	25	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	39	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	20	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
12	12	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
0	5	----> if test -n "$f"...
5	5	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
32	32	-> echo -n -s $status_color $suffix ' ' $normal
18	792	> fish_title
9	774	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
5	5	--> set -q SSH_TTY
12	748	--> if set -q argv[1]...
21	21	---> set -q argv[1]
87	98	---> set -l command (status current-command)
11	11	----> status current-command
4	21	---> if test "$command" = fish...
10	10	----> test "$command" = fish
7	7	----> set command
103	596	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
14	14	----> string sub -l 20 -- $command
35	479	----> prompt_pwd -d 1 -D 1
20	20	-----> set -l options h/help d/dir-length= D/full-length-dirs=
39	39	-----> argparse -n prompt_pwd $options -- $argv
1	7	-----> if set -q _flag_help...
6	6	------> set -q _flag_help
3	3	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
17	339	-----> for path in $argv...
47	59	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
38	60	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	203	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	117	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	94	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	54	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
46	64	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
53	194	> __fish_disable_bracketed_paste ff
141	141	-> printf "\e[?2004l"
34	2447	> fish_title ff
26	2413	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
10	10	--> set -q SSH_TTY
20	2339	--> if set -q argv[1]...
11	11	---> set -q argv[1]
435	2308	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
203	1842	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
68	68	-----> argparse -n prompt_pwd $options -- $argv
5	17	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
11	11	-----> set -q argv[1]
20	20	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
10	10	-----> set -q fish_prompt_pwd_full_dirs
42	1406	-----> for path in $argv...
116	147	------> set -l realhome (string escape --style=regex -- ~)
31	31	-------> string escape --style=regex -- ~
133	196	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
63	63	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
42	1021	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
12	12	-------> set -l full
42	659	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
205	556	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
256	351	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
95	95	----------> math $fish_prompt_pwd_full_dirs - 1
30	30	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
211	279	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
68	68	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
85	210481	> ff
210396	210396	-> fastfetch $argv
24	54	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
15	97	> fish_mode_prompt
48	82	-> fish_default_mode_prompt
3	34	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
23	23	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
35	230713	> fish_prompt
15	15	-> set -l last_status $status
72	113	-> set -l normal (set_color normal)
41	41	--> set_color normal
80	99	-> set -l status_color (set_color brgreen)
19	19	--> set_color brgreen
54	69	-> set -l cwd_color (set_color $fish_color_cwd)
15	15	--> set_color $fish_color_cwd
47	56	-> set -l vcs_color (set_color brpurple)
9	9	--> set_color brpurple
8	8	-> set -l prompt_status ""
6	6	-> set -q fish_prompt_pwd_dir_length
6	6	-> set -lx fish_prompt_pwd_dir_length 0
7	7	-> set -l suffix '❯'
3	213	-> if functions -q fish_is_root_user...
89	89	--> functions -q fish_is_root_user
22	121	--> fish_is_root_user
2	50	---> if test "$EUID" = 0 2>/dev/null...
48	48	----> test "$EUID" = 0 2>/dev/null
7	44	---> if contains -- $USER root toor Administrator...
37	37	----> contains -- $USER root toor Administrator
5	5	---> return 1
1	10	-> if test $last_status -ne 0...
9	9	--> test $last_status -ne 0
170	230064	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
69	677	--> prompt_login
10	25	---> if not set -q __fish_machine...
15	15	----> not set -q __fish_machine
2	11	---> if set -q __fish_machine[1]...
9	9	----> set -q __fish_machine[1]
10	10	---> set -l color_host $fish_color_host
2	6	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
331	556	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
16	16	----> set_color $fish_color_user
8	8	----> set_color normal
10	10	----> set_color $color_host
62	170	----> prompt_hostname
108	108	-----> string replace -r -- "\..*" "" $hostname
21	21	----> set_color normal
33	291	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
18	18	---> argparse -n prompt_pwd $options -- $argv
2	7	---> if set -q _flag_help...
5	5	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
4	4	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
6	6	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
16	184	---> for path in $argv...
51	65	----> set -l realhome (string escape --style=regex -- ~)
14	14	-----> string escape --style=regex -- ~
47	75	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
28	28	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	28	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-----> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-----> echo $tmp
49	228926	--> fish_vcs_prompt
106	228877	---> fish_git_prompt $argv
12	53311	----> if not command -sq git...
53299	53299	-----> not command -sq git
2	70	----> if functions -q __fish_git_prompt_ready...
68	68	-----> functions -q __fish_git_prompt_ready
127	58594	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58467	58467	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
85	58500	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	58415	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
3	3	------> set -l total
24	73	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	38	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
9	58198	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	58185	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
84	58183	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58099	58099	---------> command git symbolic-ref HEAD 2>/dev/null
6	20	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
51701	57715	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6014	6014	-----> read -lz key value
5	41	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	72	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
5	44	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	12	------> begin...
10	10	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
69	82	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	33	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
30	30	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	738	> fish_title
7	728	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
3	3	--> set -q SSH_TTY
19	708	--> if set -q argv[1]...
3	3	---> set -q argv[1]
51	57	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
64	616	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
23	545	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
30	30	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
8	8	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
8	8	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	435	-----> for path in $argv...
64	77	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
64	102	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
38	38	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
10	241	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
5	150	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
49	126	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
59	77	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
18	18	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
44	66	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
22	22	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
22	44	> __fish_disable_bracketed_paste hyfetch
22	22	-> printf "\e[?2004l"
-255	596	> fish_title hyfetch
8	584	-> if not set -q INSIDE_EMACS...
10	10	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
4	4	--> set -q SSH_TTY
8	555	--> if set -q argv[1]...
3	3	---> set -q argv[1]
90	544	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
12	12	----> string sub -l 20 -- $argv[1]
24	442	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
26	26	-----> argparse -n prompt_pwd $options -- $argv
3	6	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	340	-----> for path in $argv...
41	51	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
38	68	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
30	30	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	207	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
6	119	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	97	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
45	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
49	67	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
27	267	-> fish_command_not_found hyfetch
31	240	--> __fish_default_command_not_found_handler $argv
183	209	---> printf (_ "fish: Unknown command: %s\n") (string escape -- $argv[1]) >&2
13	13	----> _ "fish: Unknown command: %s\n"
13	13	----> string escape -- $argv[1]
14	30	> __fish_enable_bracketed_paste
16	16	-> printf "\e[?2004h"
7	41	> fish_mode_prompt
11	34	-> fish_default_mode_prompt
3	23	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
14	14	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
27	235318	> fish_prompt
13	13	-> set -l last_status $status
50	61	-> set -l normal (set_color normal)
11	11	--> set_color normal
53	67	-> set -l status_color (set_color brgreen)
14	14	--> set_color brgreen
45	57	-> set -l cwd_color (set_color $fish_color_cwd)
12	12	--> set_color $fish_color_cwd
34	41	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	86	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
14	74	--> fish_is_root_user
2	46	---> if test "$EUID" = 0 2>/dev/null...
44	44	----> test "$EUID" = 0 2>/dev/null
1	11	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
3	3	---> return 1
4	73	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
40	50	--> set status_color (set_color $fish_color_error)
10	10	---> set_color $fish_color_error
11	11	--> set prompt_status $status_color "[" $last_status "]" $normal
117	234861	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
13	250	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
150	214	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
9	9	----> set_color $fish_color_user
6	6	----> set_color normal
7	7	----> set_color $color_host
11	35	----> prompt_hostname
24	24	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
21	235	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
16	16	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
8	8	---> set -l fish_prompt_pwd_full_dirs 1
18	150	---> for path in $argv...
39	54	----> set -l realhome (string escape --style=regex -- ~)
15	15	-----> string escape --style=regex -- ~
37	61	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
11	234259	--> fish_vcs_prompt
76	234248	---> fish_git_prompt $argv
13	55091	----> if not command -sq git...
55078	55078	-----> not command -sq git
3	31	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
125	62690	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
62565	62565	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
61	59013	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
38	58952	-----> __fish_git_prompt_operation_branch_bare $repo_info
8	8	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
24	75	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
6	39	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
9	58737	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	58724	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
94	58720	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58626	58626	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
9	9	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
12	12	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50630	56776	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6146	6146	-----> read -lz key value
6	43	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
18	18	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	70	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
4	43	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
2	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	47	----> for i in $__fish_git_prompt_status_order...
2	8	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
72	84	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
1	20	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
19	19	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	31	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
0	4	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
31	31	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	606	> fish_title
8	597	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
6	576	--> if set -q argv[1]...
4	4	---> set -q argv[1]
36	41	---> set -l command (status current-command)
5	5	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
68	513	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
26	438	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	341	-----> for path in $argv...
43	53	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
40	60	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	214	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	109	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
38	87	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	49	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
11	11	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
65	82	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
68	92	> __fish_enable_bracketed_paste
24	24	-> printf "\e[?2004h"
27	73	> fish_mode_prompt
15	46	-> fish_default_mode_prompt
5	31	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
17	17	---> test "$fish_key_bindings" = fish_vi_key_bindings
9	9	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
56	268792	> fish_prompt
20	20	-> set -l last_status $status
83	102	-> set -l normal (set_color normal)
19	19	--> set_color normal
122	142	-> set -l status_color (set_color brgreen)
20	20	--> set_color brgreen
100	123	-> set -l cwd_color (set_color $fish_color_cwd)
23	23	--> set_color $fish_color_cwd
89	108	-> set -l vcs_color (set_color brpurple)
19	19	--> set_color brpurple
15	15	-> set -l prompt_status ""
7	7	-> set -q fish_prompt_pwd_dir_length
15	15	-> set -lx fish_prompt_pwd_dir_length 0
8	8	-> set -l suffix '❯'
5	167	-> if functions -q fish_is_root_user...
15	15	--> functions -q fish_is_root_user
19	147	--> fish_is_root_user
5	102	---> if test "$EUID" = 0 2>/dev/null...
97	97	----> test "$EUID" = 0 2>/dev/null
3	20	---> if contains -- $USER root toor Administrator...
17	17	----> contains -- $USER root toor Administrator
6	6	---> return 1
8	164	-> if test $last_status -ne 0...
11	11	--> test $last_status -ne 0
104	122	--> set status_color (set_color $fish_color_error)
18	18	---> set_color $fish_color_error
23	23	--> set prompt_status $status_color "[" $last_status "]" $normal
220	267853	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
26	682	--> prompt_login
2	8	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
4	38	---> if set -q __fish_machine[1]...
34	34	----> set -q __fish_machine[1]
24	24	---> set -l color_host $fish_color_host
3	8	---> if set -q SSH_TTY...
5	5	----> set -q SSH_TTY
432	578	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
18	18	----> set_color $fish_color_user
15	15	----> set_color normal
31	31	----> set_color $color_host
29	55	----> prompt_hostname
26	26	-----> string replace -r -- "\..*" "" $hostname
27	27	----> set_color normal
32	348	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
18	18	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
27	249	---> for path in $argv...
73	88	----> set -l realhome (string escape --style=regex -- ~)
15	15	-----> string escape --style=regex -- ~
62	99	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
37	37	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	35	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-----> test "$fish_prompt_pwd_dir_length" -eq 0
17	17	-----> echo $tmp
20	266603	--> fish_vcs_prompt
106	266583	---> fish_git_prompt $argv
9	74791	----> if not command -sq git...
74782	74782	-----> not command -sq git
1	27	----> if functions -q __fish_git_prompt_ready...
26	26	-----> functions -q __fish_git_prompt_ready
132	67130	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
66998	66998	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
58	64586	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	64528	-----> __fish_git_prompt_operation_branch_bare $repo_info
8	8	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
23	81	------> if test -d $git_dir/rebase-merge...
17	17	-------> test -d $git_dir/rebase-merge
4	41	-------> if test -d $git_dir/rebase-apply...
9	9	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
7	64300	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
3	64288	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	64285	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
64197	64197	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
12	12	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
12	12	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
53150	59394	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6244	6244	-----> read -lz key value
7	40	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	6	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
65	78	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	21	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
19	19	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
3	31	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
3	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
5	5	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
2	6	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
5	5	-----> test -z "$format"
4	4	-----> set format " (%s)"
26	26	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	556	> fish_title
7	547	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
6	527	--> if set -q argv[1]...
4	4	---> set -q argv[1]
34	40	---> set -l command (status current-command)
6	6	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
61	465	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
24	397	----> prompt_pwd -d 1 -D 1
12	12	-----> set -l options h/help d/dir-length= D/full-length-dirs=
20	20	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
8	8	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	298	-----> for path in $argv...
36	46	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
38	57	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
19	19	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	182	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
5	107	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	86	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	50	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
12	12	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
39	57	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
33	106	> __fish_disable_bracketed_paste clear
73	73	-> printf "\e[?2004l"
22	1082	> fish_title clear
12	1060	-> if not set -q INSIDE_EMACS...
10	10	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
5	1028	--> if set -q argv[1]...
4	4	---> set -q argv[1]
191	1019	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
12	12	----> string sub -l 20 -- $argv[1]
84	816	----> prompt_pwd -d 1 -D 1
17	17	-----> set -l options h/help d/dir-length= D/full-length-dirs=
27	27	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
20	641	-----> for path in $argv...
69	82	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
104	159	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
55	55	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
13	380	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
14	14	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
12	209	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
68	170	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
62	102	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
40	40	----------> math $fish_prompt_pwd_full_dirs - 1
14	14	--------> set tmp $all[1]
7	7	--------> set full $all[2..]
98	139	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
41	41	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
80256	80256	> clear
28	62	> __fish_enable_bracketed_paste
34	34	-> printf "\e[?2004h"
14	89	> fish_mode_prompt
39	75	-> fish_default_mode_prompt
5	36	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
24	24	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
46	273813	> fish_prompt
46	46	-> set -l last_status $status
102	152	-> set -l normal (set_color normal)
50	50	--> set_color normal
70	80	-> set -l status_color (set_color brgreen)
10	10	--> set_color brgreen
68	85	-> set -l cwd_color (set_color $fish_color_cwd)
17	17	--> set_color $fish_color_cwd
46	57	-> set -l vcs_color (set_color brpurple)
11	11	--> set_color brpurple
7	7	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
4	4	-> set -l suffix '❯'
8	193	-> if functions -q fish_is_root_user...
78	78	--> functions -q fish_is_root_user
17	107	--> fish_is_root_user
3	53	---> if test "$EUID" = 0 2>/dev/null...
50	50	----> test "$EUID" = 0 2>/dev/null
1	33	---> if contains -- $USER root toor Administrator...
32	32	----> contains -- $USER root toor Administrator
4	4	---> return 1
0	8	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
306	273104	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
47	589	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
358	516	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
7	7	----> set_color normal
18	18	----> set_color $color_host
72	111	----> prompt_hostname
39	39	-----> string replace -r -- "\..*" "" $hostname
10	10	----> set_color normal
31	300	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
17	17	---> argparse -n prompt_pwd $options -- $argv
3	7	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
23	201	---> for path in $argv...
47	60	----> set -l realhome (string escape --style=regex -- ~)
13	13	-----> string escape --style=regex -- ~
64	90	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	28	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
14	14	-----> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-----> echo $tmp
55	271909	--> fish_vcs_prompt
110	271854	---> fish_git_prompt $argv
11	62515	----> if not command -sq git...
62504	62504	-----> not command -sq git
4	71	----> if functions -q __fish_git_prompt_ready...
67	67	-----> functions -q __fish_git_prompt_ready
139	69924	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
69785	69785	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
66	69766	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
38	69700	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
7	7	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
27	80	------> if test -d $git_dir/rebase-merge...
14	14	-------> test -d $git_dir/rebase-merge
4	39	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
9	69477	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	69464	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	69462	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
69374	69374	---------> command git symbolic-ref HEAD 2>/dev/null
2	15	------> if test true = $inside_gitdir...
13	13	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
5	5	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
9	9	----> set -q __fish_git_prompt_status_order
4	9	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
62264	68876	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6612	6612	-----> read -lz key value
9	46	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
18	18	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
4	16	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	73	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
4	14	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	47	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
71	83	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	35	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
4	17	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
22	22	-> echo -n -s $status_color $suffix ' ' $normal
13	736	> fish_title
9	723	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
9	696	--> if set -q argv[1]...
3	3	---> set -q argv[1]
59	65	---> set -l command (status current-command)
6	6	----> status current-command
3	24	---> if test "$command" = fish...
16	16	----> test "$command" = fish
5	5	----> set command
107	595	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
40	479	----> prompt_pwd -d 1 -D 1
15	15	-----> set -l options h/help d/dir-length= D/full-length-dirs=
26	26	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	354	-----> for path in $argv...
44	57	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
43	68	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	215	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
5	125	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	103	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
48	63	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
44	68	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
24	24	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
34	62	> __fish_disable_bracketed_paste ff
28	28	-> printf "\e[?2004l"
19	1410	> fish_title ff
12	1391	-> if not set -q INSIDE_EMACS...
12	12	--> not set -q INSIDE_EMACS
18	18	--> set -l ssh
6	6	--> set -q SSH_TTY
10	1343	--> if set -q argv[1]...
6	6	---> set -q argv[1]
195	1327	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
19	19	----> string sub -l 20 -- $argv[1]
44	1113	----> prompt_pwd -d 1 -D 1
23	23	-----> set -l options h/help d/dir-length= D/full-length-dirs=
36	36	-----> argparse -n prompt_pwd $options -- $argv
2	9	-----> if set -q _flag_help...
7	7	------> set -q _flag_help
5	5	-----> set -q argv[1]
10	10	-----> set argv $PWD
5	5	-----> set -ql _flag_d
10	10	-----> set -l fish_prompt_pwd_dir_length $_flag_d
5	5	-----> set -q fish_prompt_pwd_dir_length
6	6	-----> set -l fulldirs 0
4	4	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
5	5	-----> set -q fish_prompt_pwd_full_dirs
33	935	-----> for path in $argv...
117	135	------> set -l realhome (string escape --style=regex -- ~)
18	18	-------> string escape --style=regex -- ~
189	232	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
43	43	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
17	535	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
18	18	-------> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-------> set -l full
18	302	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
9	9	--------> test $fish_prompt_pwd_full_dirs -gt 0
92	254	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
140	162	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
22	22	----------> math $fish_prompt_pwd_full_dirs - 1
13	13	--------> set tmp $all[1]
8	8	--------> set full $all[2..]
156	190	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
34	34	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
83	209620	> ff
209537	209537	-> fastfetch $argv
40	72	> __fish_enable_bracketed_paste
32	32	-> printf "\e[?2004h"
16	66	> fish_mode_prompt
19	50	-> fish_default_mode_prompt
4	31	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
45	236109	> fish_prompt
21	21	-> set -l last_status $status
73	89	-> set -l normal (set_color normal)
16	16	--> set_color normal
80	96	-> set -l status_color (set_color brgreen)
16	16	--> set_color brgreen
43	54	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
65	73	-> set -l vcs_color (set_color brpurple)
8	8	--> set_color brpurple
9	9	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
2	86	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
17	73	--> fish_is_root_user
2	42	---> if test "$EUID" = 0 2>/dev/null...
40	40	----> test "$EUID" = 0 2>/dev/null
1	11	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
3	3	---> return 1
1	20	-> if test $last_status -ne 0...
19	19	--> test $last_status -ne 0
185	235588	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
17	635	--> prompt_login
2	8	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	11	---> if set -q __fish_machine[1]...
10	10	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
412	585	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
32	32	----> set_color $fish_color_user
10	10	----> set_color normal
12	12	----> set_color $color_host
22	110	----> prompt_hostname
88	88	-----> string replace -r -- "\..*" "" $hostname
9	9	----> set_color normal
26	275	--> prompt_pwd
14	14	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
3	7	---> if set -q _flag_help...
4	4	----> set -q _flag_help
5	5	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
6	6	---> set -l fulldirs 0
5	5	---> set -ql _flag_D
7	7	---> set -q fish_prompt_pwd_full_dirs
9	9	---> set -l fish_prompt_pwd_full_dirs 1
22	168	---> for path in $argv...
48	60	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
38	65	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	21	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
12	234493	--> fish_vcs_prompt
95	234481	---> fish_git_prompt $argv
10	54448	----> if not command -sq git...
54438	54438	-----> not command -sq git
2	26	----> if functions -q __fish_git_prompt_ready...
24	24	-----> functions -q __fish_git_prompt_ready
130	60897	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
60767	60767	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
8	8	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
61	61184	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	61123	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
4	4	------> set -l branch
5	5	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	74	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
6	39	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
9	60896	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	60883	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	60879	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
60791	60791	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
12	12	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
24	24	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
51338	57236	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5898	5898	-----> read -lz key value
8	43	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
19	19	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
5	18	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
9	9	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
9	9	----> contains untrackedfiles $__fish_git_prompt_status_order
9	77	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
9	47	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
2	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	13	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
14	14	----> set -l f ""
18	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
57	70	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
1	29	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
28	28	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
11	695	> fish_title
8	684	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
6	662	--> if set -q argv[1]...
4	4	---> set -q argv[1]
34	40	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
105	599	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
24	485	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
2	2	-----> set -q fish_prompt_pwd_full_dirs
20	391	-----> for path in $argv...
50	60	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
56	87	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
31	31	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
14	224	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	124	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	99	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	59	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
52	71	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
131	218	> __fish_disable_bracketed_paste ff
87	87	-> printf "\e[?2004l"
32	2197	> fish_title ff
24	2165	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
11	11	--> set -q SSH_TTY
20	2091	--> if set -q argv[1]...
11	11	---> set -q argv[1]
328	2060	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
29	29	----> string sub -l 20 -- $argv[1]
92	1703	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
59	1382	-----> for path in $argv...
124	157	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
163	226	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
63	63	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
42	940	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
37	37	-------> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-------> set -l full
25	541	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
28	28	--------> test $fish_prompt_pwd_full_dirs -gt 0
207	445	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
192	238	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
46	46	----------> math $fish_prompt_pwd_full_dirs - 1
28	28	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
219	304	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
85	85	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
103	209353	> ff
209250	209250	-> fastfetch $argv
49	85	> __fish_enable_bracketed_paste
36	36	-> printf "\e[?2004h"
23	82	> fish_mode_prompt
20	59	-> fish_default_mode_prompt
7	39	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
24	24	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
44	542322	> fish_prompt
14	14	-> set -l last_status $status
63	80	-> set -l normal (set_color normal)
17	17	--> set_color normal
101	118	-> set -l status_color (set_color brgreen)
17	17	--> set_color brgreen
86	105	-> set -l cwd_color (set_color $fish_color_cwd)
19	19	--> set_color $fish_color_cwd
52	63	-> set -l vcs_color (set_color brpurple)
11	11	--> set_color brpurple
8	8	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
6	6	-> set -lx fish_prompt_pwd_dir_length 0
7	7	-> set -l suffix '❯'
2	102	-> if functions -q fish_is_root_user...
13	13	--> functions -q fish_is_root_user
17	87	--> fish_is_root_user
3	50	---> if test "$EUID" = 0 2>/dev/null...
47	47	----> test "$EUID" = 0 2>/dev/null
2	15	---> if contains -- $USER root toor Administrator...
13	13	----> contains -- $USER root toor Administrator
5	5	---> return 1
1	10	-> if test $last_status -ne 0...
9	9	--> test $last_status -ne 0
234	541739	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
19	416	--> prompt_login
2	8	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
2	6	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
13	13	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
270	365	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
13	13	----> set_color $fish_color_user
8	8	----> set_color normal
15	15	----> set_color $color_host
14	49	----> prompt_hostname
35	35	-----> string replace -r -- "\..*" "" $hostname
10	10	----> set_color normal
35	385	--> prompt_pwd
15	15	---> set -l options h/help d/dir-length= D/full-length-dirs=
32	32	---> argparse -n prompt_pwd $options -- $argv
3	8	---> if set -q _flag_help...
5	5	----> set -q _flag_help
4	4	---> set -q argv[1]
24	24	---> set argv $PWD
4	4	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
6	6	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
7	7	---> set -l fish_prompt_pwd_full_dirs 1
31	239	---> for path in $argv...
57	72	----> set -l realhome (string escape --style=regex -- ~)
15	15	-----> string escape --style=regex -- ~
48	78	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
30	30	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
15	58	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
23	23	-----> test "$fish_prompt_pwd_dir_length" -eq 0
20	20	-----> echo $tmp
17	540704	--> fish_vcs_prompt
142	540687	---> fish_git_prompt $argv
11	52536	----> if not command -sq git...
52525	52525	-----> not command -sq git
2	30	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
191	287816	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
287625	287625	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
24	24	----> test -n "$repo_info"
15	15	----> set -l git_dir $repo_info[1]
12	12	----> set -l inside_gitdir $repo_info[2]
11	11	----> set -l bare_repo $repo_info[3]
10	10	----> set -l inside_worktree $repo_info[4]
6	6	----> set -q repo_info[5]
10	10	----> set -l sha $repo_info[5]
94	103016	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
83	102922	-----> __fish_git_prompt_operation_branch_bare $repo_info
18	18	------> set -l git_dir $argv[1]
11	11	------> set -l inside_gitdir $argv[2]
9	9	------> set -l bare_repo $argv[3]
6	6	------> set -q argv[5]
14	14	------> set -l sha $argv[5]
7	7	------> set -l branch
7	7	------> set -l operation
6	6	------> set -l detached no
6	6	------> set -l bare
6	6	------> set -l step
6	6	------> set -l total
36	125	------> if test -d $git_dir/rebase-merge...
20	20	-------> test -d $git_dir/rebase-merge
10	69	-------> if test -d $git_dir/rebase-apply...
15	15	--------> test -d $git_dir/rebase-apply
12	12	--------> test -f $git_dir/MERGE_HEAD
12	12	--------> test -f $git_dir/CHERRY_PICK_HEAD
10	10	--------> test -f $git_dir/REVERT_HEAD
10	10	--------> test -f $git_dir/BISECT_LOG
3	20	------> if test -n "$step" -a -n "$total"...
17	17	-------> test -n "$step" -a -n "$total"
12	102538	------> if test -z "$branch"...
8	8	-------> test -z "$branch"
6	102518	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
152	102512	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
102360	102360	---------> command git symbolic-ref HEAD 2>/dev/null
2	21	------> if test true = $inside_gitdir...
19	19	-------> test true = $inside_gitdir
15	15	------> echo $operation
9	9	------> echo $branch
7	7	------> echo $detached
8	8	------> echo $bare
13	13	----> set -l r $rbc[1]
9	9	----> set -l b $rbc[2]
10	10	----> set -l detached $rbc[3]
7	7	----> set -l dirtystate
11	11	----> set -l stagedstate
7	7	----> set -l invalidstate
6	6	----> set -l stashstate
7	7	----> set -l untrackedfiles
11	11	----> set -l c $rbc[4]
6	6	----> set -l p
7	7	----> set -l informative_status
10	10	----> set -q __fish_git_prompt_status_order
2	10	----> if not set -q ___fish_git_prompt_init...
8	8	-----> not set -q ___fish_git_prompt_init
32	32	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
8	8	----> set -l informative
6	6	----> set -l dirty
10	10	----> set -l untracked
86940	96150	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
9210	9210	-----> read -lz key value
10	60	----> if not set -q dirty[1]...
25	25	-----> not set -q dirty[1]
25	25	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
23	23	----> contains dirtystate $__fish_git_prompt_status_order
6	26	----> if not set -q untracked[1]...
8	8	-----> not set -q untracked[1]
12	12	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
13	13	----> contains untrackedfiles $__fish_git_prompt_status_order
19	131	----> if test true = $inside_worktree...
11	11	-----> test true = $inside_worktree
11	78	-----> if test "$informative" = true...
9	9	------> test "$informative" = true
5	17	------> begin...
12	12	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
6	28	------> if not test "$dirty" = true...
9	9	-------> not test "$dirty" = true
7	7	-------> test "$untracked" = true
6	6	-------> test "$dirty" = true
2	13	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
11	11	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
6	23	-----> if set -q __fish_git_prompt_showupstream...
7	7	------> set -q __fish_git_prompt_showupstream
10	10	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
15	15	----> set -l branch_color $___fish_git_prompt_color_branch
11	11	----> set -l branch_done $___fish_git_prompt_color_branch_done
3	12	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
9	9	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
8	8	----> set -l f ""
35	86	----> for i in $__fish_git_prompt_status_order...
4	15	-----> if test -n "$$i"...
11	11	------> test -n "$$i"
2	10	-----> if test -n "$$i"...
8	8	------> test -n "$$i"
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	9	-----> if test -n "$$i"...
8	8	------> test -n "$$i"
2	9	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
107	126	----> set b (string replace refs/heads/ '' -- $b)
19	19	-----> string replace refs/heads/ '' -- $b
4	48	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
44	44	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
12	65	----> if test -n "$b"...
12	12	-----> test -n "$b"
13	13	-----> set b "$branch_color$b$branch_done"
5	28	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
11	11	------> test -z "$dirtystate$untrackedfiles$stagedstate"
12	12	------> test -n "$___fish_git_prompt_char_cleanstate"
2	9	----> if test -n "$c"...
7	7	-----> test -n "$c"
2	8	----> if test -n "$r"...
6	6	-----> test -n "$r"
1	7	----> if test -n "$p"...
6	6	-----> test -n "$p"
1	7	----> if test -n "$f"...
6	6	-----> test -n "$f"
12	12	----> set -l format $argv[1]
4	20	----> if test -z "$format"...
7	7	-----> test -z "$format"
9	9	-----> set format " (%s)"
52	52	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
21	21	-> echo -n -s $status_color $suffix ' ' $normal
22	1145	> fish_title
14	1123	-> if not set -q INSIDE_EMACS...
10	10	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
5	5	--> set -q SSH_TTY
11	1088	--> if set -q argv[1]...
5	5	---> set -q argv[1]
89	100	---> set -l command (status current-command)
11	11	----> status current-command
5	31	---> if test "$command" = fish...
19	19	----> test "$command" = fish
7	7	----> set command
109	941	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
10	10	----> string sub -l 20 -- $command
34	822	----> prompt_pwd -d 1 -D 1
10	10	-----> set -l options h/help d/dir-length= D/full-length-dirs=
33	33	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
3	3	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
4	4	-----> set -q fish_prompt_pwd_full_dirs
26	700	-----> for path in $argv...
58	70	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
61	94	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
33	33	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
21	510	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
11	327	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
72	280	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
186	208	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
22	22	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
10	10	--------> set full $all[2..]
101	147	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
46	46	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
46	177	> __fish_disable_bracketed_paste cd
131	131	-> printf "\e[?2004l"
27	1867	> fish_title cd
19	1840	-> if not set -q INSIDE_EMACS...
20	20	--> not set -q INSIDE_EMACS
19	19	--> set -l ssh
8	8	--> set -q SSH_TTY
8	1774	--> if set -q argv[1]...
33	33	---> set -q argv[1]
283	1733	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
21	21	----> string sub -l 20 -- $argv[1]
130	1429	----> prompt_pwd -d 1 -D 1
22	22	-----> set -l options h/help d/dir-length= D/full-length-dirs=
53	53	-----> argparse -n prompt_pwd $options -- $argv
3	12	-----> if set -q _flag_help...
9	9	------> set -q _flag_help
6	6	-----> set -q argv[1]
13	13	-----> set argv $PWD
6	6	-----> set -ql _flag_d
14	14	-----> set -l fish_prompt_pwd_dir_length $_flag_d
6	6	-----> set -q fish_prompt_pwd_dir_length
8	8	-----> set -l fulldirs 0
6	6	-----> set -ql _flag_D
11	11	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
6	6	-----> set -q fish_prompt_pwd_full_dirs
33	1136	-----> for path in $argv...
237	272	------> set -l realhome (string escape --style=regex -- ~)
35	35	-------> string escape --style=regex -- ~
127	192	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
65	65	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
21	639	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
21	21	-------> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-------> set -l full
24	364	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
11	11	--------> test $fish_prompt_pwd_full_dirs -gt 0
127	298	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
93	171	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
78	78	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
11	11	--------> set full $all[2..]
177	224	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
47	47	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
169	1678	> cd
18	18	-> set -l MAX_DIR_HIST 25
12	458	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)...
325	446	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
73	73	---> count $argv
31	31	---> test "$argv[1]" = "--"
17	17	---> echo 1
7	26	-> if status --is-command-substitution...
19	19	--> status --is-command-substitution
28	28	-> set -l previous $PWD
6	23	-> if test "$argv" = -...
17	17	--> test "$argv" = -
171	634	-> builtin cd $argv
151	463	--> __update_cwd_osc VARIABLE SET PWD
11	45	---> if status --is-command-substitution...
20	20	----> status --is-command-substitution
14	14	----> set -q INSIDE_EMACS
234	267	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
33	33	----> string escape --style=url $PWD
31	31	-> set -l cd_status $status
71	266	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"...
45	45	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
14	14	--> set -q dirprev
20	20	--> set -q dirprev[$MAX_DIR_HIST]
11	11	--> set -U -q dirprev
27	27	--> set -g -a dirprev $previous
11	11	--> set -U -q dirnext
11	11	--> set -e dirnext
9	9	--> set -U -q __fish_cd_direction
47	47	--> set -g __fish_cd_direction prev
25	25	-> return $cd_status
31	67	> __fish_enable_bracketed_paste
36	36	-> printf "\e[?2004h"
25	191	> fish_mode_prompt
117	166	-> fish_default_mode_prompt
7	49	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
30	30	---> test "$fish_key_bindings" = fish_vi_key_bindings
12	12	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
76	220147	> fish_prompt
22	22	-> set -l last_status $status
81	167	-> set -l normal (set_color normal)
86	86	--> set_color normal
219	305	-> set -l status_color (set_color brgreen)
86	86	--> set_color brgreen
134	166	-> set -l cwd_color (set_color $fish_color_cwd)
32	32	--> set_color $fish_color_cwd
219	266	-> set -l vcs_color (set_color brpurple)
47	47	--> set_color brpurple
25	25	-> set -l prompt_status ""
13	13	-> set -q fish_prompt_pwd_dir_length
15	15	-> set -lx fish_prompt_pwd_dir_length 0
16	16	-> set -l suffix '❯'
9	517	-> if functions -q fish_is_root_user...
176	176	--> functions -q fish_is_root_user
38	332	--> fish_is_root_user
8	196	---> if test "$EUID" = 0 2>/dev/null...
188	188	----> test "$EUID" = 0 2>/dev/null
4	90	---> if contains -- $USER root toor Administrator...
86	86	----> contains -- $USER root toor Administrator
8	8	---> return 1
2	18	-> if test $last_status -ne 0...
16	16	--> test $last_status -ne 0
232	218525	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
170	1022	--> prompt_login
7	60	---> if not set -q __fish_machine...
53	53	----> not set -q __fish_machine
2	14	---> if set -q __fish_machine[1]...
12	12	----> set -q __fish_machine[1]
20	20	---> set -l color_host $fish_color_host
2	59	---> if set -q SSH_TTY...
57	57	----> set -q SSH_TTY
468	699	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
28	28	----> set_color $fish_color_user
15	15	----> set_color normal
16	16	----> set_color $color_host
90	157	----> prompt_hostname
67	67	-----> string replace -r -- "\..*" "" $hostname
15	15	----> set_color normal
50	580	--> prompt_pwd
15	15	---> set -l options h/help d/dir-length= D/full-length-dirs=
25	25	---> argparse -n prompt_pwd $options -- $argv
3	11	---> if set -q _flag_help...
8	8	----> set -q _flag_help
8	8	---> set -q argv[1]
13	13	---> set argv $PWD
6	6	---> set -ql _flag_d
55	55	---> set -q fish_prompt_pwd_dir_length
18	18	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
6	6	---> set -q fish_prompt_pwd_full_dirs
8	8	---> set -l fish_prompt_pwd_full_dirs 1
33	359	---> for path in $argv...
124	147	----> set -l realhome (string escape --style=regex -- ~)
23	23	-----> string escape --style=regex -- ~
101	142	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
41	41	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	37	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
18	18	-----> test "$fish_prompt_pwd_dir_length" -eq 0
11	11	-----> echo $tmp
102	216691	--> fish_vcs_prompt
68	116178	---> fish_git_prompt $argv
10	59218	----> if not command -sq git...
59208	59208	-----> not command -sq git
2	63	----> if functions -q __fish_git_prompt_ready...
61	61	-----> functions -q __fish_git_prompt_ready
123	56808	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56685	56685	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
4	4	----> return
70	50305	---> fish_hg_prompt $argv
21	50235	----> if not command -sq hg...
50199	50199	-----> not command -sq hg
15	15	-----> return 1
82	50106	---> fish_fossil_prompt $argv
20	50024	----> if not command -sq fossil...
49990	49990	-----> not command -sq fossil
14	14	-----> return 1
16	16	-> echo -n -s $status_color $suffix ' ' $normal
11	585	> fish_title
7	574	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
5	549	--> if set -q argv[1]...
4	4	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
4	16	---> if test "$command" = fish...
8	8	----> test "$command" = fish
4	4	----> set command
65	480	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
25	407	----> prompt_pwd -d 1 -D 1
10	10	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	309	-----> for path in $argv...
38	53	------> set -l realhome (string escape --style=regex -- ~)
15	15	-------> string escape --style=regex -- ~
36	61	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	182	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	107	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	85	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	49	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
37	54	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
65	84	> __fish_complete_cd
14	14	-> set -q CDPATH[1]
5	5	-> return 0
69	116	> __fish_disable_bracketed_paste 'cd Projects/'
47	47	-> printf "\e[?2004l"
45	2394	> fish_title cd\ Projects/
25	2349	-> if not set -q INSIDE_EMACS...
28	28	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
10	2269	--> if set -q argv[1]...
11	11	---> set -q argv[1]
295	2248	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
208	1922	----> prompt_pwd -d 1 -D 1
41	41	-----> set -l options h/help d/dir-length= D/full-length-dirs=
71	71	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
11	11	-----> set -q argv[1]
18	18	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
51	1472	-----> for path in $argv...
246	296	------> set -l realhome (string escape --style=regex -- ~)
50	50	-------> string escape --style=regex -- ~
206	279	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
73	73	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
24	846	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
34	34	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
38	557	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
171	459	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
247	288	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
41	41	----------> math $fish_prompt_pwd_full_dirs - 1
26	26	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
158	216	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
58	58	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
106	1359	> cd Projects/
22	22	-> set -l MAX_DIR_HIST 25
16	389	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)...
297	373	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
31	31	---> count $argv
31	31	---> test "$argv[1]" = "--"
14	14	---> echo 1
7	26	-> if status --is-command-substitution...
19	19	--> status --is-command-substitution
32	32	-> set -l previous $PWD
4	25	-> if test "$argv" = -...
21	21	--> test "$argv" = -
181	524	-> builtin cd $argv
53	343	--> __update_cwd_osc VARIABLE SET PWD
8	34	---> if status --is-command-substitution...
14	14	----> status --is-command-substitution
12	12	----> set -q INSIDE_EMACS
227	256	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
29	29	----> string escape --style=url $PWD
26	26	-> set -l cd_status $status
50	196	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"...
40	40	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
11	11	--> set -q dirprev
17	17	--> set -q dirprev[$MAX_DIR_HIST]
11	11	--> set -U -q dirprev
22	22	--> set -g -a dirprev $previous
9	9	--> set -U -q dirnext
12	12	--> set -e dirnext
9	9	--> set -U -q __fish_cd_direction
15	15	--> set -g __fish_cd_direction prev
13	13	-> return $cd_status
27	59	> __fish_enable_bracketed_paste
32	32	-> printf "\e[?2004h"
22	84	> fish_mode_prompt
19	62	-> fish_default_mode_prompt
7	43	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
22	22	---> test "$fish_key_bindings" = fish_vi_key_bindings
14	14	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
94	222893	> fish_prompt
34	34	-> set -l last_status $status
126	150	-> set -l normal (set_color normal)
24	24	--> set_color normal
158	185	-> set -l status_color (set_color brgreen)
27	27	--> set_color brgreen
161	193	-> set -l cwd_color (set_color $fish_color_cwd)
32	32	--> set_color $fish_color_cwd
173	203	-> set -l vcs_color (set_color brpurple)
30	30	--> set_color brpurple
21	21	-> set -l prompt_status ""
11	11	-> set -q fish_prompt_pwd_dir_length
12	12	-> set -lx fish_prompt_pwd_dir_length 0
11	11	-> set -l suffix '❯'
11	380	-> if functions -q fish_is_root_user...
22	22	--> functions -q fish_is_root_user
36	347	--> fish_is_root_user
10	220	---> if test "$EUID" = 0 2>/dev/null...
210	210	----> test "$EUID" = 0 2>/dev/null
5	41	---> if contains -- $USER root toor Administrator...
36	36	----> contains -- $USER root toor Administrator
50	50	---> return 1
3	31	-> if test $last_status -ne 0...
28	28	--> test $last_status -ne 0
416	221548	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
87	1210	--> prompt_login
31	56	---> if not set -q __fish_machine...
25	25	----> not set -q __fish_machine
5	28	---> if set -q __fish_machine[1]...
23	23	----> set -q __fish_machine[1]
26	26	---> set -l color_host $fish_color_host
3	12	---> if set -q SSH_TTY...
9	9	----> set -q SSH_TTY
766	1001	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
50	50	----> set_color $fish_color_user
31	31	----> set_color normal
43	43	----> set_color $color_host
33	90	----> prompt_hostname
57	57	-----> string replace -r -- "\..*" "" $hostname
21	21	----> set_color normal
67	782	--> prompt_pwd
28	28	---> set -l options h/help d/dir-length= D/full-length-dirs=
101	101	---> argparse -n prompt_pwd $options -- $argv
4	15	---> if set -q _flag_help...
11	11	----> set -q _flag_help
9	9	---> set -q argv[1]
16	16	---> set argv $PWD
7	7	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
12	12	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
9	9	---> set -q fish_prompt_pwd_full_dirs
11	11	---> set -l fish_prompt_pwd_full_dirs 1
36	492	---> for path in $argv...
158	199	----> set -l realhome (string escape --style=regex -- ~)
41	41	-----> string escape --style=regex -- ~
137	204	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
67	67	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
12	53	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
24	24	-----> test "$fish_prompt_pwd_dir_length" -eq 0
17	17	-----> echo $tmp
27	219140	--> fish_vcs_prompt
35	118924	---> fish_git_prompt $argv
12	61680	----> if not command -sq git...
61668	61668	-----> not command -sq git
1	29	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
127	57161	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57034	57034	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
3	3	----> return
22	50686	---> fish_hg_prompt $argv
19	50664	----> if not command -sq hg...
50630	50630	-----> not command -sq hg
15	15	-----> return 1
29	49503	---> fish_fossil_prompt $argv
19	49474	----> if not command -sq fossil...
49438	49438	-----> not command -sq fossil
17	17	-----> return 1
20	20	-> echo -n -s $status_color $suffix ' ' $normal
12	626	> fish_title
6	614	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
4	4	--> set -q SSH_TTY
6	590	--> if set -q argv[1]...
4	4	---> set -q argv[1]
39	45	---> set -l command (status current-command)
6	6	----> status current-command
3	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
4	4	----> set command
67	520	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
25	445	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
12	12	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	342	-----> for path in $argv...
39	50	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
37	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	215	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	122	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	98	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	59	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
20	20	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
49	73	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
24	24	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
104	145	> __fish_disable_bracketed_paste ls
41	41	-> printf "\e[?2004l"
20	1515	> fish_title ls
15	1495	-> if not set -q INSIDE_EMACS...
15	15	--> not set -q INSIDE_EMACS
11	11	--> set -l ssh
7	7	--> set -q SSH_TTY
8	1447	--> if set -q argv[1]...
8	8	---> set -q argv[1]
211	1431	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
20	20	----> string sub -l 20 -- $argv[1]
58	1200	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
49	49	-----> argparse -n prompt_pwd $options -- $argv
2	12	-----> if set -q _flag_help...
10	10	------> set -q _flag_help
8	8	-----> set -q argv[1]
13	13	-----> set argv $PWD
6	6	-----> set -ql _flag_d
13	13	-----> set -l fish_prompt_pwd_dir_length $_flag_d
7	7	-----> set -q fish_prompt_pwd_dir_length
9	9	-----> set -l fulldirs 0
6	6	-----> set -ql _flag_D
10	10	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
6	6	-----> set -q fish_prompt_pwd_full_dirs
30	971	-----> for path in $argv...
97	128	------> set -l realhome (string escape --style=regex -- ~)
31	31	-------> string escape --style=regex -- ~
120	164	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
44	44	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
19	649	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
24	24	-------> test "$fish_prompt_pwd_dir_length" -eq 0
10	10	-------> set -l full
17	446	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
12	12	--------> test $fish_prompt_pwd_full_dirs -gt 0
174	388	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
186	214	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
28	28	----------> math $fish_prompt_pwd_full_dirs - 1
18	18	--------> set tmp $all[1]
11	11	--------> set full $all[2..]
106	150	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
44	44	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
83	75976	> ls
75893	75893	-> eza -lha $argv
30	60	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
22	73	> fish_mode_prompt
11	51	-> fish_default_mode_prompt
9	40	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
22	22	---> test "$fish_key_bindings" = fish_vi_key_bindings
9	9	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
43	210055	> fish_prompt
22	22	-> set -l last_status $status
49	63	-> set -l normal (set_color normal)
14	14	--> set_color normal
38	47	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
39	49	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
59	66	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
12	12	-> set -l prompt_status ""
9	9	-> set -q fish_prompt_pwd_dir_length
7	7	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	99	-> if functions -q fish_is_root_user...
20	20	--> functions -q fish_is_root_user
17	77	--> fish_is_root_user
2	42	---> if test "$EUID" = 0 2>/dev/null...
40	40	----> test "$EUID" = 0 2>/dev/null
1	14	---> if contains -- $USER root toor Administrator...
13	13	----> contains -- $USER root toor Administrator
4	4	---> return 1
2	9	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
173	209604	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
27	302	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
10	10	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
171	249	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
11	44	----> prompt_hostname
33	33	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
29	278	--> prompt_pwd
19	19	---> set -l options h/help d/dir-length= D/full-length-dirs=
20	20	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
4	4	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
5	5	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
18	166	---> for path in $argv...
44	60	----> set -l realhome (string escape --style=regex -- ~)
16	16	-----> string escape --style=regex -- ~
45	69	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	19	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
33	208851	--> fish_vcs_prompt
29	109243	---> fish_git_prompt $argv
12	52548	----> if not command -sq git...
52536	52536	-----> not command -sq git
2	33	----> if functions -q __fish_git_prompt_ready...
31	31	-----> functions -q __fish_git_prompt_ready
146	56613	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56467	56467	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
4	4	----> return
22	49543	---> fish_hg_prompt $argv
19	49521	----> if not command -sq hg...
49488	49488	-----> not command -sq hg
14	14	-----> return 1
27	50032	---> fish_fossil_prompt $argv
17	50005	----> if not command -sq fossil...
49969	49969	-----> not command -sq fossil
19	19	-----> return 1
20	20	-> echo -n -s $status_color $suffix ' ' $normal
10	718	> fish_title
8	708	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
4	4	--> set -q SSH_TTY
5	681	--> if set -q argv[1]...
4	4	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
2	16	---> if test "$command" = fish...
9	9	----> test "$command" = fish
5	5	----> set command
89	612	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
39	515	----> prompt_pwd -d 1 -D 1
14	14	-----> set -l options h/help d/dir-length= D/full-length-dirs=
32	32	-----> argparse -n prompt_pwd $options -- $argv
2	7	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
4	4	-----> set -q argv[1]
8	8	-----> set argv $PWD
4	4	-----> set -ql _flag_d
14	14	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
4	4	-----> set -q fish_prompt_pwd_full_dirs
18	371	-----> for path in $argv...
47	59	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
43	76	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
33	33	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	218	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
8	134	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
42	107	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
44	65	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
21	21	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	63	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
22	22	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
58	110	> __fish_disable_bracketed_paste clear
52	52	-> printf "\e[?2004l"
34	2366	> fish_title clear
25	2332	-> if not set -q INSIDE_EMACS...
26	26	--> not set -q INSIDE_EMACS
18	18	--> set -l ssh
11	11	--> set -q SSH_TTY
29	2252	--> if set -q argv[1]...
11	11	---> set -q argv[1]
400	2212	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
32	32	----> string sub -l 20 -- $argv[1]
95	1780	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
74	74	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
21	21	-----> set argv $PWD
10	10	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
49	1443	-----> for path in $argv...
170	207	------> set -l realhome (string escape --style=regex -- ~)
37	37	-------> string escape --style=regex -- ~
208	292	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
84	84	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
25	895	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
36	36	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
26	540	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
225	454	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
186	229	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
43	43	----------> math $fish_prompt_pwd_full_dirs - 1
27	27	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
186	279	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
93	93	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
69564	69564	> clear
32	65	> __fish_enable_bracketed_paste
33	33	-> printf "\e[?2004h"
12	60	> fish_mode_prompt
14	48	-> fish_default_mode_prompt
6	34	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
32	209786	> fish_prompt
13	13	-> set -l last_status $status
41	53	-> set -l normal (set_color normal)
12	12	--> set_color normal
36	45	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
35	44	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	42	-> set -l vcs_color (set_color brpurple)
9	9	--> set_color brpurple
6	6	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	80	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
13	67	--> fish_is_root_user
1	36	---> if test "$EUID" = 0 2>/dev/null...
35	35	----> test "$EUID" = 0 2>/dev/null
3	14	---> if contains -- $USER root toor Administrator...
11	11	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
143	209430	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
22	271	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
152	226	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
16	43	----> prompt_hostname
27	27	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
22	217	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
16	139	---> for path in $argv...
37	47	----> set -l realhome (string escape --style=regex -- ~)
10	10	-----> string escape --style=regex -- ~
39	59	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
13	208799	--> fish_vcs_prompt
22	109514	---> fish_git_prompt $argv
9	52143	----> if not command -sq git...
52134	52134	-----> not command -sq git
3	30	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
154	57300	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57146	57146	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
3	3	----> return
23	49596	---> fish_hg_prompt $argv
23	49573	----> if not command -sq hg...
49534	49534	-----> not command -sq hg
16	16	-----> return 1
36	49676	---> fish_fossil_prompt $argv
19	49640	----> if not command -sq fossil...
49606	49606	-----> not command -sq fossil
15	15	-----> return 1
19	19	-> echo -n -s $status_color $suffix ' ' $normal
12	681	> fish_title
9	669	-> if not set -q INSIDE_EMACS...
12	12	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
5	638	--> if set -q argv[1]...
4	4	---> set -q argv[1]
40	52	---> set -l command (status current-command)
12	12	----> status current-command
2	16	---> if test "$command" = fish...
9	9	----> test "$command" = fish
5	5	----> set command
71	561	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
28	482	----> prompt_pwd -d 1 -D 1
9	9	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
8	8	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
17	375	-----> for path in $argv...
41	53	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
36	65	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
29	29	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	240	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
5	154	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
47	132	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	85	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
43	43	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
47	66	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
36	56	> __fish_complete_cd
15	15	-> set -q CDPATH[1]
5	5	-> return 0
32	53	> __fish_complete_cd
16	16	-> set -q CDPATH[1]
5	5	-> return 0
67	110	> __fish_disable_bracketed_paste 'cd twitch-interactive-things/'
43	43	-> printf "\e[?2004l"
40	2235	> fish_title cd\ twitch-interactive-things/
26	2195	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
19	2119	--> if set -q argv[1]...
11	11	---> set -q argv[1]
360	2089	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
41	41	----> string sub -l 20 -- $argv[1]
90	1688	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
10	10	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
59	1367	-----> for path in $argv...
141	174	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
175	256	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
81	81	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
51	878	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
52	52	-------> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-------> set -l full
25	474	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
193	387	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
153	194	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
41	41	----------> math $fish_prompt_pwd_full_dirs - 1
29	29	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
220	285	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
65	65	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
112	1388	> cd twitch-interactive-things/
27	27	-> set -l MAX_DIR_HIST 25
9	420	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)...
305	411	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
49	49	---> count $argv
39	39	---> test "$argv[1]" = "--"
18	18	---> echo 1
5	22	-> if status --is-command-substitution...
17	17	--> status --is-command-substitution
30	30	-> set -l previous $PWD
6	24	-> if test "$argv" = -...
18	18	--> test "$argv" = -
190	502	-> builtin cd $argv
36	312	--> __update_cwd_osc VARIABLE SET PWD
7	32	---> if status --is-command-substitution...
13	13	----> status --is-command-substitution
12	12	----> set -q INSIDE_EMACS
213	244	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
31	31	----> string escape --style=url $PWD
27	27	-> set -l cd_status $status
57	211	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"...
41	41	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
12	12	--> set -q dirprev
17	17	--> set -q dirprev[$MAX_DIR_HIST]
10	10	--> set -U -q dirprev
30	30	--> set -g -a dirprev $previous
9	9	--> set -U -q dirnext
12	12	--> set -e dirnext
9	9	--> set -U -q __fish_cd_direction
14	14	--> set -g __fish_cd_direction prev
13	13	-> return $cd_status
34	64	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
14	65	> fish_mode_prompt
15	51	-> fish_default_mode_prompt
5	36	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
10	10	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
45	232896	> fish_prompt
20	20	-> set -l last_status $status
94	110	-> set -l normal (set_color normal)
16	16	--> set_color normal
117	139	-> set -l status_color (set_color brgreen)
22	22	--> set_color brgreen
89	112	-> set -l cwd_color (set_color $fish_color_cwd)
23	23	--> set_color $fish_color_cwd
107	123	-> set -l vcs_color (set_color brpurple)
16	16	--> set_color brpurple
15	15	-> set -l prompt_status ""
8	8	-> set -q fish_prompt_pwd_dir_length
8	8	-> set -lx fish_prompt_pwd_dir_length 0
9	9	-> set -l suffix '❯'
5	157	-> if functions -q fish_is_root_user...
23	23	--> functions -q fish_is_root_user
20	129	--> fish_is_root_user
4	84	---> if test "$EUID" = 0 2>/dev/null...
80	80	----> test "$EUID" = 0 2>/dev/null
2	18	---> if contains -- $USER root toor Administrator...
16	16	----> contains -- $USER root toor Administrator
7	7	---> return 1
1	13	-> if test $last_status -ne 0...
12	12	--> test $last_status -ne 0
228	232125	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
29	628	--> prompt_login
3	11	---> if not set -q __fish_machine...
8	8	----> not set -q __fish_machine
2	8	---> if set -q __fish_machine[1]...
6	6	----> set -q __fish_machine[1]
13	13	---> set -l color_host $fish_color_host
2	7	---> if set -q SSH_TTY...
5	5	----> set -q SSH_TTY
403	560	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
17	17	----> set_color $fish_color_user
21	21	----> set_color normal
27	27	----> set_color $color_host
22	79	----> prompt_hostname
57	57	-----> string replace -r -- "\..*" "" $hostname
13	13	----> set_color normal
40	457	--> prompt_pwd
16	16	---> set -l options h/help d/dir-length= D/full-length-dirs=
29	29	---> argparse -n prompt_pwd $options -- $argv
2	10	---> if set -q _flag_help...
8	8	----> set -q _flag_help
6	6	---> set -q argv[1]
11	11	---> set argv $PWD
6	6	---> set -ql _flag_d
6	6	---> set -q fish_prompt_pwd_dir_length
8	8	---> set -l fulldirs 0
12	12	---> set -ql _flag_D
6	6	---> set -q fish_prompt_pwd_full_dirs
7	7	---> set -l fish_prompt_pwd_full_dirs 1
30	300	---> for path in $argv...
74	93	----> set -l realhome (string escape --style=regex -- ~)
19	19	-----> string escape --style=regex -- ~
92	134	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
42	42	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	43	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
18	18	-----> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-----> echo $tmp
18	230812	--> fish_vcs_prompt
91	230794	---> fish_git_prompt $argv
10	55225	----> if not command -sq git...
55215	55215	-----> not command -sq git
3	26	----> if functions -q __fish_git_prompt_ready...
23	23	-----> functions -q __fish_git_prompt_ready
129	60415	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
60286	60286	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
60	57354	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	57294	-----> __fish_git_prompt_operation_branch_bare $repo_info
7	7	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
3	3	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
3	3	------> set -l total
25	108	------> if test -d $git_dir/rebase-merge...
18	18	-------> test -d $git_dir/rebase-merge
5	65	-------> if test -d $git_dir/rebase-apply...
9	9	--------> test -d $git_dir/rebase-apply
13	13	--------> test -f $git_dir/MERGE_HEAD
16	16	--------> test -f $git_dir/CHERRY_PICK_HEAD
12	12	--------> test -f $git_dir/REVERT_HEAD
10	10	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
7	57047	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	57036	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
86	57033	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56947	56947	---------> command git symbolic-ref HEAD 2>/dev/null
2	15	------> if test true = $inside_gitdir...
13	13	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	9	----> if not set -q ___fish_git_prompt_init...
8	8	-----> not set -q ___fish_git_prompt_init
12	12	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50905	57136	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6231	6231	-----> read -lz key value
8	41	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
10	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
56	69	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
21	21	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	30	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	13	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
6	6	-----> set format " (%s)"
25	25	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	672	> fish_title
7	662	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
3	3	--> set -q SSH_TTY
6	642	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	42	---> set -l command (status current-command)
5	5	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
76	578	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
24	495	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
4	4	-----> set -q fish_prompt_pwd_full_dirs
16	402	-----> for path in $argv...
50	60	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
53	81	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
28	28	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
10	245	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	147	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
53	119	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
52	66	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
51	75	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
24	24	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
52	100	> __fish_disable_bracketed_paste ls
48	48	-> printf "\e[?2004l"
27	1938	> fish_title ls
24	1911	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
10	1838	--> if set -q argv[1]...
11	11	---> set -q argv[1]
253	1817	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
30	30	----> string sub -l 20 -- $argv[1]
71	1534	----> prompt_pwd -d 1 -D 1
25	25	-----> set -l options h/help d/dir-length= D/full-length-dirs=
62	62	-----> argparse -n prompt_pwd $options -- $argv
4	16	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
10	10	-----> set -q argv[1]
18	18	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
51	1248	-----> for path in $argv...
160	191	------> set -l realhome (string escape --style=regex -- ~)
31	31	-------> string escape --style=regex -- ~
234	320	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
86	86	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
24	686	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
36	36	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
20	409	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
145	336	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
152	191	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
39	39	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
139	202	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
63	63	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
80	78009	> ls
77929	77929	-> eza -lha $argv
24	55	> __fish_enable_bracketed_paste
31	31	-> printf "\e[?2004h"
11	53	> fish_mode_prompt
13	42	-> fish_default_mode_prompt
2	29	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
20	20	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
24	224102	> fish_prompt
14	14	-> set -l last_status $status
41	53	-> set -l normal (set_color normal)
12	12	--> set_color normal
37	45	-> set -l status_color (set_color brgreen)
8	8	--> set_color brgreen
40	50	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
34	41	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	78	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
13	66	--> fish_is_root_user
2	36	---> if test "$EUID" = 0 2>/dev/null...
34	34	----> test "$EUID" = 0 2>/dev/null
1	13	---> if contains -- $USER root toor Administrator...
12	12	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
121	223757	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	272	--> prompt_login
2	6	---> if not set -q __fish_machine...
4	4	----> not set -q __fish_machine
1	4	---> if set -q __fish_machine[1]...
3	3	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
164	236	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
6	6	----> set_color normal
8	8	----> set_color $color_host
14	40	----> prompt_hostname
26	26	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
23	219	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
16	140	---> for path in $argv...
36	47	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
38	59	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
10	223145	--> fish_vcs_prompt
97	223135	---> fish_git_prompt $argv
11	52957	----> if not command -sq git...
52946	52946	-----> not command -sq git
2	32	----> if functions -q __fish_git_prompt_ready...
30	30	-----> functions -q __fish_git_prompt_ready
164	57185	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57021	57021	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
23	23	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
8	8	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
62	56420	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	56358	-----> __fish_git_prompt_operation_branch_bare $repo_info
11	11	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
25	100	------> if test -d $git_dir/rebase-merge...
26	26	-------> test -d $git_dir/rebase-merge
5	49	-------> if test -d $git_dir/rebase-apply...
17	17	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	56111	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	56099	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
86	56096	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56010	56010	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
7	7	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
4	10	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50097	55874	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5777	5777	-----> read -lz key value
9	41	----> if not set -q dirty[1]...
15	15	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	70	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	46	----> for i in $__fish_git_prompt_status_order...
2	8	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
59	71	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	32	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
3	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
5	5	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
0	4	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
10	661	> fish_title
5	651	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
6	632	--> if set -q argv[1]...
4	4	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
67	568	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
24	494	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
18	397	-----> for path in $argv...
53	64	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
57	90	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
33	33	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	225	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
6	138	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
50	114	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
48	64	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	63	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
59	101	> __fish_disable_bracketed_paste 'cd ..'
42	42	-> printf "\e[?2004l"
38	2742	> fish_title cd\ ..
24	2704	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
11	11	--> set -q SSH_TTY
21	2630	--> if set -q argv[1]...
10	10	---> set -q argv[1]
552	2599	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
32	32	----> string sub -l 20 -- $argv[1]
236	2015	----> prompt_pwd -d 1 -D 1
34	34	-----> set -l options h/help d/dir-length= D/full-length-dirs=
76	76	-----> argparse -n prompt_pwd $options -- $argv
4	18	-----> if set -q _flag_help...
14	14	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
40	40	-----> set -ql _flag_D
31	31	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
10	10	-----> set -q fish_prompt_pwd_full_dirs
73	1489	-----> for path in $argv...
182	219	------> set -l realhome (string escape --style=regex -- ~)
37	37	-------> string escape --style=regex -- ~
197	266	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
69	69	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
33	931	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
36	36	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
24	554	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
227	459	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
191	232	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
41	41	----------> math $fish_prompt_pwd_full_dirs - 1
28	28	--------> set tmp $all[1]
26	26	--------> set full $all[2..]
215	293	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
78	78	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
117	1454	> cd ..
36	36	-> set -l MAX_DIR_HIST 25
24	524	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)...
359	500	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
82	82	---> count $argv
40	40	---> test "$argv[1]" = "--"
19	19	---> echo 1
6	25	-> if status --is-command-substitution...
19	19	--> status --is-command-substitution
33	33	-> set -l previous $PWD
5	53	-> if test "$argv" = -...
48	48	--> test "$argv" = -
181	449	-> builtin cd $argv
40	268	--> __update_cwd_osc VARIABLE SET PWD
6	29	---> if status --is-command-substitution...
12	12	----> status --is-command-substitution
11	11	----> set -q INSIDE_EMACS
175	199	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
24	24	----> string escape --style=url $PWD
22	22	-> set -l cd_status $status
44	185	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"...
38	38	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
13	13	--> set -q dirprev
13	13	--> set -q dirprev[$MAX_DIR_HIST]
8	8	--> set -U -q dirprev
28	28	--> set -g -a dirprev $previous
8	8	--> set -U -q dirnext
10	10	--> set -e dirnext
8	8	--> set -U -q __fish_cd_direction
15	15	--> set -g __fish_cd_direction prev
10	10	-> return $cd_status
21	63	> __fish_enable_bracketed_paste
42	42	-> printf "\e[?2004h"
16	92	> fish_mode_prompt
20	76	-> fish_default_mode_prompt
15	56	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
27	27	---> test "$fish_key_bindings" = fish_vi_key_bindings
14	14	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
69	222117	> fish_prompt
32	32	-> set -l last_status $status
136	160	-> set -l normal (set_color normal)
24	24	--> set_color normal
137	167	-> set -l status_color (set_color brgreen)
30	30	--> set_color brgreen
136	161	-> set -l cwd_color (set_color $fish_color_cwd)
25	25	--> set_color $fish_color_cwd
130	180	-> set -l vcs_color (set_color brpurple)
50	50	--> set_color brpurple
16	16	-> set -l prompt_status ""
10	10	-> set -q fish_prompt_pwd_dir_length
11	11	-> set -lx fish_prompt_pwd_dir_length 0
11	11	-> set -l suffix '❯'
7	209	-> if functions -q fish_is_root_user...
22	22	--> functions -q fish_is_root_user
30	180	--> fish_is_root_user
4	117	---> if test "$EUID" = 0 2>/dev/null...
113	113	----> test "$EUID" = 0 2>/dev/null
3	25	---> if contains -- $USER root toor Administrator...
22	22	----> contains -- $USER root toor Administrator
8	8	---> return 1
2	27	-> if test $last_status -ne 0...
25	25	--> test $last_status -ne 0
462	221046	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
42	1089	--> prompt_login
3	15	---> if not set -q __fish_machine...
12	12	----> not set -q __fish_machine
3	16	---> if set -q __fish_machine[1]...
13	13	----> set -q __fish_machine[1]
19	19	---> set -l color_host $fish_color_host
3	12	---> if set -q SSH_TTY...
9	9	----> set -q SSH_TTY
781	985	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
25	25	----> set_color $fish_color_user
30	30	----> set_color normal
27	27	----> set_color $color_host
36	85	----> prompt_hostname
49	49	-----> string replace -r -- "\..*" "" $hostname
37	37	----> set_color normal
85	945	--> prompt_pwd
30	30	---> set -l options h/help d/dir-length= D/full-length-dirs=
40	40	---> argparse -n prompt_pwd $options -- $argv
5	15	---> if set -q _flag_help...
10	10	----> set -q _flag_help
8	8	---> set -q argv[1]
15	15	---> set argv $PWD
7	7	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
12	12	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
9	9	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
51	700	---> for path in $argv...
132	164	----> set -l realhome (string escape --style=regex -- ~)
32	32	-----> string escape --style=regex -- ~
278	378	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
100	100	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
36	107	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
35	35	-----> test "$fish_prompt_pwd_dir_length" -eq 0
36	36	-----> echo $tmp
31	218550	--> fish_vcs_prompt
32	118831	---> fish_git_prompt $argv
10	62084	----> if not command -sq git...
62074	62074	-----> not command -sq git
3	29	----> if functions -q __fish_git_prompt_ready...
26	26	-----> functions -q __fish_git_prompt_ready
115	56665	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56550	56550	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
4	4	----> return
22	50307	---> fish_hg_prompt $argv
20	50285	----> if not command -sq hg...
50251	50251	-----> not command -sq hg
14	14	-----> return 1
31	49381	---> fish_fossil_prompt $argv
19	49350	----> if not command -sq fossil...
49314	49314	-----> not command -sq fossil
17	17	-----> return 1
18	18	-> echo -n -s $status_color $suffix ' ' $normal
12	633	> fish_title
7	621	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
7	596	--> if set -q argv[1]...
4	4	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
3	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
4	4	----> set command
68	526	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
11	11	----> string sub -l 20 -- $command
25	447	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
25	25	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	347	-----> for path in $argv...
39	50	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
49	76	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	206	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	122	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
42	99	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	57	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
40	64	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
24	24	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
12	25	> __fish_enable_bracketed_paste
13	13	-> printf "\e[?2004h"
7	39	> fish_mode_prompt
11	32	-> fish_default_mode_prompt
5	21	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
10	10	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
28	211253	> fish_prompt
10	10	-> set -l last_status $status
34	43	-> set -l normal (set_color normal)
9	9	--> set_color normal
33	41	-> set -l status_color (set_color brgreen)
8	8	--> set_color brgreen
33	42	-> set -l cwd_color (set_color $fish_color_cwd)
9	9	--> set_color $fish_color_cwd
33	39	-> set -l vcs_color (set_color brpurple)
6	6	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
1	72	-> if functions -q fish_is_root_user...
8	8	--> functions -q fish_is_root_user
11	63	--> fish_is_root_user
2	39	---> if test "$EUID" = 0 2>/dev/null...
37	37	----> test "$EUID" = 0 2>/dev/null
1	10	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
3	3	---> return 1
1	6	-> if test $last_status -ne 0...
5	5	--> test $last_status -ne 0
147	210936	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
15	297	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
188	260	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
9	9	----> set_color $fish_color_user
14	14	----> set_color normal
11	11	----> set_color $color_host
13	31	----> prompt_hostname
18	18	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
21	226	--> prompt_pwd
9	9	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
19	145	---> for path in $argv...
42	52	----> set -l realhome (string escape --style=regex -- ~)
10	10	-----> string escape --style=regex -- ~
37	54	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
17	17	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	20	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
14	210266	--> fish_vcs_prompt
23	109907	---> fish_git_prompt $argv
13	53358	----> if not command -sq git...
53345	53345	-----> not command -sq git
3	35	----> if functions -q __fish_git_prompt_ready...
32	32	-----> functions -q __fish_git_prompt_ready
128	56470	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56342	56342	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
5	5	----> return
23	51013	---> fish_hg_prompt $argv
19	50990	----> if not command -sq hg...
50957	50957	-----> not command -sq hg
14	14	-----> return 1
30	49332	---> fish_fossil_prompt $argv
19	49302	----> if not command -sq fossil...
49267	49267	-----> not command -sq fossil
16	16	-----> return 1
18	18	-> echo -n -s $status_color $suffix ' ' $normal
10	626	> fish_title
8	616	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
6	591	--> if set -q argv[1]...
4	4	---> set -q argv[1]
40	46	---> set -l command (status current-command)
6	6	----> status current-command
3	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
4	4	----> set command
66	520	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
14	14	----> string sub -l 20 -- $command
26	440	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	341	-----> for path in $argv...
39	51	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
38	68	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
30	30	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	209	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
8	130	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
48	104	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	56	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	60	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
13	26	> __fish_disable_bracketed_paste ls
13	13	-> printf "\e[?2004l"
8	481	> fish_title ls
5	473	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
5	455	--> if set -q argv[1]...
3	3	---> set -q argv[1]
69	447	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $argv[1]
19	371	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
18	18	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
2	2	-----> set -q fish_prompt_pwd_full_dirs
11	286	-----> for path in $argv...
36	46	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
37	53	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
16	16	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	176	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	104	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
36	82	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
36	46	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
10	10	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
39	55	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
16	16	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
59	65358	> ls
65299	65299	-> eza -lha $argv
25	96	> __fish_enable_bracketed_paste
71	71	-> printf "\e[?2004h"
18	81	> fish_mode_prompt
33	63	-> fish_default_mode_prompt
5	30	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
34	209175	> fish_prompt
12	12	-> set -l last_status $status
96	131	-> set -l normal (set_color normal)
35	35	--> set_color normal
61	78	-> set -l status_color (set_color brgreen)
17	17	--> set_color brgreen
46	58	-> set -l cwd_color (set_color $fish_color_cwd)
12	12	--> set_color $fish_color_cwd
39	47	-> set -l vcs_color (set_color brpurple)
8	8	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
4	177	-> if functions -q fish_is_root_user...
81	81	--> functions -q fish_is_root_user
15	92	--> fish_is_root_user
2	42	---> if test "$EUID" = 0 2>/dev/null...
40	40	----> test "$EUID" = 0 2>/dev/null
3	31	---> if contains -- $USER root toor Administrator...
28	28	----> contains -- $USER root toor Administrator
4	4	---> return 1
0	8	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
194	208591	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
46	391	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
211	321	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
12	12	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
38	64	----> prompt_hostname
26	26	-----> string replace -r -- "\..*" "" $hostname
19	19	----> set_color normal
61	293	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
18	18	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
16	165	---> for path in $argv...
47	60	----> set -l realhome (string escape --style=regex -- ~)
13	13	-----> string escape --style=regex -- ~
40	69	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
29	29	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	20	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
54	207713	--> fish_vcs_prompt
40	108696	---> fish_git_prompt $argv
10	51847	----> if not command -sq git...
51837	51837	-----> not command -sq git
3	67	----> if functions -q __fish_git_prompt_ready...
64	64	-----> functions -q __fish_git_prompt_ready
131	56722	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56591	56591	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
4	4	----> return
57	49298	---> fish_hg_prompt $argv
25	49241	----> if not command -sq hg...
49197	49197	-----> not command -sq hg
19	19	-----> return 1
84	49665	---> fish_fossil_prompt $argv
21	49581	----> if not command -sq fossil...
49545	49545	-----> not command -sq fossil
15	15	-----> return 1
19	19	-> echo -n -s $status_color $suffix ' ' $normal
11	721	> fish_title
9	710	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
9	683	--> if set -q argv[1]...
4	4	---> set -q argv[1]
40	46	---> set -l command (status current-command)
6	6	----> status current-command
3	15	---> if test "$command" = fish...
8	8	----> test "$command" = fish
4	4	----> set command
72	609	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
10	10	----> string sub -l 20 -- $command
28	527	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
22	424	-----> for path in $argv...
41	53	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
49	75	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
26	26	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	274	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
13	13	-------> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-------> set -l full
6	169	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
51	145	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
47	94	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
47	47	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
53	75	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
22	22	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
56	81	> __fish_complete_cd
20	20	-> set -q CDPATH[1]
5	5	-> return 0
95	326	> __fish_disable_bracketed_paste 'cd franz/'
231	231	-> printf "\e[?2004l"
51	2531	> fish_title cd\ franz/
24	2480	-> if not set -q INSIDE_EMACS...
26	26	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
20	2402	--> if set -q argv[1]...
11	11	---> set -q argv[1]
386	2371	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
33	33	----> string sub -l 20 -- $argv[1]
149	1952	----> prompt_pwd -d 1 -D 1
27	27	-----> set -l options h/help d/dir-length= D/full-length-dirs=
62	62	-----> argparse -n prompt_pwd $options -- $argv
4	16	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
10	10	-----> set -q argv[1]
18	18	-----> set argv $PWD
9	9	-----> set -ql _flag_d
34	34	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
51	1572	-----> for path in $argv...
177	208	------> set -l realhome (string escape --style=regex -- ~)
31	31	-------> string escape --style=regex -- ~
211	300	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
89	89	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
34	1013	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
36	36	-------> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-------> set -l full
27	627	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
252	541	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
181	289	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
108	108	----------> math $fish_prompt_pwd_full_dirs - 1
27	27	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
218	300	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
82	82	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
213	1936	> cd franz/
45	45	-> set -l MAX_DIR_HIST 25
14	698	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)...
480	684	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
142	142	---> count $argv
43	43	---> test "$argv[1]" = "--"
19	19	---> echo 1
7	26	-> if status --is-command-substitution...
19	19	--> status --is-command-substitution
33	33	-> set -l previous $PWD
5	25	-> if test "$argv" = -...
20	20	--> test "$argv" = -
150	500	-> builtin cd $argv
47	350	--> __update_cwd_osc VARIABLE SET PWD
8	33	---> if status --is-command-substitution...
13	13	----> status --is-command-substitution
12	12	----> set -q INSIDE_EMACS
241	270	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
29	29	----> string escape --style=url $PWD
38	38	-> set -l cd_status $status
62	343	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"...
44	44	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
12	12	--> set -q dirprev
16	16	--> set -q dirprev[$MAX_DIR_HIST]
114	114	--> set -U -q dirprev
51	51	--> set -g -a dirprev $previous
10	10	--> set -U -q dirnext
11	11	--> set -e dirnext
9	9	--> set -U -q __fish_cd_direction
14	14	--> set -g __fish_cd_direction prev
15	15	-> return $cd_status
28	57	> __fish_enable_bracketed_paste
29	29	-> printf "\e[?2004h"
23	160	> fish_mode_prompt
83	137	-> fish_default_mode_prompt
8	54	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
30	30	---> test "$fish_key_bindings" = fish_vi_key_bindings
16	16	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
84	248096	> fish_prompt
38	38	-> set -l last_status $status
140	228	-> set -l normal (set_color normal)
88	88	--> set_color normal
307	493	-> set -l status_color (set_color brgreen)
186	186	--> set_color brgreen
200	297	-> set -l cwd_color (set_color $fish_color_cwd)
97	97	--> set_color $fish_color_cwd
147	175	-> set -l vcs_color (set_color brpurple)
28	28	--> set_color brpurple
18	18	-> set -l prompt_status ""
12	12	-> set -q fish_prompt_pwd_dir_length
11	11	-> set -lx fish_prompt_pwd_dir_length 0
13	13	-> set -l suffix '❯'
9	464	-> if functions -q fish_is_root_user...
175	175	--> functions -q fish_is_root_user
38	280	--> fish_is_root_user
6	155	---> if test "$EUID" = 0 2>/dev/null...
149	149	----> test "$EUID" = 0 2>/dev/null
4	78	---> if contains -- $USER root toor Administrator...
74	74	----> contains -- $USER root toor Administrator
9	9	---> return 1
3	21	-> if test $last_status -ne 0...
18	18	--> test $last_status -ne 0
546	246225	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
95	1203	--> prompt_login
4	18	---> if not set -q __fish_machine...
14	14	----> not set -q __fish_machine
3	13	---> if set -q __fish_machine[1]...
10	10	----> set -q __fish_machine[1]
20	20	---> set -l color_host $fish_color_host
3	12	---> if set -q SSH_TTY...
9	9	----> set -q SSH_TTY
739	1045	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
26	26	----> set_color $fish_color_user
44	44	----> set_color normal
27	27	----> set_color $color_host
116	181	----> prompt_hostname
65	65	-----> string replace -r -- "\..*" "" $hostname
28	28	----> set_color normal
73	720	--> prompt_pwd
32	32	---> set -l options h/help d/dir-length= D/full-length-dirs=
35	35	---> argparse -n prompt_pwd $options -- $argv
3	13	---> if set -q _flag_help...
10	10	----> set -q _flag_help
9	9	---> set -q argv[1]
15	15	---> set argv $PWD
7	7	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
7	7	---> set -q fish_prompt_pwd_full_dirs
11	11	---> set -l fish_prompt_pwd_full_dirs 1
38	492	---> for path in $argv...
123	156	----> set -l realhome (string escape --style=regex -- ~)
33	33	-----> string escape --style=regex -- ~
154	215	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
61	61	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
18	83	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
41	41	-----> test "$fish_prompt_pwd_dir_length" -eq 0
24	24	-----> echo $tmp
113	243756	--> fish_vcs_prompt
162	243643	---> fish_git_prompt $argv
11	61587	----> if not command -sq git...
61576	61576	-----> not command -sq git
2	62	----> if functions -q __fish_git_prompt_ready...
60	60	-----> functions -q __fish_git_prompt_ready
127	62454	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
62327	62327	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
59	60445	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	60386	-----> __fish_git_prompt_operation_branch_bare $repo_info
7	7	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
3	3	------> set -l total
31	96	------> if test -d $git_dir/rebase-merge...
15	15	-------> test -d $git_dir/rebase-merge
5	50	-------> if test -d $git_dir/rebase-apply...
11	11	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
9	9	--------> test -f $git_dir/CHERRY_PICK_HEAD
8	8	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
11	60150	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	60135	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
84	60132	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
60048	60048	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
12	12	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
5	5	----> set -l stagedstate
7	7	----> set -l invalidstate
6	6	----> set -l stashstate
3	3	----> set -l untrackedfiles
6	6	----> set -l c $rbc[4]
4	4	----> set -l p
5	5	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
15	15	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
5	5	----> set -l dirty
4	4	----> set -l untracked
52423	58352	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5929	5929	-----> read -lz key value
7	39	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
16	16	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	73	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	44	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
2	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	6	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	47	----> for i in $__fish_git_prompt_status_order...
2	8	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
57	73	----> set b (string replace refs/heads/ '' -- $b)
16	16	-----> string replace refs/heads/ '' -- $b
2	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	33	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
3	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	14	----> if test -z "$format"...
4	4	-----> test -z "$format"
6	6	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
17	17	-> echo -n -s $status_color $suffix ' ' $normal
11	667	> fish_title
7	656	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
8	633	--> if set -q argv[1]...
3	3	---> set -q argv[1]
46	52	---> set -l command (status current-command)
6	6	----> status current-command
4	19	---> if test "$command" = fish...
10	10	----> test "$command" = fish
5	5	----> set command
79	551	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
31	463	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
26	26	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
3	3	-----> set -q argv[1]
7	7	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
17	353	-----> for path in $argv...
40	51	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
42	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	221	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	136	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	112	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
60	73	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	64	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
82	172	> __fish_disable_bracketed_paste 'git pull'
90	90	-> printf "\e[?2004l"
52	1967	> fish_title git\ pull
25	1915	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
30	30	--> set -l ssh
16	16	--> set -q SSH_TTY
15	1822	--> if set -q argv[1]...
15	15	---> set -q argv[1]
338	1792	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
46	46	----> string sub -l 20 -- $argv[1]
87	1408	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
66	66	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
11	11	-----> set -q argv[1]
20	20	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
54	1093	-----> for path in $argv...
110	143	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
162	225	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
63	63	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
27	671	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
35	35	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
18	381	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
135	311	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
138	176	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
38	38	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
14	14	--------> set full $all[2..]
151	213	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
62	62	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
212774823	212774823	> git pull
66	223	> __fish_enable_bracketed_paste
157	157	-> printf "\e[?2004h"
42	235	> fish_mode_prompt
103	193	-> fish_default_mode_prompt
16	90	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
57	57	---> test "$fish_key_bindings" = fish_vi_key_bindings
17	17	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
110	247245	> fish_prompt
57	57	-> set -l last_status $status
177	287	-> set -l normal (set_color normal)
110	110	--> set_color normal
207	244	-> set -l status_color (set_color brgreen)
37	37	--> set_color brgreen
170	202	-> set -l cwd_color (set_color $fish_color_cwd)
32	32	--> set_color $fish_color_cwd
222	256	-> set -l vcs_color (set_color brpurple)
34	34	--> set_color brpurple
26	26	-> set -l prompt_status ""
13	13	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
15	15	-> set -l suffix '❯'
9	496	-> if functions -q fish_is_root_user...
194	194	--> functions -q fish_is_root_user
59	293	--> fish_is_root_user
5	123	---> if test "$EUID" = 0 2>/dev/null...
118	118	----> test "$EUID" = 0 2>/dev/null
5	99	---> if contains -- $USER root toor Administrator...
94	94	----> contains -- $USER root toor Administrator
12	12	---> return 1
19	283	-> if test $last_status -ne 0...
22	22	--> test $last_status -ne 0
175	208	--> set status_color (set_color $fish_color_error)
33	33	---> set_color $fish_color_error
34	34	--> set prompt_status $status_color "[" $last_status "]" $normal
550	245229	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
129	1442	--> prompt_login
4	19	---> if not set -q __fish_machine...
15	15	----> not set -q __fish_machine
4	23	---> if set -q __fish_machine[1]...
19	19	----> set -q __fish_machine[1]
23	23	---> set -l color_host $fish_color_host
3	13	---> if set -q SSH_TTY...
10	10	----> set -q SSH_TTY
787	1235	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
43	43	----> set_color $fish_color_user
41	41	----> set_color normal
46	46	----> set_color $color_host
184	271	----> prompt_hostname
87	87	-----> string replace -r -- "\..*" "" $hostname
47	47	----> set_color normal
220	1057	--> prompt_pwd
60	60	---> set -l options h/help d/dir-length= D/full-length-dirs=
56	56	---> argparse -n prompt_pwd $options -- $argv
5	34	---> if set -q _flag_help...
29	29	----> set -q _flag_help
11	11	---> set -q argv[1]
18	18	---> set argv $PWD
10	10	---> set -ql _flag_d
19	19	---> set -q fish_prompt_pwd_dir_length
17	17	---> set -l fulldirs 0
8	8	---> set -ql _flag_D
9	9	---> set -q fish_prompt_pwd_full_dirs
13	13	---> set -l fish_prompt_pwd_full_dirs 1
54	582	---> for path in $argv...
141	172	----> set -l realhome (string escape --style=regex -- ~)
31	31	-----> string escape --style=regex -- ~
174	263	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
89	89	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
35	93	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
33	33	-----> test "$fish_prompt_pwd_dir_length" -eq 0
25	25	-----> echo $tmp
137	242180	--> fish_vcs_prompt
156	242043	---> fish_git_prompt $argv
11	64020	----> if not command -sq git...
64009	64009	-----> not command -sq git
2	68	----> if functions -q __fish_git_prompt_ready...
66	66	-----> functions -q __fish_git_prompt_ready
140	57651	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57511	57511	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
60	63046	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	62986	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
5	5	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
28	102	------> if test -d $git_dir/rebase-merge...
17	17	-------> test -d $git_dir/rebase-merge
6	57	-------> if test -d $git_dir/rebase-apply...
11	11	--------> test -d $git_dir/rebase-apply
10	10	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
10	10	--------> test -f $git_dir/REVERT_HEAD
10	10	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
12	62733	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	62717	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	62714	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
62625	62625	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	8	----> if not set -q ___fish_git_prompt_init...
7	7	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50548	56520	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5972	5972	-----> read -lz key value
7	41	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	70	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	14	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	6	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
77	89	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	30	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
3	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
5	5	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	14	----> if test -z "$format"...
4	4	-----> test -z "$format"
6	6	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
10	606	> fish_title
7	596	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	575	--> if set -q argv[1]...
3	3	---> set -q argv[1]
41	47	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
71	507	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
25	428	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
20	20	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
8	8	-----> set argv $PWD
3	3	-----> set -ql _flag_d
8	8	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	331	-----> for path in $argv...
36	47	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
37	56	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
19	19	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	215	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
8	138	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	113	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	74	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
35	35	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	59	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
52	180	> __fish_disable_bracketed_paste ls
128	128	-> printf "\e[?2004l"
35	2482	> fish_title ls
28	2447	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
29	2369	--> if set -q argv[1]...
11	11	---> set -q argv[1]
404	2329	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
183	1894	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
80	80	-----> argparse -n prompt_pwd $options -- $argv
4	18	-----> if set -q _flag_help...
14	14	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
25	25	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
49	1463	-----> for path in $argv...
133	166	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
230	307	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
77	77	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
43	941	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
39	39	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
34	576	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
192	482	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
177	290	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
113	113	----------> math $fish_prompt_pwd_full_dirs - 1
26	26	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
204	268	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
64	64	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
89	77924	> ls
77835	77835	-> eza -lha $argv
26	54	> __fish_enable_bracketed_paste
28	28	-> printf "\e[?2004h"
13	89	> fish_mode_prompt
41	76	-> fish_default_mode_prompt
6	35	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
23	23	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
29	224202	> fish_prompt
13	13	-> set -l last_status $status
53	84	-> set -l normal (set_color normal)
31	31	--> set_color normal
61	76	-> set -l status_color (set_color brgreen)
15	15	--> set_color brgreen
40	51	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
34	41	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
2	160	-> if functions -q fish_is_root_user...
65	65	--> functions -q fish_is_root_user
16	93	--> fish_is_root_user
2	42	---> if test "$EUID" = 0 2>/dev/null...
40	40	----> test "$EUID" = 0 2>/dev/null
1	31	---> if contains -- $USER root toor Administrator...
30	30	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
125	223707	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
37	329	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
2	5	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
165	268	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
14	14	----> set_color $fish_color_user
7	7	----> set_color normal
7	7	----> set_color $color_host
36	68	----> prompt_hostname
32	32	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
22	222	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
15	143	---> for path in $argv...
41	51	----> set -l realhome (string escape --style=regex -- ~)
10	10	-----> string escape --style=regex -- ~
39	59	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
42	223031	--> fish_vcs_prompt
124	222989	---> fish_git_prompt $argv
12	51190	----> if not command -sq git...
51178	51178	-----> not command -sq git
4	79	----> if functions -q __fish_git_prompt_ready...
75	75	-----> functions -q __fish_git_prompt_ready
159	57135	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56976	56976	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
65	57113	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	57048	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
3	3	------> set -l total
29	77	------> if test -d $git_dir/rebase-merge...
10	10	-------> test -d $git_dir/rebase-merge
5	38	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
2	10	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
12	56830	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56814	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	56812	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56723	56723	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
9	9	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
7	7	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
2	8	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50775	56743	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5968	5968	-----> read -lz key value
7	42	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
11	11	----> contains untrackedfiles $__fish_git_prompt_status_order
9	73	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
7	45	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
3	9	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
3	8	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	46	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
75	87	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
1	31	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
30	30	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
3	32	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
2	5	----> if test -n "$c"...
3	3	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
6	6	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
11	818	> fish_title
7	807	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
6	786	--> if set -q argv[1]...
4	4	---> set -q argv[1]
36	42	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
101	721	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
6	6	----> string sub -l 20 -- $command
33	614	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	514	-----> for path in $argv...
38	48	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
44	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	388	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
11	269	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
85	238	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
128	153	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
25	25	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
66	97	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
31	31	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
700	112877	> source /usr/local/Cellar/fish/3.7.1/share/fish/completions/ls.fish
105	53330	-> set -l uname (uname -s)
53225	53225	--> uname -s
16	16	-> test "$uname" != SunOS
58	58	-> complete -c ls -s S -d "Sort by size"
9	9	-> complete -c ls -s 1 -d "List one entry per line"
6	6	-> complete -c ls -s c -d "Sort by changed time, (-l) show ctime"
5	5	-> complete -c ls -s C -d "Force multi-column output"
7	7	-> complete -c ls -s f -d "Unsorted output, enables -a"
5	5	-> complete -c ls -s l -d "Long listing format"
6	6	-> complete -c ls -s m -d "Comma-separated format, fills across screen"
6	6	-> complete -c ls -s t -d "Sort by modified time, most recent first"
6	6	-> complete -c ls -s u -d "Sort by access time, (-l) show atime"
5	5	-> complete -c ls -s x -d "Multi-column output, horizontally listed"
88	58718	-> if ls --version >/dev/null 2>/dev/null...
75	58228	--> ls --version >/dev/null 2>/dev/null
58153	58153	---> eza -lha $argv
32	32	--> complete -c ls -s a -l all -d "Show hidden"
9	9	--> complete -c ls -s A -l almost-all -d "Show hidden except . and .."
7	7	--> complete -c ls -s b -l escape -d "Octal escapes for non-graphic characters"
9	9	--> complete -c ls -s d -l directory -d "List directories, not their content"
7	7	--> complete -c ls -s F -l classify -d "Append filetype indicator (*/=>@|)"
7	7	--> complete -c ls -s h -l human-readable -d "Human readable sizes"
6	6	--> complete -c ls -s H -l dereference-command-line -d "Follow symlinks"
6	6	--> complete -c ls -s i -l inode -d "Print inode number of files"
6	6	--> complete -c ls -s k -d "Set blocksize to 1kB"
6	6	--> complete -c ls -s L -l dereference -d "Follow symlinks"
7	7	--> complete -c ls -s n -l numeric-uid-gid -d "Long format, numeric UIDs and GIDs"
7	7	--> complete -c ls -s p -l file-type -d "Append filetype indicator"
6	6	--> complete -c ls -s q -l hide-control-chars -d "Replace non-graphic characters with '?'"
6	6	--> complete -c ls -s r -l reverse -d "Reverse sort order"
7	7	--> complete -c ls -s R -l recursive -d "List subdirectory recursively"
6	6	--> complete -c ls -s s -l size -d "Print size of files"
6	6	--> complete -c ls -l author -d "Print author"
6	6	--> complete -c ls -s B -l ignore-backups -d "Ignore files ending with ~"
6	6	--> complete -c ls -l block-size -x -d "Set block size"
19	19	--> complete -c ls -l color -f -a "never always auto" -d "Use colors"
6	6	--> complete -c ls -s D -l dired -d "Generate dired output"
5	5	--> complete -c ls -l dereference-command-line-symlink-to-dir
13	13	--> complete -c ls -l format -x -a "across commas horizontal long single-column verbose vertical" -d "List format"
6	6	--> complete -c ls -l full-time -d "Long format, full-iso time"
6	6	--> complete -c ls -s G -l no-group -d "Don't print group information"
6	6	--> complete -c ls -l group-directories-first -r -d "Group directories before files"
8	8	--> complete -c ls -l hide -r -d "Do not list implied entries matching specified shell pattern"
6	6	--> complete -c ls -s I -l ignore -r -d "Skip entries matching pattern"
12	12	--> complete -c ls -l indicator-style -x -a "none classify file-type" -d "Append filetype indicator"
6	6	--> complete -c ls -l lcontext -d "Display security context"
5	5	--> complete -c ls -s N -l literal -d "Print raw entry names"
6	6	--> complete -c ls -s o -d "Long format without groups"
6	6	--> complete -c ls -s Q -l quote-name -d "Enclose entry in quotes"
18	18	--> complete -c ls -l quoting-style -x -a "literal locale shell shell-always c escape" -d "Select quoting style"
6	6	--> complete -c ls -l scontext -d "Display only security context and file name"
5	5	--> complete -c ls -l si -d "Human readable sizes, powers of 1000"
6	6	--> complete -c ls -l show-control-chars -d "Non-graphic characters printed as-is"
28	28	--> complete -c ls -l sort -x -d "Sort criteria" -a "
			extension\t'Sort by file extension'
			none\tDon\'t\ sort
			size\t'Sort by size'
			time\t'Sort by modification time'
			version\t'Sort by version'
			status\t'Sort by file status modification time'
			atime\t'Sort by access time'
			access\t'Sort by access time'
			use\t'Sort by access time'
		"
13	13	--> complete -c ls -s T -l tabsize -x -a "1 2 3 4 5 6 7 8 9 10 11 12" -d "Assume tab stops at each COLS"
17	17	--> complete -c ls -l time -x -d "Show time type" -a "
			time\t'Sort by modification time'
			access\t'Sort by access time'
			use\t'Sort by use time'
			ctime\t'Sort by file status modification time'
			status\t'Sort by status time'
		"
10	10	--> complete -c ls -l time-style -x -a "full-iso long-iso iso locale" -d "Select time style"
5	5	--> complete -c ls -s U -d "Do not sort"
5	5	--> complete -c ls -s v -d "Sort by version"
6	6	--> complete -c ls -s w -l width -x -d "Assume screen width"
5	5	--> complete -c ls -s X -d "Sort by extension"
6	6	--> complete -c ls -s Z -l context -d "Display security context so it fits on most displays"
5	5	--> complete -c ls -l help -d "Display help and exit"
5	5	--> complete -c ls -l version -d "Display version and exit"
537	1060	> source /usr/local/share/fish/vendor_completions.d/eza.fish
22	22	-> complete -c eza -s v -l version -d "Show version of eza"
8	8	-> complete -c eza -l help -d "Show list of command-line options"
7	7	-> complete -c eza -s 1 -l oneline -d "Display one entry per line"
6	6	-> complete -c eza -s l -l long -d "Display extended file metadata as a table"
6	6	-> complete -c eza -s G -l grid -d "Display entries in a grid"
7	7	-> complete -c eza -s x -l across -d "Sort the grid across, rather than downwards"
6	6	-> complete -c eza -s R -l recurse -d "Recurse into directories"
6	6	-> complete -c eza -s T -l tree -d "Recurse into directories as a tree"
7	7	-> complete -c eza -s X -l dereference -d "Dereference symbolic links when displaying file information"
6	6	-> complete -c eza -s F -l classify -d "Display type indicator by file names"
22	22	-> complete -c eza -l color \
    -l colour -d "When to use terminal colours" -x -a "
    always\t'Always use colour'
    auto\t'Use colour if standard output is a terminal'
    automatic\t'Use colour if standard output is a terminal'
    never\t'Never use colour'
"
13	13	-> complete -c eza -l color-scale \
    -l colour-scale -d "Highlight levels 'field' distinctly" -x -a "
    all\t''
    age\t''
    size\t''
"
17	17	-> complete -c eza -l color-scale-mode \
    -l colour-scale-mode \
    -d "Use gradient or fixed colors in --color-scale" -x -a "
    fixed\t'Highlight based on fixed colors'
    gradient\t'Highlight based \'field\' in relation to other files'
"
19	19	-> complete -c eza -l icons -d "When to display icons" -x -a "
  always\t'Always display icons'
  auto\t'Display icons if standard output is a terminal'
  automatic\t'Display icons if standard output is a terminal'
  never\t'Never display icons'
"
6	6	-> complete -c eza -l no-quotes -d "Don't quote file names with spaces"
6	6	-> complete -c eza -l hyperlink -d "Display entries as hyperlinks"
15	15	-> complete -c eza -l absolute -d "Display entries with their absolute path" -x -a "
  on\t'Show absolute path for listed entries'
  follow\t'Show absolute path with followed symlinks'
  off\t'Do not show the absolute path'
"
7	7	-> complete -c eza -l smart-group -d "Only show group if it has a different name from owner"
5	5	-> complete -c eza -l group-directories-first -d "Sort directories before other files"
5	5	-> complete -c eza -l git-ignore -d "Ignore files mentioned in '.gitignore'"
9	9	-> complete -c eza -s a -l all -d "Show hidden and 'dot' files. Use this twice to also show the '.' and '..' directories"
6	6	-> complete -c eza -s A -l almost-all -d "Equivalent to --all; included for compatibility with `ls -A`"
6	6	-> complete -c eza -s d -l list-dirs -d "List directories like regular files"
13	13	-> complete -c eza -s L -l level -d "Limit the depth of recursion" -x -a "1 2 3 4 5 6 7 8 9"
6	6	-> complete -c eza -s w -l width -d "Limits column output of grid, 0 implies auto-width"
5	5	-> complete -c eza -s r -l reverse -d "Reverse the sort order"
46	46	-> complete -c eza -s s -l sort -d "Which field to sort by" -x -a "
    accessed\t'Sort by file accessed time'
    age\t'Sort by file modified time (newest first)'
    changed\t'Sort by changed time'
    created\t'Sort by file modified time'
    date\t'Sort by file modified time'
    ext\t'Sort by file extension'
    Ext\t'Sort by file extension (uppercase first)'
    extension\t'Sort by file extension'
    Extension\t'Sort by file extension (uppercase first)'
    filename\t'Sort by filename'
    Filename\t'Sort by filename (uppercase first)'
    inode\t'Sort by file inode'
    modified\t'Sort by file modified time'
    name\t'Sort by filename'
    Name\t'Sort by filename (uppercase first)'
    newest\t'Sort by file modified time (newest first)'
    none\t'Do not sort files at all'
    oldest\t'Sort by file modified time'
    size\t'Sort by file size'
    time\t'Sort by file modified time'
    type\t'Sort by file type'
"
8	8	-> complete -c eza -s I -l ignore-glob -d "Ignore files that match these glob patterns" -r
6	6	-> complete -c eza -s D -l only-dirs -d "List only directories"
7	7	-> complete -c eza -s f -l only-files -d "List only files"
7	7	-> complete -c eza -l show-symlinks -d "Explicitly show symbolic links (For use with --only-dirs | --only-files)"
6	6	-> complete -c eza -l no-symlinks -d "Do not show symbolic links"
6	6	-> complete -c eza -s b -l binary -d "List file sizes with binary prefixes"
6	6	-> complete -c eza -s B -l bytes -d "List file sizes in bytes, without any prefixes"
5	5	-> complete -c eza -s g -l group -d "List each file's group"
6	6	-> complete -c eza -s h -l header -d "Add a header row to each column"
6	6	-> complete -c eza -s H -l links -d "List each file's number of hard links"
11	11	-> complete -c eza -s i -l inode -d "List each file's inode number"
6	6	-> complete -c eza -s S -l blocksize -d "List each file's size of allocated file system blocks"
15	15	-> complete -c eza -s t -l time -d "Which timestamp field to list" -x -a "
    modified\t'Display modified time'
    changed\t'Display changed time'
    accessed\t'Display accessed time'
    created\t'Display created time'
"
8	8	-> complete -c eza -s m -l modified -d "Use the modified timestamp field"
6	6	-> complete -c eza -s n -l numeric -d "List numeric user and group IDs."
5	5	-> complete -c eza -l changed -d "Use the changed timestamp field"
6	6	-> complete -c eza -s u -l accessed -d "Use the accessed timestamp field"
5	5	-> complete -c eza -s U -l created -d "Use the created timestamp field"
25	25	-> complete -c eza -l time-style -d "How to format timestamps" -x -a "
    default\t'Use the default time style'
    iso\t'Display brief ISO timestamps'
    long-iso\t'Display longer ISO timestamps, up to the minute'
    full-iso\t'Display full ISO timestamps, up to the nanosecond'
    relative\t'Display relative timestamps'
    +FORMAT\t'Use custom time style'
"
6	6	-> complete -c eza -l total-size -d "Show recursive directory size (unix only)"
5	5	-> complete -c eza -l no-permissions -d "Suppress the permissions field"
9	9	-> complete -c eza -s o -l octal-permissions -d "List each file's permission in octal format"
5	5	-> complete -c eza -l no-filesize -d "Suppress the filesize field"
6	6	-> complete -c eza -l no-user -d "Suppress the user field"
5	5	-> complete -c eza -l no-time -d "Suppress the time field"
6	6	-> complete -c eza -s M -l mounts -d "Show mount details"
5	5	-> complete -c eza -l stdin -d "When piping to eza. Read file names from stdin"
5	5	-> complete -c eza -l git -d "List each file's Git status, if tracked"
5	5	-> complete -c eza -l no-git -d "Suppress Git status"
9	9	-> complete -c eza -l git-repos -d "List each git-repos status and branch name"
6	6	-> complete -c eza -l git-repos-no-status -d "List each git-repos branch name (much faster)"
8	8	-> complete -c eza -s '@' -l extended -d "List each file's extended attributes and sizes"
6	6	-> complete -c eza -s Z -l context -d "List each file's security context"
17	32	> __fish_disable_bracketed_paste 'ls src/'
15	15	-> printf "\e[?2004l"
12	652	> fish_title ls\ src/
9	640	-> if not set -q INSIDE_EMACS...
8	8	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
3	3	--> set -q SSH_TTY
4	613	--> if set -q argv[1]...
4	4	---> set -q argv[1]
85	605	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
12	12	----> string sub -l 20 -- $argv[1]
26	508	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
29	29	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	399	-----> for path in $argv...
39	51	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
48	75	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	259	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
12	12	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
8	157	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
60	129	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
55	69	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
14	14	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
51	79	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
28	28	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
62	65674	> ls src/
65612	65612	-> eza -lha $argv
26	54	> __fish_enable_bracketed_paste
28	28	-> printf "\e[?2004h"
10	75	> fish_mode_prompt
13	65	-> fish_default_mode_prompt
5	52	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
41	41	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
33	225541	> fish_prompt
12	12	-> set -l last_status $status
71	82	-> set -l normal (set_color normal)
11	11	--> set_color normal
59	75	-> set -l status_color (set_color brgreen)
16	16	--> set_color brgreen
41	52	-> set -l cwd_color (set_color $fish_color_cwd)
11	11	--> set_color $fish_color_cwd
33	41	-> set -l vcs_color (set_color brpurple)
8	8	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	93	-> if functions -q fish_is_root_user...
13	13	--> functions -q fish_is_root_user
21	77	--> fish_is_root_user
2	40	---> if test "$EUID" = 0 2>/dev/null...
38	38	----> test "$EUID" = 0 2>/dev/null
3	12	---> if contains -- $USER root toor Administrator...
9	9	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
207	225113	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
16	279	--> prompt_login
1	9	---> if not set -q __fish_machine...
8	8	----> not set -q __fish_machine
1	6	---> if set -q __fish_machine[1]...
5	5	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
158	236	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
12	45	----> prompt_hostname
33	33	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
18	230	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
27	27	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
7	7	---> set argv $PWD
4	4	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
16	138	---> for path in $argv...
39	50	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
36	55	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
19	19	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
11	224397	--> fish_vcs_prompt
97	224386	---> fish_git_prompt $argv
13	51632	----> if not command -sq git...
51619	51619	-----> not command -sq git
4	39	----> if functions -q __fish_git_prompt_ready...
35	35	-----> functions -q __fish_git_prompt_ready
144	57680	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57536	57536	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
8	8	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
59	57567	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	57508	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
3	3	------> set -l total
22	73	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
6	39	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
9	57282	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	57269	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
92	57267	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57175	57175	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
12	12	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
10	10	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
3	3	----> set -l stagedstate
6	6	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
5	5	----> set -q __fish_git_prompt_status_order
3	13	----> if not set -q ___fish_git_prompt_init...
10	10	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50778	56749	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5971	5971	-----> read -lz key value
8	42	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	72	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
4	9	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	46	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
78	90	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
6	36	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
30	30	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
7	38	----> if test -n "$b"...
7	7	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
5	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
8	8	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	711	> fish_title
14	701	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
10	673	--> if set -q argv[1]...
4	4	---> set -q argv[1]
59	65	---> set -l command (status current-command)
6	6	----> status current-command
4	23	---> if test "$command" = fish...
13	13	----> test "$command" = fish
6	6	----> set command
99	571	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
27	463	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
32	32	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	354	-----> for path in $argv...
43	58	------> set -l realhome (string escape --style=regex -- ~)
15	15	-------> string escape --style=regex -- ~
40	74	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
34	34	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	209	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	121	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
41	97	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
41	56	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
47	68	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
24	217	> __bat_cache_no_excl
10	193	-> __bat_cache_subcommand
56	183	--> __fish_seen_subcommand_from cache
66	105	---> set -l cmd (commandline -poc)
39	39	----> commandline -poc
11	11	---> set -e cmd[1]
7	7	---> for i in $cmd...
4	4	---> return 1
9	124	> __bat_cache_subcommand
22	115	-> __fish_seen_subcommand_from cache
65	72	--> set -l cmd (commandline -poc)
7	7	---> commandline -poc
10	10	--> set -e cmd[1]
7	7	--> for i in $cmd...
4	4	--> return 1
10	88	> __bat_cache_subcommand
19	78	-> __fish_seen_subcommand_from cache
37	47	--> set -l cmd (commandline -poc)
10	10	---> commandline -poc
5	5	--> set -e cmd[1]
4	4	--> for i in $cmd...
3	3	--> return 1
9	274	> __bat_no_excl_args
8	75	-> not __bat_cache_subcommand
15	67	--> __fish_seen_subcommand_from cache
33	40	---> set -l cmd (commandline -poc)
7	7	----> commandline -poc
5	5	---> set -e cmd[1]
3	3	---> for i in $cmd...
4	4	---> return 1
75	190	-> not __fish_seen_argument \
        -s h -l help \
        -s V -l version \
        -l acknowledgements \
        -l config-dir -l config-file \
        -l diagnostic \
        -l list-languages -l list-themes
44	44	--> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
48	56	--> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
8	8	---> commandline --current-process --tokenize --cut-at-cursor
6	6	--> set --erase tokens[1]
6	6	--> for t in $tokens...
3	3	--> return 1
40	160	> __fish_is_first_arg
35	42	-> set -l tokens (commandline -poc)
7	7	--> commandline -poc
38	78	-> test (count $tokens) -eq 1
40	40	--> count $tokens
20	96	> __fish_seen_argument -s d -l diff
20	20	-> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
36	43	-> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
7	7	--> commandline --current-process --tokenize --cut-at-cursor
6	6	-> set --erase tokens[1]
4	4	-> for t in $tokens...
3	3	-> return 1
21	147	> __bat_cache_no_excl
10	126	-> __bat_cache_subcommand
22	116	--> __fish_seen_subcommand_from cache
61	77	---> set -l cmd (commandline -poc)
16	16	----> commandline -poc
7	7	---> set -e cmd[1]
6	6	---> for i in $cmd...
4	4	---> return 1
8	78	> __bat_cache_subcommand
16	70	-> __fish_seen_subcommand_from cache
36	43	--> set -l cmd (commandline -poc)
7	7	---> commandline -poc
5	5	--> set -e cmd[1]
3	3	--> for i in $cmd...
3	3	--> return 1
7	74	> __bat_cache_subcommand
15	67	-> __fish_seen_subcommand_from cache
34	40	--> set -l cmd (commandline -poc)
6	6	---> commandline -poc
5	5	--> set -e cmd[1]
4	4	--> for i in $cmd...
3	3	--> return 1
10	245	> __bat_no_excl_args
8	76	-> not __bat_cache_subcommand
20	68	--> __fish_seen_subcommand_from cache
33	39	---> set -l cmd (commandline -poc)
6	6	----> commandline -poc
4	4	---> set -e cmd[1]
3	3	---> for i in $cmd...
2	2	---> return 1
36	159	-> not __fish_seen_argument \
        -s h -l help \
        -s V -l version \
        -l acknowledgements \
        -l config-dir -l config-file \
        -l diagnostic \
        -l list-languages -l list-themes
37	37	--> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
53	63	--> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
10	10	---> commandline --current-process --tokenize --cut-at-cursor
10	10	--> set --erase tokens[1]
9	9	--> for t in $tokens...
4	4	--> return 1
17	116	> __fish_is_first_arg
39	49	-> set -l tokens (commandline -poc)
10	10	--> commandline -poc
38	50	-> test (count $tokens) -eq 1
12	12	--> count $tokens
25	124	> __fish_seen_argument -s d -l diff
24	24	-> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
50	59	-> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
9	9	--> commandline --current-process --tokenize --cut-at-cursor
6	6	-> set --erase tokens[1]
6	6	-> for t in $tokens...
4	4	-> return 1
21	157	> __bat_cache_no_excl
11	136	-> __bat_cache_subcommand
24	125	--> __fish_seen_subcommand_from cache
67	81	---> set -l cmd (commandline -poc)
14	14	----> commandline -poc
8	8	---> set -e cmd[1]
8	8	---> for i in $cmd...
4	4	---> return 1
8	78	> __bat_cache_subcommand
15	70	-> __fish_seen_subcommand_from cache
37	43	--> set -l cmd (commandline -poc)
6	6	---> commandline -poc
5	5	--> set -e cmd[1]
4	4	--> for i in $cmd...
3	3	--> return 1
7	72	> __bat_cache_subcommand
15	65	-> __fish_seen_subcommand_from cache
33	39	--> set -l cmd (commandline -poc)
6	6	---> commandline -poc
5	5	--> set -e cmd[1]
3	3	--> for i in $cmd...
3	3	--> return 1
10	216	> __bat_no_excl_args
7	72	-> not __bat_cache_subcommand
15	65	--> __fish_seen_subcommand_from cache
33	39	---> set -l cmd (commandline -poc)
6	6	----> commandline -poc
5	5	---> set -e cmd[1]
3	3	---> for i in $cmd...
3	3	---> return 1
32	134	-> not __fish_seen_argument \
        -s h -l help \
        -s V -l version \
        -l acknowledgements \
        -l config-dir -l config-file \
        -l diagnostic \
        -l list-languages -l list-themes
38	38	--> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
41	49	--> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
8	8	---> commandline --current-process --tokenize --cut-at-cursor
6	6	--> set --erase tokens[1]
6	6	--> for t in $tokens...
3	3	--> return 1
12	100	> __fish_is_first_arg
34	40	-> set -l tokens (commandline -poc)
6	6	--> commandline -poc
37	48	-> test (count $tokens) -eq 1
11	11	--> count $tokens
23	102	> __fish_seen_argument -s d -l diff
19	19	-> argparse --ignore-unknown 's/short=+' 'o/old=+' 'l/long=+' 'w/windows=+' -- $argv
37	45	-> set --local tokens (commandline --current-process --tokenize --cut-at-cursor)
8	8	--> commandline --current-process --tokenize --cut-at-cursor
6	6	-> set --erase tokens[1]
5	5	-> for t in $tokens...
4	4	-> return 1
63	113	> __fish_disable_bracketed_paste 'cat src/server.rs '
50	50	-> printf "\e[?2004l"
32	1807	> fish_title cat\ src/server.rs\ 
23	1775	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
10	1703	--> if set -q argv[1]...
11	11	---> set -q argv[1]
285	1682	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
98	1366	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
68	68	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
39	1038	-----> for path in $argv...
140	173	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
142	209	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
67	67	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
20	617	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
12	12	-------> set -l full
29	363	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
119	281	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
126	162	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
138	193	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
55	55	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
164	202337438	> cat src/server.rs
202337274	202337274	-> bat $argv
107	290	> __fish_enable_bracketed_paste
183	183	-> printf "\e[?2004h"
27	181	> fish_mode_prompt
85	154	-> fish_default_mode_prompt
9	69	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
43	43	---> test "$fish_key_bindings" = fish_vi_key_bindings
17	17	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
61	241202	> fish_prompt
31	31	-> set -l last_status $status
171	237	-> set -l normal (set_color normal)
66	66	--> set_color normal
201	238	-> set -l status_color (set_color brgreen)
37	37	--> set_color brgreen
163	192	-> set -l cwd_color (set_color $fish_color_cwd)
29	29	--> set_color $fish_color_cwd
177	206	-> set -l vcs_color (set_color brpurple)
29	29	--> set_color brpurple
35	35	-> set -l prompt_status ""
14	14	-> set -q fish_prompt_pwd_dir_length
12	12	-> set -lx fish_prompt_pwd_dir_length 0
12	12	-> set -l suffix '❯'
6	374	-> if functions -q fish_is_root_user...
152	152	--> functions -q fish_is_root_user
41	216	--> fish_is_root_user
5	91	---> if test "$EUID" = 0 2>/dev/null...
86	86	----> test "$EUID" = 0 2>/dev/null
3	76	---> if contains -- $USER root toor Administrator...
73	73	----> contains -- $USER root toor Administrator
8	8	---> return 1
2	18	-> if test $last_status -ne 0...
16	16	--> test $last_status -ne 0
416	239760	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
93	949	--> prompt_login
4	16	---> if not set -q __fish_machine...
12	12	----> not set -q __fish_machine
2	11	---> if set -q __fish_machine[1]...
9	9	----> set -q __fish_machine[1]
22	22	---> set -l color_host $fish_color_host
3	11	---> if set -q SSH_TTY...
8	8	----> set -q SSH_TTY
545	796	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
27	27	----> set_color $fish_color_user
35	35	----> set_color normal
24	24	----> set_color $color_host
86	146	----> prompt_hostname
60	60	-----> string replace -r -- "\..*" "" $hostname
19	19	----> set_color normal
146	1289	--> prompt_pwd
30	30	---> set -l options h/help d/dir-length= D/full-length-dirs=
41	41	---> argparse -n prompt_pwd $options -- $argv
3	14	---> if set -q _flag_help...
11	11	----> set -q _flag_help
8	8	---> set -q argv[1]
15	15	---> set argv $PWD
7	7	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
8	8	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
330	984	---> for path in $argv...
253	317	----> set -l realhome (string escape --style=regex -- ~)
64	64	-----> string escape --style=regex -- ~
201	280	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
79	79	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
13	57	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
25	25	-----> test "$fish_prompt_pwd_dir_length" -eq 0
19	19	-----> echo $tmp
112	237106	--> fish_vcs_prompt
146	236994	---> fish_git_prompt $argv
11	62517	----> if not command -sq git...
62506	62506	-----> not command -sq git
7	69	----> if functions -q __fish_git_prompt_ready...
62	62	-----> functions -q __fish_git_prompt_ready
136	58099	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57963	57963	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
63	58730	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	58667	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
4	4	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	72	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	38	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
6	6	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
7	58453	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
3	58441	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
95	58438	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58343	58343	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
5	5	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50756	56852	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6096	6096	-----> read -lz key value
8	44	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
4	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
6	6	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	70	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	45	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
62	83	----> set b (string replace refs/heads/ '' -- $b)
21	21	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	33	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
1	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
8	8	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	596	> fish_title
7	586	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
3	3	--> set -q SSH_TTY
5	566	--> if set -q argv[1]...
4	4	---> set -q argv[1]
37	42	---> set -l command (status current-command)
5	5	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
67	502	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
24	428	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	333	-----> for path in $argv...
38	48	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
36	59	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	212	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	135	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
38	113	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
38	75	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
37	37	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
41	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
17	17	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
70	135	> __fish_disable_bracketed_paste 'cargo run'
65	65	-> printf "\e[?2004l"
48	2222	> fish_title cargo\ run
25	2174	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
11	11	--> set -q SSH_TTY
15	2100	--> if set -q argv[1]...
31	31	---> set -q argv[1]
321	2054	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
39	39	----> string sub -l 20 -- $argv[1]
90	1694	----> prompt_pwd -d 1 -D 1
31	31	-----> set -l options h/help d/dir-length= D/full-length-dirs=
74	74	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
66	1370	-----> for path in $argv...
112	144	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
187	249	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
62	62	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
31	911	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
37	37	-------> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-------> set -l full
24	520	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
208	435	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
189	227	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
38	38	----------> math $fish_prompt_pwd_full_dirs - 1
29	29	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
234	307	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
73	73	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
11611203	11611203	> cargo run
241	1828	> fish_job_summary 1 1 'cargo run' SIGINT 'Quit request from job control (^C)'
1509	1535	-> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/fish_job_summary.fish
26	26	--> function fish_job_summary -a job_id is_foreground cmd_line signal_or_end_name signal_desc proc_pid proc_name...
11	52	-> if test "$signal_or_end_name" = SIGINT...
21	21	--> test "$signal_or_end_name" = SIGINT
14	14	--> test $is_foreground -eq 1
6	6	--> return
91	144	> __fish_enable_bracketed_paste
53	53	-> printf "\e[?2004h"
23	101	> fish_mode_prompt
24	78	-> fish_default_mode_prompt
9	54	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
33	33	---> test "$fish_key_bindings" = fish_vi_key_bindings
12	12	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
122	234951	> fish_prompt
33	33	-> set -l last_status $status
315	342	-> set -l normal (set_color normal)
27	27	--> set_color normal
302	361	-> set -l status_color (set_color brgreen)
59	59	--> set_color brgreen
214	252	-> set -l cwd_color (set_color $fish_color_cwd)
38	38	--> set_color $fish_color_cwd
214	280	-> set -l vcs_color (set_color brpurple)
66	66	--> set_color brpurple
16	16	-> set -l prompt_status ""
8	8	-> set -q fish_prompt_pwd_dir_length
10	10	-> set -lx fish_prompt_pwd_dir_length 0
13	13	-> set -l suffix '❯'
14	228	-> if functions -q fish_is_root_user...
56	56	--> functions -q fish_is_root_user
32	158	--> fish_is_root_user
5	99	---> if test "$EUID" = 0 2>/dev/null...
94	94	----> test "$EUID" = 0 2>/dev/null
3	21	---> if contains -- $USER root toor Administrator...
18	18	----> contains -- $USER root toor Administrator
6	6	---> return 1
22	384	-> if test $last_status -ne 0...
13	13	--> test $last_status -ne 0
129	156	--> set status_color (set_color $fish_color_error)
27	27	---> set_color $fish_color_error
193	193	--> set prompt_status $status_color "[" $last_status "]" $normal
320	232889	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
136	1005	--> prompt_login
5	21	---> if not set -q __fish_machine...
16	16	----> not set -q __fish_machine
6	28	---> if set -q __fish_machine[1]...
22	22	----> set -q __fish_machine[1]
25	25	---> set -l color_host $fish_color_host
4	13	---> if set -q SSH_TTY...
9	9	----> set -q SSH_TTY
527	782	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
42	42	----> set_color $fish_color_user
18	18	----> set_color normal
81	81	----> set_color $color_host
36	98	----> prompt_hostname
62	62	-----> string replace -r -- "\..*" "" $hostname
16	16	----> set_color normal
58	872	--> prompt_pwd
17	17	---> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	---> argparse -n prompt_pwd $options -- $argv
2	9	---> if set -q _flag_help...
7	7	----> set -q _flag_help
6	6	---> set -q argv[1]
10	10	---> set argv $PWD
5	5	---> set -ql _flag_d
5	5	---> set -q fish_prompt_pwd_dir_length
8	8	---> set -l fulldirs 0
4	4	---> set -ql _flag_D
35	35	---> set -q fish_prompt_pwd_full_dirs
137	137	---> set -l fish_prompt_pwd_full_dirs 1
38	554	---> for path in $argv...
287	318	----> set -l realhome (string escape --style=regex -- ~)
31	31	-----> string escape --style=regex -- ~
109	158	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
49	49	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	40	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
18	18	-----> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-----> echo $tmp
17	230692	--> fish_vcs_prompt
95	230675	---> fish_git_prompt $argv
10	57186	----> if not command -sq git...
57176	57176	-----> not command -sq git
2	26	----> if functions -q __fish_git_prompt_ready...
24	24	-----> functions -q __fish_git_prompt_ready
149	58364	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58215	58215	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
62	57583	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
44	57521	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	77	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
8	41	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
9	57298	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	57285	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	57283	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57194	57194	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
5	5	----> set -l dirty
7	7	----> set -l untracked
50888	56835	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5947	5947	-----> read -lz key value
9	44	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
6	6	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	71	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
2	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
4	4	----> set -l f ""
17	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
63	79	----> set b (string replace refs/heads/ '' -- $b)
16	16	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	32	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
10	652	> fish_title
7	642	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	621	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	42	---> set -l command (status current-command)
5	5	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
87	558	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
13	13	----> string sub -l 20 -- $command
33	458	----> prompt_pwd -d 1 -D 1
14	14	-----> set -l options h/help d/dir-length= D/full-length-dirs=
28	28	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
9	9	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
14	335	-----> for path in $argv...
47	59	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
46	67	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	195	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	116	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
38	93	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	55	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
41	59	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
314	686	> up-or-search
12	106	-> if commandline --search-mode...
94	94	--> commandline --search-mode
5	18	-> if commandline --paging-mode...
13	13	--> commandline --paging-mode
184	208	-> set -l lineno (commandline -L)
24	24	--> commandline -L
21	40	-> switch $lineno...
19	19	--> commandline -f history-search-backward
14635	341869	> source /usr/local/Cellar/fish/3.7.1/share/fish/completions/cargo.fish
344	127186	-> set -l __fish_cargo_subcommands (cargo --list 2>&1 | string replace -rf '^\s+([^\s]+)\s*(.*)' '$1\t$2' | string escape)
126842	126842	--> cargo --list 2>&1 | string replace -rf '^\s+([^\s]+)\s*(.*)' '$1\t$2' | string escape
225	190820	-> set -la __fish_cargo_subcommands (complete -C'cargo-' | string replace -rf '^cargo-(\w+).*' '$1')
64009	190595	--> complete -C'cargo-' | string replace -rf '^cargo-(\w+).*' '$1'
139	126586	---> __fish_describe_command cargo-
67	90	----> set -l argv_regex (string escape --style=regex -- "$argv")
23	23	-----> string escape --style=regex -- "$argv"
50638	126357	----> __fish_apropos ^$argv 2>/dev/null | awk -v FS=" +- +" '{
		split($1, names, ", ");
		for (name in names)
			if (names[name] ~ /^'"$argv_regex"'.* *\([18]\)/ ) {
				sub( "( |\t)*\\\([18]\\\)", "", names[name] );
				sub( " \\\[.*\\\]", "", names[name] );
				print names[name] "\t" $2;
			}
	}'
23	23	-----> set -l whatis $dir/whatis
6	6	-----> set -l max_age 600000
11	11	-----> set -l age $max_age
8	178	-----> if test -f "$whatis"...
29	29	------> test -f "$whatis"
64	141	------> set age (path mtime -R -- $whatis)
77	77	-------> path mtime -R -- $whatis
75448	75448	-----> MANPATH="$dir" apropos "$argv"
3	53	-----> if test $age -ge $max_age...
50	50	------> test $age -ge $max_age
143	143	-> complete -c cargo -f -c cargo -n __fish_use_subcommand -a "$__fish_cargo_subcommands"
110	110	-> complete -c cargo -x -c cargo -n '__fish_seen_subcommand_from help' -a "$__fish_cargo_subcommands"
38	489	-> for x in bench b build rustc t test...
27	27	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bench -a "(cargo bench --bench 2>&1 | string replace -rf '^\s+' '')"
12	12	--> complete -c cargo -n "__fish_seen_subcommand_from $x" -l lib -d 'Only this package\'s library'
19	19	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l test -a "(cargo test --test 2>&1 | string replace -rf '^\s+' '')"
18	18	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bench -a "(cargo bench --bench 2>&1 | string replace -rf '^\s+' '')"
10	10	--> complete -c cargo -n "__fish_seen_subcommand_from $x" -l lib -d 'Only this package\'s library'
18	18	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l test -a "(cargo test --test 2>&1 | string replace -rf '^\s+' '')"
17	17	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bench -a "(cargo bench --bench 2>&1 | string replace -rf '^\s+' '')"
10	10	--> complete -c cargo -n "__fish_seen_subcommand_from $x" -l lib -d 'Only this package\'s library'
17	17	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l test -a "(cargo test --test 2>&1 | string replace -rf '^\s+' '')"
22	22	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bench -a "(cargo bench --bench 2>&1 | string replace -rf '^\s+' '')"
10	10	--> complete -c cargo -n "__fish_seen_subcommand_from $x" -l lib -d 'Only this package\'s library'
16	16	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l test -a "(cargo test --test 2>&1 | string replace -rf '^\s+' '')"
18	18	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bench -a "(cargo bench --bench 2>&1 | string replace -rf '^\s+' '')"
12	12	--> complete -c cargo -n "__fish_seen_subcommand_from $x" -l lib -d 'Only this package\'s library'
22	22	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l test -a "(cargo test --test 2>&1 | string replace -rf '^\s+' '')"
41	41	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bench -a "(cargo bench --bench 2>&1 | string replace -rf '^\s+' '')"
54	54	--> complete -c cargo -n "__fish_seen_subcommand_from $x" -l lib -d 'Only this package\'s library'
108	108	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l test -a "(cargo test --test 2>&1 | string replace -rf '^\s+' '')"
72	423	-> for x in bench b build r run rustc t test...
20	20	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bin -a "(cargo run --bin 2>&1 | string replace -rf '^\s+' '')"
20	20	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l example -a "(cargo run --example 2>&1 | string replace -rf '^\s+' '')"
60	60	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bin -a "(cargo run --bin 2>&1 | string replace -rf '^\s+' '')"
51	51	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l example -a "(cargo run --example 2>&1 | string replace -rf '^\s+' '')"
16	16	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bin -a "(cargo run --bin 2>&1 | string replace -rf '^\s+' '')"
16	16	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l example -a "(cargo run --example 2>&1 | string replace -rf '^\s+' '')"
16	16	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bin -a "(cargo run --bin 2>&1 | string replace -rf '^\s+' '')"
17	17	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l example -a "(cargo run --example 2>&1 | string replace -rf '^\s+' '')"
16	16	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bin -a "(cargo run --bin 2>&1 | string replace -rf '^\s+' '')"
16	16	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l example -a "(cargo run --example 2>&1 | string replace -rf '^\s+' '')"
18	18	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bin -a "(cargo run --bin 2>&1 | string replace -rf '^\s+' '')"
18	18	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l example -a "(cargo run --example 2>&1 | string replace -rf '^\s+' '')"
17	17	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bin -a "(cargo run --bin 2>&1 | string replace -rf '^\s+' '')"
17	17	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l example -a "(cargo run --example 2>&1 | string replace -rf '^\s+' '')"
16	16	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l bin -a "(cargo run --bin 2>&1 | string replace -rf '^\s+' '')"
17	17	--> complete -c cargo -x -n "__fish_seen_subcommand_from $x" -l example -a "(cargo run --example 2>&1 | string replace -rf '^\s+' '')"
5	5	-> function __fish_cargo_packages...
15	15	-> complete -c cargo -n '__fish_seen_subcommand_from run test build debug check' -l package \
    -xa "(__fish_cargo_packages)"
1	1	-> function __fish_cargo_search...
23	23	-> complete -c cargo -n '__fish_seen_subcommand_from add install' -n '__fish_is_nth_token 2' \
    -a "(__fish_cargo_search (commandline -ct))"
8	8	-> complete -c cargo -n __fish_use_subcommand -l explain -d 'Run `rustc --explain CODE`'
7	7	-> complete -c cargo -n __fish_use_subcommand -l color -d 'Coloring: auto, always, never'
7	7	-> complete -c cargo -n __fish_use_subcommand -l config -d 'Override a configuration value (unstable)'
9	9	-> complete -c cargo -n __fish_use_subcommand -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
9	9	-> complete -c cargo -n __fish_use_subcommand -s V -l version -d 'Print version info and exit'
8	8	-> complete -c cargo -n __fish_use_subcommand -l list -d 'List installed commands'
13	13	-> complete -c cargo -n __fish_use_subcommand -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
11	11	-> complete -c cargo -n __fish_use_subcommand -s q -l quiet -d 'No output printed to stdout'
8	8	-> complete -c cargo -n __fish_use_subcommand -l frozen -d 'Require Cargo.lock and cache are up to date'
8	8	-> complete -c cargo -n __fish_use_subcommand -l locked -d 'Require Cargo.lock is up to date'
8	8	-> complete -c cargo -n __fish_use_subcommand -l offline -d 'Run without accessing the network'
9	9	-> complete -c cargo -n __fish_use_subcommand -s h -l help -d 'Prints help information'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a bench -d 'Execute all benchmarks of a local package'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a build -d 'Compile a local package and all of its dependencies'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a check -d 'Check a local package and all of its dependencies for errors'
8	8	-> complete -c cargo -n __fish_use_subcommand -f -a clean -d 'Remove artifacts that cargo has generated in the past'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a complete -d 'Generate completion file for a shell'
8	8	-> complete -c cargo -n __fish_use_subcommand -f -a doc -d 'Build a package\'s documentation'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a fetch -d 'Fetch dependencies of a package from the network'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a fix -d 'Automatically fix lint warnings reported by rustc'
10	10	-> complete -c cargo -n __fish_use_subcommand -f -a generate-lockfile -d 'Generate the lockfile for a package'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a git-checkout -d 'This subcommand has been removed'
10	10	-> complete -c cargo -n __fish_use_subcommand -f -a init -d 'Create a new cargo package in an existing directory'
10	10	-> complete -c cargo -n __fish_use_subcommand -f -a install -d 'Install a Rust binary. Default location is $HOME/.cargo/bin'
10	10	-> complete -c cargo -n __fish_use_subcommand -f -a locate-project -d 'Print a JSON representation of a Cargo.toml file\'s location'
10	10	-> complete -c cargo -n __fish_use_subcommand -f -a login -d 'Save an api token from the registry locally. If token is not specified, it will be read from stdin.'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a logout -d 'Remove an API token from the registry locally'
12	12	-> complete -c cargo -n __fish_use_subcommand -f -a metadata -d 'Output the resolved dependencies of a package, the concrete used versions including overrides, in machine-readable format'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a new -d 'Create a new cargo package at <path>'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a owner -d 'Manage the owners of a crate on the registry'
10	10	-> complete -c cargo -n __fish_use_subcommand -f -a package -d 'Assemble the local package into a distributable tarball'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a pkgid -d 'Print a fully qualified package specification'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a publish -d 'Upload a package to the registry'
13	13	-> complete -c cargo -n __fish_use_subcommand -f -a read-manifest -d 'Print a JSON representation of a Cargo.toml manifest.

Deprecated, use `cargo metadata --no-deps` instead.'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a run -d 'Run a binary or example of the local package'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a rustc -d 'Compile a package, and pass extra options to the compiler'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a rustdoc -d 'Build a package\'s documentation, using specified custom flags.'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a search -d 'Search packages in crates.io'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a test -d 'Execute all unit and integration tests and build examples of a local package'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a tree -d 'Display a tree visualization of a dependency graph'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a uninstall -d 'Remove a Rust binary'
10	10	-> complete -c cargo -n __fish_use_subcommand -f -a update -d 'Update dependencies as recorded in the local lock file'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a vendor -d 'Vendor all dependencies for a project locally'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a verify-project -d 'Check correctness of crate manifest'
11	11	-> complete -c cargo -n __fish_use_subcommand -f -a version -d 'Show version information'
8	8	-> complete -c cargo -n __fish_use_subcommand -f -a yank -d 'Remove a pushed crate from the index'
9	9	-> complete -c cargo -n __fish_use_subcommand -f -a help -d 'Prints this message or the help of the given subcommand(s)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l bin -d 'Benchmark only the specified binary'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l example -d 'Benchmark only the specified example'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l test -d 'Benchmark only the specified test target'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l bench -d 'Benchmark only the specified bench target'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -s p -l package -d 'Package to run benchmarks for'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l exclude -d 'Exclude packages from the benchmark'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l features -d 'Space or comma separated list of features to activate'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l target -d 'Build for the target triple'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l target-dir -d 'Directory for all generated artifacts'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l manifest-path -d 'Path to Cargo.toml'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l message-format -d 'Error format'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l color -d 'Coloring: auto, always, never'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l lib -d 'Benchmark only this package\'s library'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l bins -d 'Benchmark all binaries'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l examples -d 'Benchmark all examples'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l tests -d 'Benchmark all tests'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l benches -d 'Benchmark all benches'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l all-targets -d 'Benchmark all targets'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l no-run -d 'Compile, but don\'t run benchmarks'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l all -d 'Alias for --workspace (deprecated)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l workspace -d 'Benchmark all packages in the workspace'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l all-features -d 'Activate all available features'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l no-default-features -d 'Do not activate the `default` feature'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l ignore-rust-version -d 'Ignore `rust-version` specification in packages (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l no-fail-fast -d 'Run all benchmarks regardless of failure'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l unit-graph -d 'Output build graph in JSON (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -s V -l version -d 'Prints version information'
17	17	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from bench" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -s p -l package -d 'Package to build (see `cargo help pkgid`)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l exclude -d 'Exclude packages from the build'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l bin -d 'Build only the specified binary'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l example -d 'Build only the specified example'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l test -d 'Build only the specified test target'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l bench -d 'Build only the specified bench target'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l profile -d 'Build artifacts with the specified profile'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l features -d 'Space or comma separated list of features to activate'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l target -d 'Build for the target triple'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l target-dir -d 'Directory for all generated artifacts'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l out-dir -d 'Copy final artifacts to this directory (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l manifest-path -d 'Path to Cargo.toml'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l message-format -d 'Error format'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l all -d 'Alias for --workspace (deprecated)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l workspace -d 'Build all packages in the workspace'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l lib -d 'Build only this package\'s library'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l bins -d 'Build all binaries'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l examples -d 'Build all examples'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l tests -d 'Build all tests'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l benches -d 'Build all benches'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l all-targets -d 'Build all targets'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l release -d 'Build artifacts in release mode, with optimizations'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l all-features -d 'Activate all available features'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l no-default-features -d 'Do not activate the `default` feature'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l ignore-rust-version -d 'Ignore `rust-version` specification in packages (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l build-plan -d 'Output the build plan in JSON (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l unit-graph -d 'Output build graph in JSON (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l future-incompat-report -d 'Ouputs a future incompatibility report at the end of the build (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -s h -l help -d 'Prints help information'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from build" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from build" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from build" -l offline -d 'Run without accessing the network'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -s p -l package -d 'Package(s) to check'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l exclude -d 'Exclude packages from the check'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l bin -d 'Check only the specified binary'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l example -d 'Check only the specified example'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l test -d 'Check only the specified test target'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l bench -d 'Check only the specified bench target'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l profile -d 'Check artifacts with the specified profile'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l features -d 'Space or comma separated list of features to activate'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l target -d 'Check for the target triple'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l target-dir -d 'Directory for all generated artifacts'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l manifest-path -d 'Path to Cargo.toml'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l message-format -d 'Error format'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l color -d 'Coloring: auto, always, never'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from check" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l all -d 'Alias for --workspace (deprecated)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l workspace -d 'Check all packages in the workspace'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l lib -d 'Check only this package\'s library'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l bins -d 'Check all binaries'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l examples -d 'Check all examples'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l tests -d 'Check all tests'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l benches -d 'Check all benches'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l all-targets -d 'Check all targets'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l release -d 'Check artifacts in release mode, with optimizations'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l all-features -d 'Activate all available features'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l no-default-features -d 'Do not activate the `default` feature'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l ignore-rust-version -d 'Ignore `rust-version` specification in packages (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l unit-graph -d 'Output build graph in JSON (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l future-incompat-report -d 'Ouputs a future incompatibility report at the end of the build (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from check" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from check" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -s p -l package -d 'Package to clean artifacts for'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l manifest-path -d 'Path to Cargo.toml'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l target -d 'Target triple to clean output for'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l target-dir -d 'Directory for all generated artifacts'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l profile -d 'Clean artifacts of the specified profile'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l release -d 'Whether or not to clean release artifacts'
14	14	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l doc -d 'Whether or not to clean just the documentation directory'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -s h -l help -d 'Prints help information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from clean" -l offline -d 'Run without accessing the network'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from complete" -l color -d 'Coloring: auto, always, never'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from complete" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from complete" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from complete" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from complete" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from complete" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from complete" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from complete" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from complete" -l offline -d 'Run without accessing the network'
24	24	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -s p -l package -d 'Package to document'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l exclude -d 'Exclude packages from the build'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l bin -d 'Document only the specified binary'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l profile -d 'Build artifacts with the specified profile'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l features -d 'Space or comma separated list of features to activate'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l target -d 'Build for the target triple'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l target-dir -d 'Directory for all generated artifacts'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l manifest-path -d 'Path to Cargo.toml'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l message-format -d 'Error format'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l open -d 'Opens the docs in a browser after the operation'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l all -d 'Alias for --workspace (deprecated)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l workspace -d 'Document all packages in the workspace'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l no-deps -d 'Don\'t build documentation for dependencies'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l document-private-items -d 'Document private items'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l lib -d 'Document only this package\'s library'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l bins -d 'Document all binaries'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l release -d 'Build artifacts in release mode, with optimizations'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l all-features -d 'Activate all available features'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l no-default-features -d 'Do not activate the `default` feature'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l ignore-rust-version -d 'Ignore `rust-version` specification in packages (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l unit-graph -d 'Output build graph in JSON (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l frozen -d 'Require Cargo.lock and cache are up to date'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l locked -d 'Require Cargo.lock is up to date'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from doc" -l offline -d 'Run without accessing the network'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -l manifest-path -d 'Path to Cargo.toml'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -l target -d 'Fetch dependencies for the target triple'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -s q -l quiet -d 'No output printed to stdout'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -l frozen -d 'Require Cargo.lock and cache are up to date'
14	14	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fetch" -l offline -d 'Run without accessing the network'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -s p -l package -d 'Package(s) to fix'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l exclude -d 'Exclude packages from the fixes'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l bin -d 'Fix only the specified binary'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l example -d 'Fix only the specified example'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l test -d 'Fix only the specified test target'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l bench -d 'Fix only the specified bench target'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l profile -d 'Build artifacts with the specified profile'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l features -d 'Space or comma separated list of features to activate'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l target -d 'Fix for the target triple'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l target-dir -d 'Directory for all generated artifacts'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l manifest-path -d 'Path to Cargo.toml'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l message-format -d 'Error format'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l color -d 'Coloring: auto, always, never'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l config -d 'Override a configuration value (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -s q -l quiet -d 'No output printed to stdout'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l all -d 'Alias for --workspace (deprecated)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l workspace -d 'Fix all packages in the workspace'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l lib -d 'Fix only this package\'s library'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l bins -d 'Fix all binaries'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l examples -d 'Fix all examples'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l tests -d 'Fix all tests'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l benches -d 'Fix all benches'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l all-targets -d 'Fix all targets (default)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l release -d 'Fix artifacts in release mode, with optimizations'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l all-features -d 'Activate all available features'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l no-default-features -d 'Do not activate the `default` feature'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l broken-code -d 'Fix code even if it already has compiler errors'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l edition -d 'Fix in preparation for the next edition'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l edition-idioms -d 'Fix warnings to migrate to the idioms of an edition'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l allow-no-vcs -d 'Fix code even if a VCS was not detected'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l allow-dirty -d 'Fix code even if the working directory is dirty'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l allow-staged -d 'Fix code even if the working directory has staged changes'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l ignore-rust-version -d 'Ignore `rust-version` specification in packages (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -s V -l version -d 'Prints version information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l frozen -d 'Require Cargo.lock and cache are up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from fix" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -l manifest-path -d 'Path to Cargo.toml'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -l color -d 'Coloring: auto, always, never'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -l config -d 'Override a configuration value (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -s q -l quiet -d 'No output printed to stdout'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -s h -l help -d 'Prints help information'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -l frozen -d 'Require Cargo.lock and cache are up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -l locked -d 'Require Cargo.lock is up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from generate-lockfile" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from git-checkout" -l color -d 'Coloring: auto, always, never'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from git-checkout" -l config -d 'Override a configuration value (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from git-checkout" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from git-checkout" -s h -l help -d 'Prints help information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from git-checkout" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from git-checkout" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from git-checkout" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from git-checkout" -l locked -d 'Require Cargo.lock is up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from git-checkout" -l offline -d 'Run without accessing the network'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l registry -d 'Registry to use'
17	17	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l vcs -d 'Initialize a new repository for the given version control system (git, hg, pijul, or fossil) or do not initialize any version control at all (none), overriding a global configuration.' -r -f -a "git hg pijul fossil none"
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l edition -d 'Edition to set for the crate generated' -r -f -a "2015 2018 2021"
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l name -d 'Set the resulting package name, defaults to the directory name'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l color -d 'Coloring: auto, always, never'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from init" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from init" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l bin -d 'Use a binary (application) template [default]'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l lib -d 'Use a library template'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from init" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from init" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from init" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l locked -d 'Require Cargo.lock is up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from init" -l offline -d 'Run without accessing the network'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l version -d 'Specify a version to install'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l git -d 'Git URL to install the specified crate from'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l branch -d 'Branch to use when installing from git'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l tag -d 'Tag to use when installing from git'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l rev -d 'Specific commit to use when installing from git'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l path -d 'Filesystem path to local crate to install'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from install" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l features -d 'Space or comma separated list of features to activate'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l profile -d 'Install artifacts with the specified profile'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l bin -d 'Install only the specified binary'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l example -d 'Install only the specified example'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l target -d 'Build for the target triple'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l target-dir -d 'Directory for all generated artifacts'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l root -d 'Directory to install packages into'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l index -d 'Registry index to install from'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l registry -d 'Registry to use'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l color -d 'Coloring: auto, always, never'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l config -d 'Override a configuration value (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from install" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l list -d 'list all installed packages and their versions'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from install" -s f -l force -d 'Force overwriting existing crates or binaries'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l no-track -d 'Do not save tracking information'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l all-features -d 'Activate all available features'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l no-default-features -d 'Do not activate the `default` feature'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l debug -d 'Build in debug mode instead of release mode'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l bins -d 'Install all binaries'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l examples -d 'Install all examples'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -s h -l help -d 'Prints help information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from install" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l frozen -d 'Require Cargo.lock and cache are up to date'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from install" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -l manifest-path -d 'Path to Cargo.toml'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -l message-format -d 'Output representation [possible values: json, plain]'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -l workspace -d 'Locate Cargo.toml of the workspace root'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -s h -l help -d 'Prints help information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -s V -l version -d 'Prints version information'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -l locked -d 'Require Cargo.lock is up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from locate-project" -l offline -d 'Run without accessing the network'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from login" -l host -d 'Host to set the token for'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from login" -l registry -d 'Registry to use'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from login" -l color -d 'Coloring: auto, always, never'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from login" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from login" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from login" -s q -l quiet -d 'No output printed to stdout'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from login" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from login" -s V -l version -d 'Prints version information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from login" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from login" -l frozen -d 'Require Cargo.lock and cache are up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from login" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from login" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -l registry -d 'Registry to use'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -l color -d 'Coloring: auto, always, never'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -s q -l quiet -d 'No output printed to stdout'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -s V -l version -d 'Prints version information'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from logout" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l features -d 'Space or comma separated list of features to activate'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l filter-platform -d 'Only include resolve dependencies matching the given target-triple'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l manifest-path -d 'Path to Cargo.toml'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l format-version -d 'Format version' -r -f -a 1
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -s q -l quiet -d 'Do not print cargo log messages'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l all-features -d 'Activate all available features'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l no-default-features -d 'Do not activate the `default` feature'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l no-deps -d 'Output information only about the workspace members and don\'t fetch dependencies'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -s h -l help -d 'Prints help information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from metadata" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l registry -d 'Registry to use'
15	15	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l vcs -d 'Initialize a new repository for the given version control system (git, hg, pijul, or fossil) or do not initialize any version control at all (none), overriding a global configuration.' -r -f -a "git hg pijul fossil none"
38	38	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l edition -d 'Edition to set for the crate generated' -r -f -a "2015 2018 2021"
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l name -d 'Set the resulting package name, defaults to the directory name'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from new" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from new" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l bin -d 'Use a binary (application) template [default]'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l lib -d 'Use a library template'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from new" -s h -l help -d 'Prints help information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from new" -s V -l version -d 'Prints version information'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from new" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l frozen -d 'Require Cargo.lock and cache are up to date'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from new" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -s a -l add -d 'Name of a user or team to invite as an owner'
15	15	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -s r -l remove -d 'Name of a user or team to remove as an owner'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -l index -d 'Registry index to modify owners for'
30	30	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -l token -d 'API token to use when authenticating'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -l registry -d 'Registry to use'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -l color -d 'Coloring: auto, always, never'
50	50	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -l config -d 'Override a configuration value (unstable)'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
76	76	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -s q -l quiet -d 'No output printed to stdout'
20	20	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -s l -l list -d 'List owners of a crate'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -s h -l help -d 'Prints help information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -s V -l version -d 'Prints version information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
48	48	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -l frozen -d 'Require Cargo.lock and cache are up to date'
16	16	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -l locked -d 'Require Cargo.lock is up to date'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from owner" -l offline -d 'Run without accessing the network'
51	51	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l target -d 'Build for the target triple'
46	46	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l target-dir -d 'Directory for all generated artifacts'
61	61	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l features -d 'Space or comma separated list of features to activate'
48	48	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l manifest-path -d 'Path to Cargo.toml'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from package" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
27	27	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l color -d 'Coloring: auto, always, never'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l config -d 'Override a configuration value (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from package" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from package" -s q -l quiet -d 'No output printed to stdout'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from package" -s l -l list -d 'Print files included in a package without making one'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l no-verify -d 'Don\'t verify the contents by building them'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l no-metadata -d 'Ignore warnings about a lack of human-usable metadata'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l allow-dirty -d 'Allow dirty working directories to be packaged'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l all-features -d 'Activate all available features'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l no-default-features -d 'Do not activate the `default` feature'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from package" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from package" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from package" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l locked -d 'Require Cargo.lock is up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from package" -l offline -d 'Run without accessing the network'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -s p -l package -d 'Argument to get the package ID specifier for'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -l manifest-path -d 'Path to Cargo.toml'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -l color -d 'Coloring: auto, always, never'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -l config -d 'Override a configuration value (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -s q -l quiet -d 'No output printed to stdout'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -s h -l help -d 'Prints help information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -l frozen -d 'Require Cargo.lock and cache are up to date'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -l locked -d 'Require Cargo.lock is up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from pkgid" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l index -d 'Registry index URL to upload the package to'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l host -d 'DEPRECATED, renamed to \'--index\''
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l token -d 'Token to use when uploading'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l target -d 'Build for the target triple'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l target-dir -d 'Directory for all generated artifacts'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l manifest-path -d 'Path to Cargo.toml'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l features -d 'Space or comma separated list of features to activate'
24	24	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l registry -d 'Registry to publish to'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l color -d 'Coloring: auto, always, never'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l config -d 'Override a configuration value (unstable)'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -s q -l quiet -d 'No output printed to stdout'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l no-verify -d 'Don\'t verify the contents by building them'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l allow-dirty -d 'Allow dirty working directories to be packaged'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l all-features -d 'Activate all available features'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l no-default-features -d 'Do not activate the `default` feature'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l dry-run -d 'Perform all checks without uploading'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -s h -l help -d 'Prints help information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l frozen -d 'Require Cargo.lock and cache are up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l locked -d 'Require Cargo.lock is up to date'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from publish" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -l manifest-path -d 'Path to Cargo.toml'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -l config -d 'Override a configuration value (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -s q -l quiet -d 'No output printed to stdout'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -s h -l help -d 'Prints help information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -s V -l version -d 'Prints version information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from read-manifest" -l offline -d 'Run without accessing the network'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l bin -d 'Name of the bin target to run'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l example -d 'Name of the example target to run'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from run" -s p -l package -d 'Package with the target to run'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from run" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l profile -d 'Build artifacts with the specified profile'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l features -d 'Space or comma separated list of features to activate'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l target -d 'Build for the target triple'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l target-dir -d 'Directory for all generated artifacts'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l manifest-path -d 'Path to Cargo.toml'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l message-format -d 'Error format'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from run" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from run" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l release -d 'Build artifacts in release mode, with optimizations'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l all-features -d 'Activate all available features'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l no-default-features -d 'Do not activate the `default` feature'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l unit-graph -d 'Output build graph in JSON (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l ignore-rust-version -d 'Ignore `rust-version` specification in packages (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from run" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from run" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from run" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -s p -l package -d 'Package to build'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l bin -d 'Build only the specified binary'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l example -d 'Build only the specified example'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l test -d 'Build only the specified test target'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l bench -d 'Build only the specified bench target'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l profile -d 'Build artifacts with the specified profile'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l features -d 'Space or comma separated list of features to activate'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l target -d 'Target triple which compiles will be for'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l print -d 'Output compiler information without compiling'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l target-dir -d 'Directory for all generated artifacts'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l manifest-path -d 'Path to Cargo.toml'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l message-format -d 'Error format'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l config -d 'Override a configuration value (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -s q -l quiet -d 'No output printed to stdout'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l lib -d 'Build only this package\'s library'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l bins -d 'Build all binaries'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l examples -d 'Build all examples'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l tests -d 'Build all tests'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l benches -d 'Build all benches'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l all-targets -d 'Build all targets'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l release -d 'Build artifacts in release mode, with optimizations'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l all-features -d 'Activate all available features'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l no-default-features -d 'Do not activate the `default` feature'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l unit-graph -d 'Output build graph in JSON (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l ignore-rust-version -d 'Ignore `rust-version` specification in packages (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l future-incompat-report -d 'Ouputs a future incompatibility report at the end of the build (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -s h -l help -d 'Prints help information'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustc" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -s p -l package -d 'Package to document'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l bin -d 'Build only the specified binary'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l example -d 'Build only the specified example'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l test -d 'Build only the specified test target'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l bench -d 'Build only the specified bench target'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l profile -d 'Build artifacts with the specified profile'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l features -d 'Space or comma separated list of features to activate'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l target -d 'Build for the target triple'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l target-dir -d 'Directory for all generated artifacts'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l manifest-path -d 'Path to Cargo.toml'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l message-format -d 'Error format'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l color -d 'Coloring: auto, always, never'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -s q -l quiet -d 'No output printed to stdout'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l open -d 'Opens the docs in a browser after the operation'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l lib -d 'Build only this package\'s library'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l bins -d 'Build all binaries'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l examples -d 'Build all examples'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l tests -d 'Build all tests'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l benches -d 'Build all benches'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l all-targets -d 'Build all targets'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l release -d 'Build artifacts in release mode, with optimizations'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l all-features -d 'Activate all available features'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l no-default-features -d 'Do not activate the `default` feature'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l unit-graph -d 'Output build graph in JSON (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l ignore-rust-version -d 'Ignore `rust-version` specification in packages (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -s h -l help -d 'Prints help information'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -s V -l version -d 'Prints version information'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from rustdoc" -l offline -d 'Run without accessing the network'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from search" -l index -d 'Registry index URL to upload the package to'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from search" -l host -d 'DEPRECATED, renamed to \'--index\''
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from search" -l limit -d 'Limit the number of results (default: 10, max: 100)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from search" -l registry -d 'Registry to use'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from search" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from search" -l config -d 'Override a configuration value (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from search" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from search" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from search" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from search" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from search" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from search" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from search" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from search" -l offline -d 'Run without accessing the network'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l bin -d 'Test only the specified binary'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l example -d 'Test only the specified example'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l test -d 'Test only the specified test target'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l bench -d 'Test only the specified bench target'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -s p -l package -d 'Package to run tests for'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l exclude -d 'Exclude packages from the test'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -s j -l jobs -d 'Number of parallel jobs, defaults to # of CPUs'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l profile -d 'Build artifacts with the specified profile'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l features -d 'Space or comma separated list of features to activate'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l target -d 'Build for the target triple'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l target-dir -d 'Directory for all generated artifacts'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l manifest-path -d 'Path to Cargo.toml'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l message-format -d 'Error format'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l color -d 'Coloring: auto, always, never'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -s q -l quiet -d 'Display one character per test instead of one line'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l lib -d 'Test only this package\'s library unit tests'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l bins -d 'Test all binaries'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l examples -d 'Test all examples'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l tests -d 'Test all tests'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l benches -d 'Test all benches'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l all-targets -d 'Test all targets'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l doc -d 'Test only this library\'s documentation'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l no-run -d 'Compile, but don\'t run tests'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l no-fail-fast -d 'Run all tests regardless of failure'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l all -d 'Alias for --workspace (deprecated)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l workspace -d 'Test all packages in the workspace'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l release -d 'Build artifacts in release mode, with optimizations'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l all-features -d 'Activate all available features'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l no-default-features -d 'Do not activate the `default` feature'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l ignore-rust-version -d 'Ignore `rust-version` specification in packages (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l unit-graph -d 'Output build graph in JSON (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l future-incompat-report -d 'Ouputs a future incompatibility report at the end of the build (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from test" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l frozen -d 'Require Cargo.lock and cache are up to date'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l locked -d 'Require Cargo.lock is up to date'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from test" -l offline -d 'Run without accessing the network'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l manifest-path -d 'Path to Cargo.toml'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s p -l package -d 'Package to be used as the root of the tree'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l exclude -d 'Exclude specific workspace members'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l features -d 'Space or comma separated list of features to activate'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l target -d 'Filter dependencies matching the given target-triple (default host platform). Pass `all` to include all targets.'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s e -l edges -d 'The kinds of dependencies to display (features, normal, build, dev, all, no-dev, no-build, no-normal)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s i -l invert -d 'Invert the tree direction and focus on the given package'
16	16	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l prefix -d 'Change the prefix (indentation) of how each entry is displayed' -r -f -a "depth indent none"
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l charset -d 'Character set to use in output: utf8, ascii' -r -f -a "utf8 ascii"
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s f -l format -d 'Format string used for printing dependencies'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l color -d 'Coloring: auto, always, never'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s q -l quiet -d 'Suppress status messages'
31	31	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l workspace -d 'Display the tree for all packages in the workspace'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s a -l all
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l all-targets
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l all-features -d 'Activate all available features'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l no-default-features -d 'Do not activate the `default` feature'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l no-dev-dependencies
26	26	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l no-indent
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l prefix-depth
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l no-dedupe -d 'Do not de-duplicate (repeats all shared dependencies)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s d -l duplicates -d 'Show only dependencies which come in multiple versions (implies -i)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s V -l version
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from tree" -l offline -d 'Run without accessing the network'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -s p -l package -d 'Package to uninstall'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -l bin -d 'Only uninstall the binary NAME'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -l root -d 'Directory to uninstall packages from'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -l config -d 'Override a configuration value (unstable)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -s q -l quiet -d 'No output printed to stdout'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -l locked -d 'Require Cargo.lock is up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from uninstall" -l offline -d 'Run without accessing the network'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from update" -s p -l package -d 'Package to update'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from update" -l precise -d 'Update a single dependency to exactly PRECISE when used with -p'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from update" -l manifest-path -d 'Path to Cargo.toml'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from update" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from update" -l config -d 'Override a configuration value (unstable)'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from update" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from update" -s q -l quiet -d 'No output printed to stdout'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from update" -s w -l workspace -d 'Only update the workspace packages'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from update" -l aggressive -d 'Force updating all dependencies of SPEC as well when used with -p'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from update" -l dry-run -d 'Don\'t actually write the lockfile'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from update" -s h -l help -d 'Prints help information'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from update" -s V -l version -d 'Prints version information'
16	16	-> complete -c cargo -n "__fish_seen_subcommand_from update" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from update" -l frozen -d 'Require Cargo.lock and cache are up to date'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from update" -l locked -d 'Require Cargo.lock is up to date'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from update" -l offline -d 'Run without accessing the network'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l manifest-path -d 'Path to Cargo.toml'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -s s -l sync -d 'Additional `Cargo.toml` to sync and vendor'
20	20	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l color -d 'Coloring: auto, always, never'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l config -d 'Override a configuration value (unstable)'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -s q -l quiet -d 'No output printed to stdout'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l no-delete -d 'Don\'t delete older crates in the vendor directory'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l respect-source-config -d 'Respect `[source]` config in `.cargo/config`'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l versioned-dirs -d 'Always include version in subdir name'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l no-merge-sources
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l relative-path
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l only-git-deps
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l disallow-duplicates
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -s h -l help -d 'Prints help information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from vendor" -l offline -d 'Run without accessing the network'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -l manifest-path -d 'Path to Cargo.toml'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -l color -d 'Coloring: auto, always, never'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -l config -d 'Override a configuration value (unstable)'
13	13	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -s q -l quiet -d 'No output printed to stdout'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -s V -l version -d 'Prints version information'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -l frozen -d 'Require Cargo.lock and cache are up to date'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from verify-project" -l offline -d 'Run without accessing the network'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from version" -l color -d 'Coloring: auto, always, never'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from version" -l config -d 'Override a configuration value (unstable)'
12	12	-> complete -c cargo -n "__fish_seen_subcommand_from version" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from version" -s q -l quiet -d 'No output printed to stdout'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from version" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from version" -s V -l version -d 'Prints version information'
14	14	-> complete -c cargo -n "__fish_seen_subcommand_from version" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from version" -l frozen -d 'Require Cargo.lock and cache are up to date'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from version" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from version" -l offline -d 'Run without accessing the network'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l vers -d 'The version to yank or un-yank'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l index -d 'Registry index to yank from'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l token -d 'API token to use when authenticating'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l registry -d 'Registry to use'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l config -d 'Override a configuration value (unstable)'
11	11	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -s q -l quiet -d 'No output printed to stdout'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l undo -d 'Undo a yank, putting a version back into the index'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -s V -l version -d 'Prints version information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l locked -d 'Require Cargo.lock is up to date'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from yank" -l offline -d 'Run without accessing the network'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from help" -l color -d 'Coloring: auto, always, never'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from help" -l config -d 'Override a configuration value (unstable)'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from help" -s Z -d 'Unstable (nightly-only) flags to Cargo, see \'cargo -Z help\' for details'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from help" -s h -l help -d 'Prints help information'
10	10	-> complete -c cargo -n "__fish_seen_subcommand_from help" -s V -l version -d 'Prints version information'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from help" -s v -l verbose -d 'Use verbose output (-vv very verbose/build.rs output)'
8	8	-> complete -c cargo -n "__fish_seen_subcommand_from help" -l frozen -d 'Require Cargo.lock and cache are up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from help" -l locked -d 'Require Cargo.lock is up to date'
9	9	-> complete -c cargo -n "__fish_seen_subcommand_from help" -l offline -d 'Run without accessing the network'
104	241	> __fish_disable_bracketed_paste 'cargo run -v'
137	137	-> printf "\e[?2004l"
48	2117	> fish_title cargo\ run\ -v
26	2069	-> if not set -q INSIDE_EMACS...
31	31	--> not set -q INSIDE_EMACS
18	18	--> set -l ssh
11	11	--> set -q SSH_TTY
21	1983	--> if set -q argv[1]...
10	10	---> set -q argv[1]
432	1952	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
32	32	----> string sub -l 20 -- $argv[1]
180	1488	----> prompt_pwd -d 1 -D 1
33	33	-----> set -l options h/help d/dir-length= D/full-length-dirs=
77	77	-----> argparse -n prompt_pwd $options -- $argv
4	18	-----> if set -q _flag_help...
14	14	------> set -q _flag_help
11	11	-----> set -q argv[1]
20	20	-----> set argv $PWD
9	9	-----> set -ql _flag_d
21	21	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
39	1064	-----> for path in $argv...
133	166	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
136	204	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
68	68	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
20	655	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
18	409	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
116	339	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
124	223	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
99	99	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
128	185	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
57	57	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
61159589	61159589	> cargo run -v
72	214	> __fish_enable_bracketed_paste
142	142	-> printf "\e[?2004h"
29	195	> fish_mode_prompt
97	166	-> fish_default_mode_prompt
10	69	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
44	44	---> test "$fish_key_bindings" = fish_vi_key_bindings
15	15	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
90	248668	> fish_prompt
38	38	-> set -l last_status $status
107	182	-> set -l normal (set_color normal)
75	75	--> set_color normal
78	97	-> set -l status_color (set_color brgreen)
19	19	--> set_color brgreen
108	128	-> set -l cwd_color (set_color $fish_color_cwd)
20	20	--> set_color $fish_color_cwd
179	203	-> set -l vcs_color (set_color brpurple)
24	24	--> set_color brpurple
28	28	-> set -l prompt_status ""
12	12	-> set -q fish_prompt_pwd_dir_length
10	10	-> set -lx fish_prompt_pwd_dir_length 0
10	10	-> set -l suffix '❯'
7	336	-> if functions -q fish_is_root_user...
126	126	--> functions -q fish_is_root_user
32	203	--> fish_is_root_user
5	100	---> if test "$EUID" = 0 2>/dev/null...
95	95	----> test "$EUID" = 0 2>/dev/null
2	63	---> if contains -- $USER root toor Administrator...
61	61	----> contains -- $USER root toor Administrator
8	8	---> return 1
12	218	-> if test $last_status -ne 0...
14	14	--> test $last_status -ne 0
133	155	--> set status_color (set_color $fish_color_error)
22	22	---> set_color $fish_color_error
37	37	--> set prompt_status $status_color "[" $last_status "]" $normal
319	247303	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
92	1088	--> prompt_login
4	25	---> if not set -q __fish_machine...
21	21	----> not set -q __fish_machine
3	11	---> if set -q __fish_machine[1]...
8	8	----> set -q __fish_machine[1]
29	29	---> set -l color_host $fish_color_host
2	9	---> if set -q SSH_TTY...
7	7	----> set -q SSH_TTY
657	922	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
30	30	----> set_color $fish_color_user
25	25	----> set_color normal
32	32	----> set_color $color_host
96	160	----> prompt_hostname
64	64	-----> string replace -r -- "\..*" "" $hostname
18	18	----> set_color normal
120	762	--> prompt_pwd
27	27	---> set -l options h/help d/dir-length= D/full-length-dirs=
31	31	---> argparse -n prompt_pwd $options -- $argv
3	11	---> if set -q _flag_help...
8	8	----> set -q _flag_help
7	7	---> set -q argv[1]
13	13	---> set argv $PWD
6	6	---> set -ql _flag_d
9	9	---> set -q fish_prompt_pwd_dir_length
10	10	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
7	7	---> set -q fish_prompt_pwd_full_dirs
9	9	---> set -l fish_prompt_pwd_full_dirs 1
44	506	---> for path in $argv...
174	210	----> set -l realhome (string escape --style=regex -- ~)
36	36	-----> string escape --style=regex -- ~
136	201	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
65	65	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	51	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
25	25	-----> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-----> echo $tmp
201	245134	--> fish_vcs_prompt
213	244933	---> fish_git_prompt $argv
12	60892	----> if not command -sq git...
60880	60880	-----> not command -sq git
4	78	----> if functions -q __fish_git_prompt_ready...
74	74	-----> functions -q __fish_git_prompt_ready
138	62966	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
62828	62828	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
8	8	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
61	58686	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
38	58625	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
5	5	------> set -l branch
6	6	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
34	111	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
9	66	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
30	30	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
10	58366	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
10	58352	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	58342	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58254	58254	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
7	7	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
5	5	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
22	22	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
55641	61489	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5848	5848	-----> read -lz key value
6	39	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
10	10	----> contains untrackedfiles $__fish_git_prompt_status_order
9	78	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
7	48	-----> if test "$informative" = true...
7	7	------> test "$informative" = true
4	11	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
13	13	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
0	8	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
8	8	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	48	----> for i in $__fish_git_prompt_status_order...
1	9	-----> if test -n "$$i"...
8	8	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
61	75	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
1	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
8	36	----> if test -n "$b"...
5	5	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	6	----> if test -n "$r"...
5	5	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
8	8	----> set -l format $argv[1]
4	14	----> if test -z "$format"...
4	4	-----> test -z "$format"
6	6	-----> set format " (%s)"
32	32	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
11	753	> fish_title
8	742	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
8	719	--> if set -q argv[1]...
4	4	---> set -q argv[1]
55	64	---> set -l command (status current-command)
9	9	----> status current-command
4	20	---> if test "$command" = fish...
11	11	----> test "$command" = fish
5	5	----> set command
79	623	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
32	535	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
19	432	-----> for path in $argv...
38	49	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
38	65	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	299	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
8	204	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
81	177	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
48	96	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
48	48	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
50	75	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
25	25	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
300	788	> up-or-search
12	109	-> if commandline --search-mode...
97	97	--> commandline --search-mode
5	18	-> if commandline --paging-mode...
13	13	--> commandline --paging-mode
275	304	-> set -l lineno (commandline -L)
29	29	--> commandline -L
27	57	-> switch $lineno...
30	30	--> commandline -f history-search-backward
169	580	> __fish_seen_subcommand_from help
209	249	-> set -l cmd (commandline -poc)
40	40	--> commandline -poc
26	26	-> set -e cmd[1]
44	125	-> for i in $cmd...
7	37	--> if contains -- $i $argv...
30	30	---> contains -- $i $argv
4	22	--> if contains -- $i $argv...
18	18	---> contains -- $i $argv
6	22	--> if contains -- $i $argv...
16	16	---> contains -- $i $argv
11	11	-> return 1
78	453	> __fish_seen_subcommand_from yank
173	214	-> set -l cmd (commandline -poc)
41	41	--> commandline -poc
24	24	-> set -e cmd[1]
43	127	-> for i in $cmd...
6	37	--> if contains -- $i $argv...
31	31	---> contains -- $i $argv
5	24	--> if contains -- $i $argv...
19	19	---> contains -- $i $argv
5	23	--> if contains -- $i $argv...
18	18	---> contains -- $i $argv
10	10	-> return 1
72	413	> __fish_seen_subcommand_from version
162	198	-> set -l cmd (commandline -poc)
36	36	--> commandline -poc
20	20	-> set -e cmd[1]
40	114	-> for i in $cmd...
6	31	--> if contains -- $i $argv...
25	25	---> contains -- $i $argv
5	22	--> if contains -- $i $argv...
17	17	---> contains -- $i $argv
5	21	--> if contains -- $i $argv...
16	16	---> contains -- $i $argv
9	9	-> return 1
70	382	> __fish_seen_subcommand_from verify-project
126	162	-> set -l cmd (commandline -poc)
36	36	--> commandline -poc
19	19	-> set -e cmd[1]
39	121	-> for i in $cmd...
7	31	--> if contains -- $i $argv...
24	24	---> contains -- $i $argv
5	30	--> if contains -- $i $argv...
25	25	---> contains -- $i $argv
4	21	--> if contains -- $i $argv...
17	17	---> contains -- $i $argv
10	10	-> return 1
59	339	> __fish_seen_subcommand_from vendor
129	156	-> set -l cmd (commandline -poc)
27	27	--> commandline -poc
16	16	-> set -e cmd[1]
32	100	-> for i in $cmd...
5	26	--> if contains -- $i $argv...
21	21	---> contains -- $i $argv
5	21	--> if contains -- $i $argv...
16	16	---> contains -- $i $argv
5	21	--> if contains -- $i $argv...
16	16	---> contains -- $i $argv
8	8	-> return 1
45	298	> __fish_seen_subcommand_from update
114	137	-> set -l cmd (commandline -poc)
23	23	--> commandline -poc
15	15	-> set -e cmd[1]
30	93	-> for i in $cmd...
6	23	--> if contains -- $i $argv...
17	17	---> contains -- $i $argv
5	20	--> if contains -- $i $argv...
15	15	---> contains -- $i $argv
5	20	--> if contains -- $i $argv...
15	15	---> contains -- $i $argv
8	8	-> return 1
56	405	> __fish_seen_subcommand_from uninstall
176	197	-> set -l cmd (commandline -poc)
21	21	--> commandline -poc
24	24	-> set -e cmd[1]
41	119	-> for i in $cmd...
7	34	--> if contains -- $i $argv...
27	27	---> contains -- $i $argv
5	22	--> if contains -- $i $argv...
17	17	---> contains -- $i $argv
5	22	--> if contains -- $i $argv...
17	17	---> contains -- $i $argv
9	9	-> return 1
71	413	> __fish_seen_subcommand_from tree
163	193	-> set -l cmd (commandline -poc)
30	30	--> commandline -poc
24	24	-> set -e cmd[1]
40	116	-> for i in $cmd...
7	33	--> if contains -- $i $argv...
26	26	---> contains -- $i $argv
6	22	--> if contains -- $i $argv...
16	16	---> contains -- $i $argv
5	21	--> if contains -- $i $argv...
16	16	---> contains -- $i $argv
9	9	-> return 1
49	328	> __fish_seen_subcommand_from test
145	182	-> set -l cmd (commandline -poc)
37	37	--> commandline -poc
13	13	-> set -e cmd[1]
25	77	-> for i in $cmd...
5	20	--> if contains -- $i $argv...
15	15	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
3	16	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
7	7	-> return 1
47	344	> __fish_seen_subcommand_from search
154	172	-> set -l cmd (commandline -poc)
18	18	--> commandline -poc
20	20	-> set -e cmd[1]
35	97	-> for i in $cmd...
5	27	--> if contains -- $i $argv...
22	22	---> contains -- $i $argv
4	18	--> if contains -- $i $argv...
14	14	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
8	8	-> return 1
52	432	> __fish_seen_subcommand_from rustdoc
234	258	-> set -l cmd (commandline -poc)
24	24	--> commandline -poc
20	20	-> set -e cmd[1]
32	94	-> for i in $cmd...
5	27	--> if contains -- $i $argv...
22	22	---> contains -- $i $argv
4	18	--> if contains -- $i $argv...
14	14	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
8	8	-> return 1
41	268	> __fish_seen_subcommand_from rustc
104	128	-> set -l cmd (commandline -poc)
24	24	--> commandline -poc
13	13	-> set -e cmd[1]
26	79	-> for i in $cmd...
4	20	--> if contains -- $i $argv...
16	16	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
5	17	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
7	7	-> return 1
33	199	> __fish_seen_subcommand_from run
91	109	-> set -l cmd (commandline -poc)
18	18	--> commandline -poc
12	12	-> set -e cmd[1]
15	45	-> for i in $cmd...
9	30	--> if contains -- $i $argv...
14	14	---> contains -- $i $argv
7	7	---> return 0
45	313	> __fish_seen_subcommand_from read-manifest
130	147	-> set -l cmd (commandline -poc)
17	17	--> commandline -poc
19	19	-> set -e cmd[1]
32	94	-> for i in $cmd...
5	27	--> if contains -- $i $argv...
22	22	---> contains -- $i $argv
4	18	--> if contains -- $i $argv...
14	14	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
8	8	-> return 1
40	265	> __fish_seen_subcommand_from publish
103	127	-> set -l cmd (commandline -poc)
24	24	--> commandline -poc
13	13	-> set -e cmd[1]
25	79	-> for i in $cmd...
5	20	--> if contains -- $i $argv...
15	15	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
6	6	-> return 1
47	332	> __fish_seen_subcommand_from pkgid
132	151	-> set -l cmd (commandline -poc)
19	19	--> commandline -poc
20	20	-> set -e cmd[1]
33	106	-> for i in $cmd...
5	27	--> if contains -- $i $argv...
22	22	---> contains -- $i $argv
6	29	--> if contains -- $i $argv...
23	23	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
8	8	-> return 1
99	379	> __fish_seen_subcommand_from package
136	167	-> set -l cmd (commandline -poc)
31	31	--> commandline -poc
16	16	-> set -e cmd[1]
31	89	-> for i in $cmd...
5	24	--> if contains -- $i $argv...
19	19	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
8	8	-> return 1
37	272	> __fish_seen_subcommand_from owner
117	138	-> set -l cmd (commandline -poc)
21	21	--> commandline -poc
13	13	-> set -e cmd[1]
24	77	-> for i in $cmd...
5	20	--> if contains -- $i $argv...
15	15	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
7	7	-> return 1
36	227	> __fish_seen_subcommand_from new
83	101	-> set -l cmd (commandline -poc)
18	18	--> commandline -poc
11	11	-> set -e cmd[1]
23	73	-> for i in $cmd...
4	18	--> if contains -- $i $argv...
14	14	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
6	6	-> return 1
34	221	> __fish_seen_subcommand_from metadata
81	97	-> set -l cmd (commandline -poc)
16	16	--> commandline -poc
11	11	-> set -e cmd[1]
23	73	-> for i in $cmd...
4	18	--> if contains -- $i $argv...
14	14	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
6	6	-> return 1
34	219	> __fish_seen_subcommand_from logout
79	95	-> set -l cmd (commandline -poc)
16	16	--> commandline -poc
10	10	-> set -e cmd[1]
24	74	-> for i in $cmd...
4	18	--> if contains -- $i $argv...
14	14	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
6	6	-> return 1
35	217	> __fish_seen_subcommand_from login
78	94	-> set -l cmd (commandline -poc)
16	16	--> commandline -poc
11	11	-> set -e cmd[1]
21	71	-> for i in $cmd...
5	18	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
6	6	-> return 1
33	218	> __fish_seen_subcommand_from locate-project
78	94	-> set -l cmd (commandline -poc)
16	16	--> commandline -poc
11	11	-> set -e cmd[1]
24	74	-> for i in $cmd...
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
6	6	-> return 1
32	215	> __fish_seen_subcommand_from install
78	93	-> set -l cmd (commandline -poc)
15	15	--> commandline -poc
11	11	-> set -e cmd[1]
24	73	-> for i in $cmd...
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
4	16	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
6	6	-> return 1
51	302	> __fish_seen_subcommand_from init
110	139	-> set -l cmd (commandline -poc)
29	29	--> commandline -poc
15	15	-> set -e cmd[1]
31	89	-> for i in $cmd...
5	24	--> if contains -- $i $argv...
19	19	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
8	8	-> return 1
38	240	> __fish_seen_subcommand_from git-checkout
85	105	-> set -l cmd (commandline -poc)
20	20	--> commandline -poc
12	12	-> set -e cmd[1]
25	78	-> for i in $cmd...
4	19	--> if contains -- $i $argv...
15	15	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
7	7	-> return 1
30	189	> __fish_seen_subcommand_from generate-lockfile
67	82	-> set -l cmd (commandline -poc)
15	15	--> commandline -poc
10	10	-> set -e cmd[1]
19	62	-> for i in $cmd...
3	15	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
5	5	-> return 1
35	208	> __fish_seen_subcommand_from fix
84	97	-> set -l cmd (commandline -poc)
13	13	--> commandline -poc
10	10	-> set -e cmd[1]
20	61	-> for i in $cmd...
4	15	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
4	13	--> if contains -- $i $argv...
9	9	---> contains -- $i $argv
2	13	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
5	5	-> return 1
27	182	> __fish_seen_subcommand_from fetch
66	80	-> set -l cmd (commandline -poc)
14	14	--> commandline -poc
9	9	-> set -e cmd[1]
19	61	-> for i in $cmd...
4	15	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
3	13	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
5	5	-> return 1
28	193	> __fish_seen_subcommand_from doc
78	91	-> set -l cmd (commandline -poc)
13	13	--> commandline -poc
9	9	-> set -e cmd[1]
18	60	-> for i in $cmd...
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
3	13	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
5	15	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
5	5	-> return 1
28	183	> __fish_seen_subcommand_from complete
67	80	-> set -l cmd (commandline -poc)
13	13	--> commandline -poc
9	9	-> set -e cmd[1]
18	61	-> for i in $cmd...
4	15	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
5	5	-> return 1
27	196	> __fish_seen_subcommand_from clean
80	94	-> set -l cmd (commandline -poc)
14	14	--> commandline -poc
9	9	-> set -e cmd[1]
18	60	-> for i in $cmd...
4	15	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
3	13	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
6	6	-> return 1
28	207	> __fish_seen_subcommand_from check
91	104	-> set -l cmd (commandline -poc)
13	13	--> commandline -poc
9	9	-> set -e cmd[1]
19	61	-> for i in $cmd...
3	15	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
2	13	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
5	5	-> return 1
26	180	> __fish_seen_subcommand_from build
66	79	-> set -l cmd (commandline -poc)
13	13	--> commandline -poc
9	9	-> set -e cmd[1]
19	60	-> for i in $cmd...
3	14	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
2	13	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
6	6	-> return 1
27	178	> __fish_seen_subcommand_from bench
64	77	-> set -l cmd (commandline -poc)
13	13	--> commandline -poc
9	9	-> set -e cmd[1]
20	60	-> for i in $cmd...
3	14	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
3	13	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
2	13	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
5	5	-> return 1
152	1973	> __fish_use_subcommand
1611	1638	-> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_use_subcommand.fish
27	27	--> function __fish_use_subcommand -d "Test if a non-switch argument has been given in the current commandline"...
113	135	-> set -l cmd (commandline -poc)
22	22	--> commandline -poc
13	13	-> set -e cmd[1]
20	35	-> for i in $cmd...
7	7	--> switch $i...
8	8	--> return 1
51	263	> __fish_seen_subcommand_from add install
92	113	-> set -l cmd (commandline -poc)
21	21	--> commandline -poc
12	12	-> set -e cmd[1]
25	81	-> for i in $cmd...
5	21	--> if contains -- $i $argv...
16	16	---> contains -- $i $argv
4	17	--> if contains -- $i $argv...
13	13	---> contains -- $i $argv
4	18	--> if contains -- $i $argv...
14	14	---> contains -- $i $argv
6	6	-> return 1
34	197	> __fish_seen_subcommand_from run test build debug check
83	99	-> set -l cmd (commandline -poc)
16	16	--> commandline -poc
11	11	-> set -e cmd[1]
16	53	-> for i in $cmd...
9	37	--> if contains -- $i $argv...
21	21	---> contains -- $i $argv
7	7	---> return 0
32	214	> __fish_seen_subcommand_from t
82	99	-> set -l cmd (commandline -poc)
17	17	--> commandline -poc
18	18	-> set -e cmd[1]
17	60	-> for i in $cmd...
4	15	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
5	5	-> return 1
26	185	> __fish_seen_subcommand_from r
64	77	-> set -l cmd (commandline -poc)
13	13	--> commandline -poc
9	9	-> set -e cmd[1]
21	68	-> for i in $cmd...
4	14	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
4	13	--> if contains -- $i $argv...
9	9	---> contains -- $i $argv
9	20	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
5	5	-> return 1
67	349	> __fish_seen_subcommand_from b
165	189	-> set -l cmd (commandline -poc)
24	24	--> commandline -poc
19	19	-> set -e cmd[1]
24	68	-> for i in $cmd...
4	18	--> if contains -- $i $argv...
14	14	---> contains -- $i $argv
3	13	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
2	13	--> if contains -- $i $argv...
11	11	---> contains -- $i $argv
6	6	-> return 1
69	117	> __fish_disable_bracketed_paste 'cargo run -- --path /tmp/testing-franz'
48	48	-> printf "\e[?2004l"
68	2843	> fish_title cargo\ run\ --\ --path\ /tmp/testing-franz
99	2775	-> if not set -q INSIDE_EMACS...
34	34	--> not set -q INSIDE_EMACS
124	124	--> set -l ssh
89	89	--> set -q SSH_TTY
33	2429	--> if set -q argv[1]...
22	22	---> set -q argv[1]
816	2374	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
47	47	----> string sub -l 20 -- $argv[1]
98	1511	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
70	70	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
49	1184	-----> for path in $argv...
147	180	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
141	206	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
65	65	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
39	749	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
27	27	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
25	396	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
15	15	--------> test $fish_prompt_pwd_full_dirs -gt 0
156	312	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
120	156	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
28	28	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
205	274	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
69	69	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
32265099	32265099	> cargo run -- --path /tmp/testing-franz
85	248	> __fish_enable_bracketed_paste
163	163	-> printf "\e[?2004h"
42	390	> fish_mode_prompt
159	348	-> fish_default_mode_prompt
54	189	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
51	51	---> test "$fish_key_bindings" = fish_vi_key_bindings
84	84	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
194	238126	> fish_prompt
63	63	-> set -l last_status $status
364	536	-> set -l normal (set_color normal)
172	172	--> set_color normal
187	225	-> set -l status_color (set_color brgreen)
38	38	--> set_color brgreen
175	208	-> set -l cwd_color (set_color $fish_color_cwd)
33	33	--> set_color $fish_color_cwd
276	344	-> set -l vcs_color (set_color brpurple)
68	68	--> set_color brpurple
18	18	-> set -l prompt_status ""
10	10	-> set -q fish_prompt_pwd_dir_length
12	12	-> set -lx fish_prompt_pwd_dir_length 0
12	12	-> set -l suffix '❯'
7	593	-> if functions -q fish_is_root_user...
180	180	--> functions -q fish_is_root_user
43	406	--> fish_is_root_user
8	115	---> if test "$EUID" = 0 2>/dev/null...
107	107	----> test "$EUID" = 0 2>/dev/null
98	232	---> if contains -- $USER root toor Administrator...
134	134	----> contains -- $USER root toor Administrator
16	16	---> return 1
3	31	-> if test $last_status -ne 0...
28	28	--> test $last_status -ne 0
460	235861	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
182	1593	--> prompt_login
7	29	---> if not set -q __fish_machine...
22	22	----> not set -q __fish_machine
2	13	---> if set -q __fish_machine[1]...
11	11	----> set -q __fish_machine[1]
25	25	---> set -l color_host $fish_color_host
2	11	---> if set -q SSH_TTY...
9	9	----> set -q SSH_TTY
928	1333	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
47	47	----> set_color $fish_color_user
59	59	----> set_color normal
32	32	----> set_color $color_host
145	241	----> prompt_hostname
96	96	-----> string replace -r -- "\..*" "" $hostname
26	26	----> set_color normal
127	669	--> prompt_pwd
23	23	---> set -l options h/help d/dir-length= D/full-length-dirs=
34	34	---> argparse -n prompt_pwd $options -- $argv
3	13	---> if set -q _flag_help...
10	10	----> set -q _flag_help
7	7	---> set -q argv[1]
14	14	---> set argv $PWD
7	7	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
8	8	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
42	401	---> for path in $argv...
102	132	----> set -l realhome (string escape --style=regex -- ~)
30	30	-----> string escape --style=regex -- ~
114	178	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
64	64	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	49	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
22	22	-----> test "$fish_prompt_pwd_dir_length" -eq 0
18	18	-----> echo $tmp
121	233139	--> fish_vcs_prompt
158	233018	---> fish_git_prompt $argv
18	60203	----> if not command -sq git...
60185	60185	-----> not command -sq git
2	63	----> if functions -q __fish_git_prompt_ready...
61	61	-----> functions -q __fish_git_prompt_ready
129	57440	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57311	57311	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
60	56974	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
47	56914	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
3	3	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
3	3	------> set -l total
32	88	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	44	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
8	8	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
8	56681	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56669	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
91	56667	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56576	56576	---------> command git symbolic-ref HEAD 2>/dev/null
1	14	------> if test true = $inside_gitdir...
13	13	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
51730	57599	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5869	5869	-----> read -lz key value
6	39	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
16	16	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	71	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
8	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	14	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
1	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
2	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
5	5	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
20	50	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
60	72	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
2	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	35	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
4	17	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
30	30	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
19	19	-> echo -n -s $status_color $suffix ' ' $normal
13	721	> fish_title
8	708	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
6	681	--> if set -q argv[1]...
3	3	---> set -q argv[1]
42	48	---> set -l command (status current-command)
6	6	----> status current-command
3	15	---> if test "$command" = fish...
7	7	----> test "$command" = fish
5	5	----> set command
69	609	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
25	532	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
29	29	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
8	8	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
23	419	-----> for path in $argv...
49	62	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
53	91	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
38	38	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	243	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
12	12	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
5	149	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
42	126	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	84	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
42	42	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
46	66	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
54	102	> __fish_disable_bracketed_paste ls
48	48	-> printf "\e[?2004l"
33	2182	> fish_title ls
25	2149	-> if not set -q INSIDE_EMACS...
22	22	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
11	11	--> set -q SSH_TTY
20	2074	--> if set -q argv[1]...
11	11	---> set -q argv[1]
382	2043	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
31	31	----> string sub -l 20 -- $argv[1]
110	1630	----> prompt_pwd -d 1 -D 1
37	37	-----> set -l options h/help d/dir-length= D/full-length-dirs=
71	71	-----> argparse -n prompt_pwd $options -- $argv
4	17	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
11	11	-----> set -q argv[1]
29	29	-----> set argv $PWD
11	11	-----> set -ql _flag_d
32	32	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
23	23	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
68	1248	-----> for path in $argv...
181	215	------> set -l realhome (string escape --style=regex -- ~)
34	34	-------> string escape --style=regex -- ~
206	296	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
90	90	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
41	669	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-------> set -l full
18	357	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
125	287	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
124	162	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
38	38	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
172	228	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
56	56	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
88	80091	> ls
80003	80003	-> eza -lha $argv
35	65	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
10	64	> fish_mode_prompt
14	54	-> fish_default_mode_prompt
11	40	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
21	21	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
24	223618	> fish_prompt
13	13	-> set -l last_status $status
40	52	-> set -l normal (set_color normal)
12	12	--> set_color normal
35	44	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
35	45	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
34	41	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
4	91	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
15	76	--> fish_is_root_user
5	46	---> if test "$EUID" = 0 2>/dev/null...
41	41	----> test "$EUID" = 0 2>/dev/null
1	12	---> if contains -- $USER root toor Administrator...
11	11	----> contains -- $USER root toor Administrator
3	3	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
128	223269	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
20	358	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
219	315	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
17	17	----> set_color normal
11	11	----> set_color $color_host
18	49	----> prompt_hostname
31	31	-----> string replace -r -- "\..*" "" $hostname
8	8	----> set_color normal
26	241	--> prompt_pwd
9	9	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
6	11	---> if set -q _flag_help...
5	5	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
17	148	---> for path in $argv...
40	52	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
39	60	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	19	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
11	222542	--> fish_vcs_prompt
93	222531	---> fish_git_prompt $argv
11	51789	----> if not command -sq git...
51778	51778	-----> not command -sq git
3	30	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
157	56891	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56734	56734	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
5	5	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
61	56704	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
40	56643	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
23	72	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
6	38	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
6	6	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
8	56426	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56414	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
88	56412	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56324	56324	---------> command git symbolic-ref HEAD 2>/dev/null
3	16	------> if test true = $inside_gitdir...
13	13	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
10	10	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
5	5	----> set -l dirty
4	4	----> set -l untracked
50529	56414	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5885	5885	-----> read -lz key value
7	39	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
16	16	----> contains dirtystate $__fish_git_prompt_status_order
3	13	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
6	6	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
11	11	----> contains untrackedfiles $__fish_git_prompt_status_order
9	90	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
9	60	-----> if test "$informative" = true...
7	7	------> test "$informative" = true
4	15	------> begin...
11	11	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	20	------> if not test "$dirty" = true...
6	6	-------> not test "$dirty" = true
7	7	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
2	9	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
7	7	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	13	-----> if set -q __fish_git_prompt_showupstream...
5	5	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
12	12	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
6	6	----> set -l f ""
20	55	----> for i in $__fish_git_prompt_status_order...
2	10	-----> if test -n "$$i"...
8	8	------> test -n "$$i"
3	8	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
59	73	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	33	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
2	6	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
21	818	> fish_title
14	797	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
32	769	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	43	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
143	678	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
29	527	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
17	425	-----> for path in $argv...
64	76	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
68	103	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
35	35	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	229	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
12	12	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
9	133	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
49	107	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	58	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
18	18	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
48	68	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
39	659	> __fish_git_using_command upload-pack
71	547	-> set -l cmd (__fish_git_needs_command)
34	476	--> __fish_git_needs_command
78	126	---> set -l cmdline "$(commandline -c)"
48	48	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
12	12	---> set -g __fish_git_cmdline $cmdline
45	55	---> set -l cmd (commandline -opc)
10	10	----> commandline -opc
6	6	---> set -e cmd[1]
131	171	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
13	40	----> __fish_git_global_optspecs
27	27	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
4	4	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
8	32	---> if set -q argv[1]...
3	3	----> set -q argv[1]
9	9	----> set -g __fish_git_cmd $argv[1]
8	8	----> echo $argv[1]
4	4	----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
40	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	247	> __fish_git_using_command upload-archive
55	164	-> set -l cmd (__fish_git_needs_command)
10	109	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	233	> __fish_git_using_command shell
53	154	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	230	> __fish_git_using_command receive-pack
52	153	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	227	> __fish_git_using_command flow
51	151	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	227	> __fish_git_using_command cvsserver
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
9	99	> __fish_git_needs_command
51	57	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
7	33	-> if set -q __fish_git_cmdline...
3	3	--> set -q __fish_git_cmdline
7	7	--> test "$cmdline" = "$__fish_git_cmdline"
5	16	--> if set -q __fish_git_cmd[1]...
4	4	---> set -q __fish_git_cmd[1]
5	5	---> echo -- $__fish_git_cmd
2	2	---> return 1
56	131	> __fish_seen_subcommand_from branch for-each-ref tag
40	48	-> set -l cmd (commandline -poc)
8	8	--> commandline -poc
5	5	-> set -e cmd[1]
9	19	-> for i in $cmd...
2	10	--> if contains -- $i $argv...
8	8	---> contains -- $i $argv
3	3	-> return 1
17	231	> __fish_git_using_command for-each-ref
52	154	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	226	> __fish_git_using_command config
51	149	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	235	> __fish_git_using_command help
52	154	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
26	294	> __fish_git_using_command blame
66	198	-> set -l cmd (__fish_git_needs_command)
12	132	--> __fish_git_needs_command
62	74	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
6	46	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
14	14	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	238	> __fish_git_using_command clean
52	157	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	238	> __fish_git_using_command submodule
57	160	-> set -l cmd (__fish_git_needs_command)
11	103	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	224	> __fish_git_using_command format-patch
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command format-patch log
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	222	> __fish_git_using_command stash
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	224	> __fish_git_using_command worktree
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	223	> __fish_git_using_command update-index
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	221	> __fish_git_using_command tag
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	253	> __fish_git_using_command stripspace
54	168	-> set -l cmd (__fish_git_needs_command)
10	114	--> __fish_git_needs_command
61	66	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
41	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
20	240	> __fish_git_using_command status
52	159	-> set -l cmd (__fish_git_needs_command)
8	107	--> __fish_git_needs_command
54	62	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
5	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	238	> __fish_git_using_command rm
53	155	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
9	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command revert
51	148	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	227	> __fish_git_using_command rev-parse
50	150	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	224	> __fish_git_using_command restore switch
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	228	> __fish_git_using_command switch
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	224	> __fish_git_using_command restore
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
15	224	> __fish_git_using_command reset
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	222	> __fish_git_using_command reflog
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	225	> __fish_git_using_command rebase
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	224	> __fish_git_using_command push
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	248	> __fish_git_using_command range-diff
53	158	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	42	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
15	26	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
47	53	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
15	222	> __fish_git_using_command pull
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command prune
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	224	> __fish_git_using_command notes
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	225	> __fish_git_using_command mv
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	233	> __fish_git_using_command mergetool
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	231	> __fish_git_using_command merge-base
52	150	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	230	> __fish_git_using_command merge
53	153	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	232	> __fish_git_using_command maintenance
51	150	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
42	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	231	> __fish_git_using_command mailsplit
51	153	-> set -l cmd (__fish_git_needs_command)
10	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	226	> __fish_git_using_command mailsplit am
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	228	> __fish_git_using_command mailinfo
51	148	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	228	> __fish_git_using_command mailinfo am
52	151	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	223	> __fish_git_using_command ls-files
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	229	> __fish_git_using_command log
50	154	-> set -l cmd (__fish_git_needs_command)
11	104	--> __fish_git_needs_command
54	59	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	221	> __fish_git_using_command init
50	145	-> set -l cmd (__fish_git_needs_command)
7	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	220	> __fish_git_using_command grep
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	220	> __fish_git_using_command gc
49	145	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	222	> __fish_git_using_command difftool
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	223	> __fish_git_using_command diff
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
22	231	> __fish_git_using_command describe
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	223	> __fish_git_using_command daemon
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	224	> __fish_git_using_command count-objects
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
24	312	> __fish_git_using_command commit
58	207	-> set -l cmd (__fish_git_needs_command)
14	149	--> __fish_git_needs_command
81	86	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	49	---> if set -q __fish_git_cmdline...
7	7	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
5	22	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
48	57	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	248	> __fish_git_using_command clone
52	163	-> set -l cmd (__fish_git_needs_command)
10	111	--> __fish_git_needs_command
57	65	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
5	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	238	> __fish_git_using_command cherry-pick
51	159	-> set -l cmd (__fish_git_needs_command)
14	108	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	226	> __fish_git_using_command cherry
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	229	> __fish_git_using_command bundle
50	150	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
2	2	-> return 1
17	233	> __fish_git_using_command branch
52	153	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	232	> __fish_git_using_command bisect
52	152	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
15	229	> __fish_git_using_command archive
50	152	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
16	226	> __fish_git_using_command apply
50	149	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	233	> __fish_git_using_command apply am
51	155	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
9	21	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
12	176	> __fish_git_using_command checkout
53	151	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
2	2	-> return 0
71	178528	> __fish_git_files modified deleted modified-staged-deleted
71	57820	-> set -l root (__fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null)
62	57749	--> __fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null
11	11	---> set -l saved_args $argv
5	5	---> set -l global_args
37	45	---> set -l cmd (commandline -opc)
8	8	----> commandline -opc
6	6	---> set -e cmd[1]
9	360	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
105	143	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	38	-----> __fish_git_global_optspecs
28	28	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
42	197	----> set -l num_global_args (math (count $cmd) - (count $argv))
89	155	-----> math (count $cmd) - (count $argv)
51	51	------> count $cmd
15	15	------> count $argv
2	11	----> if test $num_global_args -ne 0...
9	9	-----> test $num_global_args -ne 0
65	57260	---> eval command git $global_args \$saved_args 2>/dev/null
57195	57195	----> command git $saved_args
17	17	-> test "$root[2]" = true
7	7	-> set -e root[2]
13	13	-> contains -- all-staged $argv
6	6	-> contains -- unmerged $argv
5	5	-> contains -- added $argv
4	4	-> set -ql all_staged
6	6	-> contains -- modified $argv
5	5	-> set -l modified
6	6	-> set -l modified_desc "Modified file"
6	6	-> contains -- untracked $argv
5	5	-> contains -- modified-staged $argv
3	3	-> set -ql all_staged
5	5	-> contains -- modified-staged-deleted $argv
5	5	-> set -l modified_staged_deleted
7	7	-> set -l modified_staged_deleted_desc "Staged modified and deleted file"
5	5	-> contains -- deleted $argv
4	4	-> set -l deleted
6	6	-> set -l deleted_desc "Deleted file"
5	5	-> contains -- deleted-staged $argv
3	3	-> set -ql all_staged
5	5	-> contains -- ignored $argv
6	6	-> contains -- renamed $argv
5	5	-> contains -- copied $argv
5	5	-> set -l q '\\?'
2	7	-> if status test-feature qmark-noglob...
5	5	--> status test-feature qmark-noglob
4	4	-> set -l use_next
5	5	-> set -l status_opt --ignore-submodules=all
3	3	-> set -q ignored
3	3	-> set -q untracked
5	5	-> set -a status_opt -uno
6	6	-> set -l git_opt -c status.relativePaths -c core.quotePath=
81	57490	-> set -l ver (__fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2')
353	57409	--> __fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2'
8	8	---> set -l saved_args $argv
4	4	---> set -l global_args
39	51	---> set -l cmd (commandline -opc)
12	12	----> commandline -opc
6	6	---> set -e cmd[1]
9	294	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
106	149	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
13	43	-----> __fish_git_global_optspecs
30	30	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
42	127	----> set -l num_global_args (math (count $cmd) - (count $argv))
66	85	-----> math (count $cmd) - (count $argv)
11	11	------> count $cmd
8	8	------> count $argv
1	9	----> if test $num_global_args -ne 0...
8	8	-----> test $num_global_args -ne 0
60	56693	---> eval command git $global_args \$saved_args 2>/dev/null
56633	56633	----> command git $saved_args
67	62970	-> if test "$ver[1]" -gt 2 2>/dev/null...
53	53	--> test "$ver[1]" -gt 2 2>/dev/null
27	27	--> test "$ver[1]" -eq 2 -a "$ver[2]" -ge 11 2>/dev/null
162	62823	--> __fish_git $git_opt status --porcelain=2 $status_opt \
            | while read -la -d ' ' line
            set -l file
            set -l desc
            # The basic status format is "XY", where X is "our" state (meaning the staging area),
            # and "Y" is "their" state.
            # A "." means it's unmodified.
            switch "$line[1..2]"
                case 'u *'
                    # Unmerged
                    # "Unmerged entries have the following format; the first character is a "u" to distinguish from ordinary changed entries."
                    # "u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>"
                    # This is first to distinguish it from normal modifications et al.
                    set -ql unmerged
                    and set file "$line[11..-1]"
                    and set desc $unmerged_desc
                case '2 .R*' '2 R.*'
                    # Renamed/Copied
                    # From the docs: "Renamed or copied entries have the following format:"
                    # "2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>"
                    # Since <sep> is \t, we can't really parse it unambiguously.
                    # The "-z" format would be great here!
                    set -ql renamed
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    and set desc $renamed_desc
                case '2 RM*' '2 RT*'
                    # Staged as renamed, with unstaged modifications (issue #6031)
                    set -ql renamed
                    or set -ql modified
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql modified
                    and set --append desc $modified_desc
                case '2 RD*'
                    # Staged as renamed, but deleted in the worktree
                    set -ql renamed
                    or set -ql deleted
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql deleted
                    and set --append desc $deleted_desc
                case '2 .C*' '2 C.*'
                    set -ql copied
                    and set file (string replace -r '\t[^\t].*' '' -- "$line[10..-1]")
                    and set desc $copied_desc
                case '1 A.*'
                    # Additions are only shown here if they are staged.
                    # Otherwise it's an untracked file.
                    set -ql added
                    and set file "$line[9..-1]"
                    and set desc $added_desc
                case '1 AD*'
                    # Added files that were since deleted
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql deleted
                        set file "$line[9..-1]"
                        set desc $deleted_desc
                    end
                case "1 AM*" "1 AT*"
                    # Added files with additional modifications
                    # ("T" is type-changed. As of git 2.33 this appears to be undocumented.
                    # it happens when e.g. a file is replaced with a symlink.
                    # For our purposes it's the same as modified)
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    end
                case '1 .A*'
                    # Files added with git add --intent-to-add.
                    set -ql untracked
                    and set file "$line[9..-1]"
                    and set desc $untracked_desc
                case '1 .M*' '1 .T*'
                    # Modified
                    # From the docs: "Ordinary changed entries have the following format:"
                    # "1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>"
                    # Since <path> can contain spaces, print from element 9 onwards
                    set -ql modified
                    and set file "$line[9..-1]"
                    and set desc $modified_desc
                case '1 MD*' '1 TD*'
                    set -ql modified_staged_deleted
                    and set file "$line[9..-1]"
                    and set desc $modified_staged_deleted_desc
                case '1 M.*' '1 T.*'
                    # If the character is first ("M."), then that means it's "our" change,
                    # which means it is staged.
                    # This is useless for many commands - e.g. `checkout` won't do anything with this.
                    # So it needs to be requested explicitly.
                    set -ql modified_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_modified_desc
                case '1 MM*' '1 MT*' '1 TM*' '1 TT*'
                    # Staged-modified with unstaged modifications
                    # These need to be offered for both kinds of modified.
                    if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    else if set -ql modified_staged
                        set file "$line[9..-1]"
                        set desc $staged_modified_desc
                    end
                case '1 .D*'
                    set -ql deleted
                    and set file "$line[9..-1]"
                    and set desc $deleted_desc
                case '1 D.*'
                    # TODO: The docs are unclear on this.
                    # There is both X unmodified and Y either M or D ("not updated")
                    # and Y is D and X is unmodified or [MARC] ("deleted in work tree").
                    # For our purposes, we assume this is a staged deletion.
                    set -ql deleted_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_deleted_desc
                case "$q"' *'
                    # Untracked
                    # "? <path>" - print from element 2 on.
                    set -ql untracked
                    and set file "$line[2..-1]"
                    and set desc $untracked_desc
                case '! *'
                    # Ignored
                    # "! <path>" - print from element 2 on.
                    set -ql ignored
                    and set file "$line[2..-1]"
                    and set desc $ignored_desc
            end
            # Only try printing if the file was selected.
            if set -q file[1]
                for d in $desc
                    # Without "-z", git sometimes _quotes_ filenames.
                    # It adds quotes around it _and_ escapes the character.
                    # e.g. `"a\\b"`.
                    # We just remove the quotes and hope it works out.
                    # If this contains newlines or tabs,
                    # there is nothing we can do, but that's a general issue with scripted completions.
                    set file (string trim -c \" -- $file)
                    # The relative filename.
                    if string match -q './*' -- (commandline -ct)
                        printf './%s\t%s\n' $file $d
                    else
                        printf '%s\t%s\n' "$file" $d
                    end
                    # Now from repo root.
                    # Only do this if the filename isn't a simple child,
                    # or the current token starts with ":"
                    if string match -q '../*' -- $file
                        or string match -q ':*' -- (commandline -ct)
                        set -l fromroot (builtin realpath -- $file 2>/dev/null)
                        # `:` starts pathspec "magic", and the second `:` terminates it.
                        # `/` is the magic letter for "from repo root".
                        # If we didn't terminate it we'd have to escape any special chars
                        # (non-alphanumeric, glob or regex special characters, in whatever dialect git uses)
                        and set fromroot (string replace -- "$root/" ":/:" "$fromroot")
                        and printf '%s\t%s\n' "$fromroot" $d
                    end
                end
            end
        end
19	19	---> set -l saved_args $argv
5	5	---> set -l global_args
47	60	---> set -l cmd (commandline -opc)
13	13	----> commandline -opc
6	6	---> set -e cmd[1]
7	309	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
103	137	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	34	-----> __fish_git_global_optspecs
24	24	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
43	155	----> set -l num_global_args (math (count $cmd) - (count $argv))
84	112	-----> math (count $cmd) - (count $argv)
14	14	------> count $cmd
14	14	------> count $argv
2	10	----> if test $num_global_args -ne 0...
8	8	-----> test $num_global_args -ne 0
67	62235	---> eval command git $global_args \$saved_args 2>/dev/null
62168	62168	----> command git $saved_args
27	27	---> read -la -d ' ' line
46	61	> not contains -- -- (commandline -opc)
15	15	-> commandline -opc
18	117393	> __fish_git_branches
60	58937	-> __fish_git for-each-ref --format='%(refname:strip=2)%09Local Branch' --sort=-committerdate refs/heads/ 2>/dev/null
18	18	--> set -l saved_args $argv
7	7	--> set -l global_args
46	54	--> set -l cmd (commandline -opc)
8	8	---> commandline -opc
7	7	--> set -e cmd[1]
10	291	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
103	143	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	40	----> __fish_git_global_optspecs
30	30	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
41	127	---> set -l num_global_args (math (count $cmd) - (count $argv))
66	86	----> math (count $cmd) - (count $argv)
13	13	-----> count $cmd
7	7	-----> count $argv
1	11	---> if test $num_global_args -ne 0...
10	10	----> test $num_global_args -ne 0
59	58500	--> eval command git $global_args \$saved_args 2>/dev/null
58441	58441	---> command git $saved_args
71	58438	-> __fish_git for-each-ref --format='%(refname:strip=2)%09Remote Branch' refs/remotes/ 2>/dev/null
23	23	--> set -l saved_args $argv
6	6	--> set -l global_args
63	76	--> set -l cmd (commandline -opc)
13	13	---> commandline -opc
7	7	--> set -e cmd[1]
10	350	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
108	150	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
12	42	----> __fish_git_global_optspecs
30	30	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
48	178	---> set -l num_global_args (math (count $cmd) - (count $argv))
98	130	----> math (count $cmd) - (count $argv)
11	11	-----> count $cmd
21	21	-----> count $argv
2	12	---> if test $num_global_args -ne 0...
10	10	----> test $num_global_args -ne 0
62	57905	--> eval command git $global_args \$saved_args 2>/dev/null
57843	57843	---> command git $saved_args
28	107899	> __fish_git_unique_remote_branches
50675	107871	-> __fish_git for-each-ref --format="%(refname:strip=3)" \
        --sort="refname:strip=3" \
        "refs/remotes/*/$match*" "refs/remotes/*/*/**" 2>/dev/null | uniq -u
38	38	--> set -l saved_args $argv
6	6	--> set -l global_args
62	78	--> set -l cmd (commandline -opc)
16	16	---> commandline -opc
7	7	--> set -e cmd[1]
9	327	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
104	138	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	34	----> __fish_git_global_optspecs
23	23	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
44	168	---> set -l num_global_args (math (count $cmd) - (count $argv))
94	124	----> math (count $cmd) - (count $argv)
13	13	-----> count $cmd
17	17	-----> count $argv
1	12	---> if test $num_global_args -ne 0...
11	11	----> test $num_global_args -ne 0
99	56740	--> eval command git $global_args \$saved_args 2>/dev/null
56641	56641	---> command git $saved_args
19	57507	> __fish_git_heads
66	57394	-> set -l gitdir (__fish_git rev-parse --git-dir 2>/dev/null)
54	57328	--> __fish_git rev-parse --git-dir 2>/dev/null
14	14	---> set -l saved_args $argv
6	6	---> set -l global_args
41	55	---> set -l cmd (commandline -opc)
14	14	----> commandline -opc
7	7	---> set -e cmd[1]
9	401	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
113	146	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	33	-----> __fish_git_global_optspecs
23	23	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
45	235	----> set -l num_global_args (math (count $cmd) - (count $argv))
155	190	-----> math (count $cmd) - (count $argv)
13	13	------> count $cmd
22	22	------> count $argv
2	11	----> if test $num_global_args -ne 0...
9	9	-----> test $num_global_args -ne 0
63	56791	---> eval command git $global_args \$saved_args 2>/dev/null
56728	56728	----> command git $saved_args
16	94	-> for head in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD...
3	33	--> if test -f $gitdir/$head...
19	19	---> test -f $gitdir/$head
11	11	---> echo $head
2	19	--> if test -f $gitdir/$head...
11	11	---> test -f $gitdir/$head
6	6	---> echo $head
2	16	--> if test -f $gitdir/$head...
14	14	---> test -f $gitdir/$head
1	10	--> if test -f $gitdir/$head...
9	9	---> test -f $gitdir/$head
12	59770	> __fish_git_tags
48	59758	-> __fish_git tag --sort=-creatordate 2>/dev/null
12	12	--> set -l saved_args $argv
5	5	--> set -l global_args
41	52	--> set -l cmd (commandline -opc)
11	11	---> commandline -opc
6	6	--> set -e cmd[1]
7	305	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
98	137	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
14	39	----> __fish_git_global_optspecs
25	25	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
41	152	---> set -l num_global_args (math (count $cmd) - (count $argv))
93	111	----> math (count $cmd) - (count $argv)
11	11	-----> count $cmd
7	7	-----> count $argv
1	9	---> if test $num_global_args -ne 0...
8	8	----> test $num_global_args -ne 0
57	59330	--> eval command git $global_args \$saved_args 2>/dev/null
59273	59273	---> command git $saved_args
21	59098	> __fish_git_recent_commits --all
58	59077	-> __fish_git log --no-show-signature --pretty=tformat:"%h"\t"%<(64,trunc)%s" --max-count=50 $argv 2>/dev/null
18	18	--> set -l saved_args $argv
5	5	--> set -l global_args
41	55	--> set -l cmd (commandline -opc)
14	14	---> commandline -opc
7	7	--> set -e cmd[1]
12	326	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
123	163	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	40	----> __fish_git_global_optspecs
29	29	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
46	141	---> set -l num_global_args (math (count $cmd) - (count $argv))
74	95	----> math (count $cmd) - (count $argv)
13	13	-----> count $cmd
8	8	-----> count $argv
1	10	---> if test $num_global_args -ne 0...
9	9	----> test $num_global_args -ne 0
56	58608	--> eval command git $global_args \$saved_args 2>/dev/null
58552	58552	---> command git $saved_args
57	72	> contains -- -- (commandline -opc)
15	15	-> commandline -opc
24	295	> __fish_git_using_command am
66	197	-> set -l cmd (__fish_git_needs_command)
10	131	--> __fish_git_needs_command
62	74	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
8	47	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
7	22	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
41	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	243	> __fish_git_using_command add
55	161	-> set -l cmd (__fish_git_needs_command)
10	106	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	234	> __fish_git_using_command show-branch
52	155	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	227	> __fish_git_using_command show
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
8	256	> __fish_git_needs_rev_files
34	248	-> __fish_git_using_command show
51	151	--> set -l cmd (__fish_git_needs_command)
9	100	---> __fish_git_needs_command
51	57	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
5	34	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
8	8	-----> test "$cmdline" = "$__fish_git_cmdline"
5	17	-----> if set -q __fish_git_cmd[1]...
4	4	------> set -q __fish_git_cmd[1]
5	5	------> echo -- $__fish_git_cmd
3	3	------> return 1
5	5	--> test -z "$cmd"
6	6	--> contains -- $cmd $argv
37	45	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	---> string escape --style=var -- $cmd
5	5	--> set -q $varname
2	2	--> return 1
17	229	> __fish_git_using_command remote
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	227	> __fish_git_using_command filter-branch
52	152	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	233	> __fish_git_using_command fetch
58	157	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
9	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command fetch pull
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	232	> __fish_git_using_command diff log show range-diff
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	224	> __fish_git_using_command diff show range-diff
49	147	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command diff show range-diff apply
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	225	> __fish_git_using_command log show diff-tree rev-list
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
32	520	> __fish_git_using_command upload-pack
67	479	-> set -l cmd (__fish_git_needs_command)
37	412	--> __fish_git_needs_command
77	92	---> set -l cmdline "$(commandline -c)"
15	15	----> commandline -c
5	22	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
8	8	---> set -g __fish_git_cmdline $cmdline
40	47	---> set -l cmd (commandline -opc)
7	7	----> commandline -opc
6	6	---> set -e cmd[1]
127	171	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
14	44	----> __fish_git_global_optspecs
30	30	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
2	5	---> if set -q argv[1]...
3	3	----> set -q argv[1]
6	6	---> set -g __fish_git_cmd
3	3	---> return 0
7	7	-> test -z "$cmd"
2	2	-> return 1
19	206	> __fish_git_using_command upload-archive
62	178	-> set -l cmd (__fish_git_needs_command)
11	116	--> __fish_git_needs_command
62	73	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
8	32	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
1	6	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
11	165	> __fish_git_using_command shell
53	147	-> set -l cmd (__fish_git_needs_command)
8	94	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
10	159	> __fish_git_using_command receive-pack
50	141	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	157	> __fish_git_using_command flow
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	166	> __fish_git_using_command cvsserver
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
60	66	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
8	94	> __fish_git_needs_command
56	61	-> set -l cmdline "$(commandline -c)"
5	5	--> commandline -c
7	25	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
6	6	--> test "$cmdline" = "$__fish_git_cmdline"
2	5	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
3	3	--> return 0
13	53551	> __fish_git_custom_commands
147	53538	-> for name in (string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*)...
53331	53331	--> string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*
9	9	--> switch $name...
8	24	--> switch $name...
16	16	---> echo $name
4	4	--> switch $name...
3	3	--> switch $name...
4	4	--> switch $name...
4	4	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
29	114	> __fish_seen_subcommand_from branch for-each-ref tag
52	62	-> set -l cmd (commandline -poc)
10	10	--> commandline -poc
11	11	-> set -e cmd[1]
8	8	-> for i in $cmd...
4	4	-> return 1
16	288	> __fish_git_using_command for-each-ref
65	261	-> set -l cmd (__fish_git_needs_command)
22	196	--> __fish_git_needs_command
110	122	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
12	52	---> if set -q __fish_git_cmdline...
12	12	----> set -q __fish_git_cmdline
17	17	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
7	7	-> test -z "$cmd"
4	4	-> return 1
16	183	> __fish_git_using_command config
57	160	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
56	66	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	177	> __fish_git_using_command help
51	158	-> set -l cmd (__fish_git_needs_command)
10	107	--> __fish_git_needs_command
51	72	---> set -l cmdline "$(commandline -c)"
21	21	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
13	159	> __fish_git_using_command blame
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	159	> __fish_git_using_command clean
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
53	58	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	61674	> __fish_git_aliases
159	61663	-> __fish_git config -z --get-regexp '^alias\.' 2>/dev/null | while read -lz key value
        begin
            set -l name (string replace -r '^.*\.' '' -- $key)
            set -l val (string shorten --no-newline -m 36 -- $value)
            printf "%s\t%s\n" $name "alias: $val"
        end
    end
13	13	--> set -l saved_args $argv
5	5	--> set -l global_args
36	43	--> set -l cmd (commandline -opc)
7	7	---> commandline -opc
5	5	--> set -e cmd[1]
8	256	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
92	122	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	30	----> __fish_git_global_optspecs
21	21	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
37	118	---> set -l num_global_args (math (count $cmd) - (count $argv))
64	81	----> math (count $cmd) - (count $argv)
10	10	-----> count $cmd
7	7	-----> count $argv
1	8	---> if test $num_global_args -ne 0...
7	7	----> test $num_global_args -ne 0
55	61161	--> eval command git $global_args \$saved_args 2>/dev/null
61106	61106	---> command git $saved_args
21	21	--> read -lz key value
20	366	> __fish_git_using_command submodule
74	333	-> set -l cmd (__fish_git_needs_command)
32	259	--> __fish_git_needs_command
115	128	---> set -l cmdline "$(commandline -c)"
13	13	----> commandline -c
25	99	---> if set -q __fish_git_cmdline...
17	17	----> set -q __fish_git_cmdline
35	35	----> test "$cmdline" = "$__fish_git_cmdline"
2	17	----> if set -q __fish_git_cmd[1]...
15	15	-----> set -q __fish_git_cmd[1]
5	5	----> return 0
9	9	-> test -z "$cmd"
4	4	-> return 1
17	192	> __fish_git_using_command format-patch
56	168	-> set -l cmd (__fish_git_needs_command)
11	112	--> __fish_git_needs_command
58	68	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
9	33	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
19	253	> __fish_git_using_command format-patch log
87	217	-> set -l cmd (__fish_git_needs_command)
17	130	--> __fish_git_needs_command
71	81	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
10	32	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	6	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
10	10	-> test -z "$cmd"
7	7	-> return 1
16	230	> __fish_git_using_command stash
60	206	-> set -l cmd (__fish_git_needs_command)
12	146	--> __fish_git_needs_command
87	97	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
9	37	---> if set -q __fish_git_cmdline...
9	9	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
12	171	> __fish_git_using_command worktree
51	151	-> set -l cmd (__fish_git_needs_command)
10	100	--> __fish_git_needs_command
55	63	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
28	231	> __fish_git_using_command update-index
70	169	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
56	64	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
22	22	-> test -z "$cmd"
12	12	-> return 1
17	192	> __fish_git_using_command tag
57	167	-> set -l cmd (__fish_git_needs_command)
9	110	--> __fish_git_needs_command
60	70	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
9	31	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	205	> __fish_git_using_command stripspace
80	175	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
13	13	-> test -z "$cmd"
3	3	-> return 1
15	288	> __fish_git_using_command status
79	264	-> set -l cmd (__fish_git_needs_command)
18	185	--> __fish_git_needs_command
123	136	---> set -l cmdline "$(commandline -c)"
13	13	----> commandline -c
8	31	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
16	216	> __fish_git_using_command rm
84	189	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
53	61	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
14	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
8	8	-> test -z "$cmd"
3	3	-> return 1
15	299	> __fish_git_using_command revert
74	275	-> set -l cmd (__fish_git_needs_command)
16	201	--> __fish_git_needs_command
115	127	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
24	58	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	11	----> if set -q __fish_git_cmd[1]...
9	9	-----> set -q __fish_git_cmd[1]
8	8	----> return 0
7	7	-> test -z "$cmd"
2	2	-> return 1
15	181	> __fish_git_using_command rev-parse
57	159	-> set -l cmd (__fish_git_needs_command)
10	102	--> __fish_git_needs_command
56	65	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
13	170	> __fish_git_using_command restore switch
57	150	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
52	60	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
15	184	> __fish_git_using_command switch
66	156	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
9	9	-> test -z "$cmd"
4	4	-> return 1
12	235	> __fish_git_using_command restore
72	214	-> set -l cmd (__fish_git_needs_command)
15	142	--> __fish_git_needs_command
85	95	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
8	32	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
11	170	> __fish_git_using_command reset
52	150	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
56	62	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
14	182	> __fish_git_using_command reflog
65	155	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
9	9	-> test -z "$cmd"
4	4	-> return 1
17	267	> __fish_git_using_command rebase
64	240	-> set -l cmd (__fish_git_needs_command)
12	176	--> __fish_git_needs_command
120	131	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
9	33	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
7	7	-> test -z "$cmd"
3	3	-> return 1
12	184	> __fish_git_using_command push
59	164	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
61	69	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
16	263	> __fish_git_using_command range-diff
71	235	-> set -l cmd (__fish_git_needs_command)
14	164	--> __fish_git_needs_command
82	90	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
15	60	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	27	----> if set -q __fish_git_cmd[1]...
23	23	-----> set -q __fish_git_cmd[1]
5	5	----> return 0
8	8	-> test -z "$cmd"
4	4	-> return 1
14	177	> __fish_git_using_command pull
53	156	-> set -l cmd (__fish_git_needs_command)
11	103	--> __fish_git_needs_command
55	63	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
13	168	> __fish_git_using_command prune
50	148	-> set -l cmd (__fish_git_needs_command)
10	98	--> __fish_git_needs_command
52	63	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	165	> __fish_git_using_command notes
52	146	-> set -l cmd (__fish_git_needs_command)
10	94	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	163	> __fish_git_using_command mv
51	144	-> set -l cmd (__fish_git_needs_command)
10	93	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
14	194	> __fish_git_using_command mergetool
54	172	-> set -l cmd (__fish_git_needs_command)
15	118	--> __fish_git_needs_command
61	67	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
12	170	> __fish_git_using_command merge-base
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
55	63	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
4	4	-> return 1
12	161	> __fish_git_using_command merge
50	142	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	165	> __fish_git_using_command maintenance
53	146	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command mailsplit
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	197	> __fish_git_using_command mailsplit am
54	178	-> set -l cmd (__fish_git_needs_command)
10	124	--> __fish_git_needs_command
76	88	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	178	> __fish_git_using_command mailinfo
55	159	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
59	65	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
13	30	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	156	> __fish_git_using_command mailinfo am
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	157	> __fish_git_using_command ls-files
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	158	> __fish_git_using_command log
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	59	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	157	> __fish_git_using_command init
49	139	-> set -l cmd (__fish_git_needs_command)
10	90	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	153	> __fish_git_using_command grep
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
0	4	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	157	> __fish_git_using_command gc
48	138	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	155	> __fish_git_using_command difftool
50	138	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	156	> __fish_git_using_command diff
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	161	> __fish_git_using_command describe
51	142	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
4	7	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command daemon
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	166	> __fish_git_using_command count-objects
51	147	-> set -l cmd (__fish_git_needs_command)
10	96	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
12	29	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	160	> __fish_git_using_command commit
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command clone
52	143	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command cherry-pick
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command cherry
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	171	> __fish_git_using_command bundle
58	153	-> set -l cmd (__fish_git_needs_command)
11	95	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	157	> __fish_git_using_command branch
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	159	> __fish_git_using_command bisect
50	141	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	166	> __fish_git_using_command archive
50	146	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	30	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	161	> __fish_git_using_command apply
50	141	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	166	> __fish_git_using_command apply am
52	147	-> set -l cmd (__fish_git_needs_command)
9	95	--> __fish_git_needs_command
50	59	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	163	> __fish_git_using_command checkout
51	143	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
13	166	> __fish_git_using_command am
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
9	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	179	> __fish_git_using_command add
58	158	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	163	> __fish_git_using_command show-branch
51	142	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
16	202	> __fish_git_using_command show
64	173	-> set -l cmd (__fish_git_needs_command)
9	109	--> __fish_git_needs_command
59	66	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
9	9	-> test -z "$cmd"
4	4	-> return 1
11	222	> __fish_git_needs_rev_files
28	211	-> __fish_git_using_command show
55	175	--> set -l cmd (__fish_git_needs_command)
11	120	---> __fish_git_needs_command
60	76	----> set -l cmdline "$(commandline -c)"
16	16	-----> commandline -c
12	33	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
7	7	-----> test "$cmdline" = "$__fish_git_cmdline"
3	7	-----> if set -q __fish_git_cmd[1]...
4	4	------> set -q __fish_git_cmd[1]
3	3	-----> return 0
5	5	--> test -z "$cmd"
3	3	--> return 1
17	166	> __fish_git_using_command remote
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	165	> __fish_git_using_command filter-branch
51	145	-> set -l cmd (__fish_git_needs_command)
9	94	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	161	> __fish_git_using_command fetch
50	142	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	160	> __fish_git_using_command fetch pull
50	140	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	165	> __fish_git_using_command diff log show range-diff
52	145	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	159	> __fish_git_using_command diff show range-diff
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
20	202	> __fish_git_using_command diff show range-diff apply
76	173	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
11	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
7	7	-> test -z "$cmd"
2	2	-> return 1
14	189	> __fish_git_using_command log show diff-tree rev-list
57	168	-> set -l cmd (__fish_git_needs_command)
17	111	--> __fish_git_needs_command
55	66	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
30	489	> __fish_git_using_command upload-pack
62	450	-> set -l cmd (__fish_git_needs_command)
38	388	--> __fish_git_needs_command
73	88	---> set -l cmdline "$(commandline -c)"
15	15	----> commandline -c
5	21	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
7	7	---> set -g __fish_git_cmdline $cmdline
39	47	---> set -l cmd (commandline -opc)
8	8	----> commandline -opc
6	6	---> set -e cmd[1]
116	152	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
14	36	----> __fish_git_global_optspecs
22	22	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
2	5	---> if set -q argv[1]...
3	3	----> set -q argv[1]
6	6	---> set -g __fish_git_cmd
3	3	---> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
11	171	> __fish_git_using_command upload-archive
53	152	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	203	> __fish_git_using_command shell
57	181	-> set -l cmd (__fish_git_needs_command)
14	124	--> __fish_git_needs_command
65	71	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	39	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
3	7	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
15	224	> __fish_git_using_command receive-pack
57	200	-> set -l cmd (__fish_git_needs_command)
21	143	--> __fish_git_needs_command
75	84	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	38	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
14	178	> __fish_git_using_command flow
54	156	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
55	64	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	165	> __fish_git_using_command cvsserver
52	146	-> set -l cmd (__fish_git_needs_command)
9	94	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
8	91	> __fish_git_needs_command
51	57	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
8	26	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
6	6	--> test "$cmdline" = "$__fish_git_cmdline"
2	5	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
3	3	--> return 0
20	55776	> __fish_git_custom_commands
136	55756	-> for name in (string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*)...
55558	55558	--> string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*
11	11	--> switch $name...
8	26	--> switch $name...
18	18	---> echo $name
4	4	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
4	4	--> switch $name...
2	2	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
27	146	> __fish_seen_subcommand_from branch for-each-ref tag
84	95	-> set -l cmd (commandline -poc)
11	11	--> commandline -poc
12	12	-> set -e cmd[1]
7	7	-> for i in $cmd...
5	5	-> return 1
19	228	> __fish_git_using_command for-each-ref
65	200	-> set -l cmd (__fish_git_needs_command)
14	135	--> __fish_git_needs_command
67	83	---> set -l cmdline "$(commandline -c)"
16	16	----> commandline -c
10	38	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
15	191	> __fish_git_using_command config
58	167	-> set -l cmd (__fish_git_needs_command)
10	109	--> __fish_git_needs_command
60	67	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
9	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
12	172	> __fish_git_using_command help
52	153	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
59	65	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	172	> __fish_git_using_command blame
56	152	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	163	> __fish_git_using_command clean
52	145	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
13	57872	> __fish_git_aliases
137	57859	-> __fish_git config -z --get-regexp '^alias\.' 2>/dev/null | while read -lz key value
        begin
            set -l name (string replace -r '^.*\.' '' -- $key)
            set -l val (string shorten --no-newline -m 36 -- $value)
            printf "%s\t%s\n" $name "alias: $val"
        end
    end
13	13	--> set -l saved_args $argv
5	5	--> set -l global_args
38	46	--> set -l cmd (commandline -opc)
8	8	---> commandline -opc
6	6	--> set -e cmd[1]
10	317	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
111	142	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	31	----> __fish_git_global_optspecs
22	22	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
55	155	---> set -l num_global_args (math (count $cmd) - (count $argv))
82	100	----> math (count $cmd) - (count $argv)
11	11	-----> count $cmd
7	7	-----> count $argv
1	10	---> if test $num_global_args -ne 0...
9	9	----> test $num_global_args -ne 0
56	57313	--> eval command git $global_args \$saved_args 2>/dev/null
57257	57257	---> command git $saved_args
22	22	--> read -lz key value
16	211	> __fish_git_using_command submodule
59	186	-> set -l cmd (__fish_git_needs_command)
10	127	--> __fish_git_needs_command
68	81	---> set -l cmdline "$(commandline -c)"
13	13	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
13	182	> __fish_git_using_command format-patch
57	162	-> set -l cmd (__fish_git_needs_command)
11	105	--> __fish_git_needs_command
56	64	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
10	30	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	168	> __fish_git_using_command format-patch log
51	149	-> set -l cmd (__fish_git_needs_command)
10	98	--> __fish_git_needs_command
57	63	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	163	> __fish_git_using_command stash
51	144	-> set -l cmd (__fish_git_needs_command)
10	93	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
3	7	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	164	> __fish_git_using_command worktree
50	146	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
56	62	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	160	> __fish_git_using_command update-index
50	142	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	28	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	156	> __fish_git_using_command tag
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	154	> __fish_git_using_command stripspace
47	136	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	155	> __fish_git_using_command status
50	138	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	158	> __fish_git_using_command rm
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	162	> __fish_git_using_command revert
49	143	-> set -l cmd (__fish_git_needs_command)
11	94	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command rev-parse
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	162	> __fish_git_using_command restore switch
50	143	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	157	> __fish_git_using_command switch
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	156	> __fish_git_using_command restore
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
29	215	> __fish_git_using_command reset
59	178	-> set -l cmd (__fish_git_needs_command)
11	119	--> __fish_git_needs_command
66	76	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
7	32	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	176	> __fish_git_using_command reflog
52	157	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
18	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	163	> __fish_git_using_command rebase
50	144	-> set -l cmd (__fish_git_needs_command)
8	94	--> __fish_git_needs_command
51	60	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	158	> __fish_git_using_command push
48	139	-> set -l cmd (__fish_git_needs_command)
10	91	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command range-diff
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
14	160	> __fish_git_using_command pull
48	138	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command prune
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	154	> __fish_git_using_command notes
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command mv
48	138	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
24	219	> __fish_git_using_command mergetool
67	181	-> set -l cmd (__fish_git_needs_command)
11	114	--> __fish_git_needs_command
61	71	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
8	32	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
10	10	-> test -z "$cmd"
4	4	-> return 1
14	209	> __fish_git_using_command merge-base
76	187	-> set -l cmd (__fish_git_needs_command)
10	111	--> __fish_git_needs_command
61	70	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	31	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	165	> __fish_git_using_command merge
50	145	-> set -l cmd (__fish_git_needs_command)
9	95	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	165	> __fish_git_using_command maintenance
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
12	31	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	157	> __fish_git_using_command mailsplit
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	168	> __fish_git_using_command mailsplit am
49	148	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
53	65	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	157	> __fish_git_using_command mailinfo
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	158	> __fish_git_using_command mailinfo am
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	160	> __fish_git_using_command ls-files
51	141	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	158	> __fish_git_using_command log
48	139	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	158	> __fish_git_using_command init
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	157	> __fish_git_using_command grep
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	163	> __fish_git_using_command gc
50	144	-> set -l cmd (__fish_git_needs_command)
12	94	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	155	> __fish_git_using_command difftool
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	155	> __fish_git_using_command diff
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	158	> __fish_git_using_command describe
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
50	58	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	158	> __fish_git_using_command daemon
48	140	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	28	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	156	> __fish_git_using_command count-objects
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	159	> __fish_git_using_command commit
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	154	> __fish_git_using_command clone
48	136	-> set -l cmd (__fish_git_needs_command)
7	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command cherry-pick
48	138	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	155	> __fish_git_using_command cherry
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	155	> __fish_git_using_command bundle
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	153	> __fish_git_using_command branch
49	136	-> set -l cmd (__fish_git_needs_command)
7	87	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	186	> __fish_git_using_command bisect
53	166	-> set -l cmd (__fish_git_needs_command)
11	113	--> __fish_git_needs_command
64	70	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	32	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
13	169	> __fish_git_using_command archive
52	149	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	160	> __fish_git_using_command apply
49	141	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	160	> __fish_git_using_command apply am
49	141	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
53	58	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	158	> __fish_git_using_command checkout
50	140	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command am
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
10	157	> __fish_git_using_command add
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command show-branch
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	155	> __fish_git_using_command show
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	199	> __fish_git_needs_rev_files
27	190	-> __fish_git_using_command show
53	156	--> set -l cmd (__fish_git_needs_command)
11	103	---> __fish_git_needs_command
57	63	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
7	29	----> if set -q __fish_git_cmdline...
5	5	-----> set -q __fish_git_cmdline
8	8	-----> test "$cmdline" = "$__fish_git_cmdline"
2	6	-----> if set -q __fish_git_cmd[1]...
4	4	------> set -q __fish_git_cmd[1]
3	3	-----> return 0
5	5	--> test -z "$cmd"
2	2	--> return 1
12	166	> __fish_git_using_command remote
50	146	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
10	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	162	> __fish_git_using_command filter-branch
49	143	-> set -l cmd (__fish_git_needs_command)
8	94	--> __fish_git_needs_command
56	61	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	164	> __fish_git_using_command fetch
50	145	-> set -l cmd (__fish_git_needs_command)
12	95	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	159	> __fish_git_using_command fetch pull
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	162	> __fish_git_using_command diff log show range-diff
51	144	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	158	> __fish_git_using_command diff show range-diff
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command diff show range-diff apply
50	142	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
49	58	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command log show diff-tree rev-list
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
27	534	> __fish_git_using_command upload-pack
68	497	-> set -l cmd (__fish_git_needs_command)
40	429	--> __fish_git_needs_command
74	88	---> set -l cmdline "$(commandline -c)"
14	14	----> commandline -c
6	22	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
15	15	---> set -g __fish_git_cmdline $cmdline
42	49	---> set -l cmd (commandline -opc)
7	7	----> commandline -opc
6	6	---> set -e cmd[1]
139	174	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	35	----> __fish_git_global_optspecs
25	25	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
9	9	---> set -q _flag_version
4	4	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
2	6	---> if set -q argv[1]...
4	4	----> set -q argv[1]
6	6	---> set -g __fish_git_cmd
4	4	---> return 0
7	7	-> test -z "$cmd"
3	3	-> return 1
15	182	> __fish_git_using_command upload-archive
54	159	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
58	66	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
21	357	> __fish_git_using_command shell
128	324	-> set -l cmd (__fish_git_needs_command)
29	196	--> __fish_git_needs_command
67	74	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
30	93	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
35	35	----> test "$cmdline" = "$__fish_git_cmdline"
3	17	----> if set -q __fish_git_cmd[1]...
14	14	-----> set -q __fish_git_cmd[1]
6	6	----> return 0
8	8	-> test -z "$cmd"
4	4	-> return 1
14	177	> __fish_git_using_command receive-pack
55	156	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
55	63	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
13	161	> __fish_git_using_command flow
50	142	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
17	187	> __fish_git_using_command cvsserver
65	155	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
11	11	-> test -z "$cmd"
4	4	-> return 1
12	111	> __fish_git_needs_command
59	68	-> set -l cmdline "$(commandline -c)"
9	9	--> commandline -c
9	31	-> if set -q __fish_git_cmdline...
5	5	--> set -q __fish_git_cmdline
8	8	--> test "$cmdline" = "$__fish_git_cmdline"
2	6	--> if set -q __fish_git_cmd[1]...
4	4	---> set -q __fish_git_cmd[1]
3	3	--> return 0
10	54798	> __fish_git_custom_commands
146	54788	-> for name in (string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*)...
54586	54586	--> string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*
9	9	--> switch $name...
7	20	--> switch $name...
13	13	---> echo $name
4	4	--> switch $name...
4	4	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
4	4	--> switch $name...
3	3	--> switch $name...
25	105	> __fish_seen_subcommand_from branch for-each-ref tag
49	62	-> set -l cmd (commandline -poc)
13	13	--> commandline -poc
7	7	-> set -e cmd[1]
7	7	-> for i in $cmd...
4	4	-> return 1
15	197	> __fish_git_using_command for-each-ref
61	174	-> set -l cmd (__fish_git_needs_command)
11	113	--> __fish_git_needs_command
64	70	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	32	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
20	226	> __fish_git_using_command config
63	198	-> set -l cmd (__fish_git_needs_command)
12	135	--> __fish_git_needs_command
72	89	---> set -l cmdline "$(commandline -c)"
17	17	----> commandline -c
11	34	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	198	> __fish_git_using_command help
72	178	-> set -l cmd (__fish_git_needs_command)
11	106	--> __fish_git_needs_command
59	67	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	173	> __fish_git_using_command blame
57	153	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
15	187	> __fish_git_using_command clean
65	158	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
12	12	-> test -z "$cmd"
2	2	-> return 1
13	57666	> __fish_git_aliases
176	57653	-> __fish_git config -z --get-regexp '^alias\.' 2>/dev/null | while read -lz key value
        begin
            set -l name (string replace -r '^.*\.' '' -- $key)
            set -l val (string shorten --no-newline -m 36 -- $value)
            printf "%s\t%s\n" $name "alias: $val"
        end
    end
15	15	--> set -l saved_args $argv
5	5	--> set -l global_args
40	48	--> set -l cmd (commandline -opc)
8	8	---> commandline -opc
6	6	--> set -e cmd[1]
10	323	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
119	157	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	38	----> __fish_git_global_optspecs
28	28	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
52	146	---> set -l num_global_args (math (count $cmd) - (count $argv))
75	94	----> math (count $cmd) - (count $argv)
12	12	-----> count $cmd
7	7	-----> count $argv
3	10	---> if test $num_global_args -ne 0...
7	7	----> test $num_global_args -ne 0
56	57059	--> eval command git $global_args \$saved_args 2>/dev/null
57003	57003	---> command git $saved_args
21	21	--> read -lz key value
17	238	> __fish_git_using_command submodule
63	211	-> set -l cmd (__fish_git_needs_command)
20	148	--> __fish_git_needs_command
73	86	---> set -l cmdline "$(commandline -c)"
13	13	----> commandline -c
10	42	---> if set -q __fish_git_cmdline...
9	9	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
7	7	-> test -z "$cmd"
3	3	-> return 1
14	179	> __fish_git_using_command format-patch
54	157	-> set -l cmd (__fish_git_needs_command)
11	103	--> __fish_git_needs_command
55	65	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	162	> __fish_git_using_command format-patch log
51	142	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	165	> __fish_git_using_command stash
51	145	-> set -l cmd (__fish_git_needs_command)
8	94	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	29	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	9	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
10	162	> __fish_git_using_command worktree
50	144	-> set -l cmd (__fish_git_needs_command)
9	94	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	168	> __fish_git_using_command update-index
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
60	66	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	156	> __fish_git_using_command tag
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	154	> __fish_git_using_command stripspace
48	136	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	153	> __fish_git_using_command status
48	135	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	153	> __fish_git_using_command rm
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	153	> __fish_git_using_command revert
48	135	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command rev-parse
56	142	-> set -l cmd (__fish_git_needs_command)
7	86	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	155	> __fish_git_using_command restore switch
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	157	> __fish_git_using_command switch
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	158	> __fish_git_using_command restore
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
11	29	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
4	7	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	153	> __fish_git_using_command reset
49	135	-> set -l cmd (__fish_git_needs_command)
8	86	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	153	> __fish_git_using_command reflog
50	136	-> set -l cmd (__fish_git_needs_command)
8	86	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command rebase
48	139	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	152	> __fish_git_using_command push
48	134	-> set -l cmd (__fish_git_needs_command)
8	86	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	154	> __fish_git_using_command range-diff
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	154	> __fish_git_using_command pull
48	135	-> set -l cmd (__fish_git_needs_command)
9	87	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	158	> __fish_git_using_command prune
49	139	-> set -l cmd (__fish_git_needs_command)
11	90	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
9	153	> __fish_git_using_command notes
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	152	> __fish_git_using_command mv
48	135	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	156	> __fish_git_using_command mergetool
52	139	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	166	> __fish_git_using_command merge-base
60	149	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
49	56	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	155	> __fish_git_using_command merge
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
16	171	> __fish_git_using_command maintenance
51	147	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
50	59	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
11	28	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	155	> __fish_git_using_command mailsplit
49	138	-> set -l cmd (__fish_git_needs_command)
10	89	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	157	> __fish_git_using_command mailsplit am
51	139	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	164	> __fish_git_using_command mailinfo
52	147	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	8	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	156	> __fish_git_using_command mailinfo am
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	158	> __fish_git_using_command ls-files
51	140	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command log
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	160	> __fish_git_using_command init
50	141	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
11	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	158	> __fish_git_using_command grep
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	164	> __fish_git_using_command gc
51	146	-> set -l cmd (__fish_git_needs_command)
11	95	--> __fish_git_needs_command
50	59	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	159	> __fish_git_using_command difftool
50	141	-> set -l cmd (__fish_git_needs_command)
10	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	154	> __fish_git_using_command diff
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
9	157	> __fish_git_using_command describe
50	140	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	156	> __fish_git_using_command daemon
51	138	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
14	160	> __fish_git_using_command count-objects
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	28	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	9	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	158	> __fish_git_using_command commit
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	159	> __fish_git_using_command clone
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command cherry-pick
50	139	-> set -l cmd (__fish_git_needs_command)
7	89	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	153	> __fish_git_using_command cherry
48	136	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	158	> __fish_git_using_command bundle
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	154	> __fish_git_using_command branch
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	157	> __fish_git_using_command bisect
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	157	> __fish_git_using_command archive
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	198	> __fish_git_using_command apply
50	180	-> set -l cmd (__fish_git_needs_command)
9	130	--> __fish_git_needs_command
88	96	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
16	189	> __fish_git_using_command apply am
55	164	-> set -l cmd (__fish_git_needs_command)
10	109	--> __fish_git_needs_command
60	68	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	31	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
15	235	> __fish_git_using_command checkout
101	208	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
57	64	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
9	9	----> return 0
5	5	-> test -z "$cmd"
7	7	-> return 1
17	324	> __fish_git_using_command am
105	295	-> set -l cmd (__fish_git_needs_command)
14	190	--> __fish_git_needs_command
59	66	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
39	110	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
49	49	----> test "$cmdline" = "$__fish_git_cmdline"
3	14	----> if set -q __fish_git_cmd[1]...
11	11	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
8	8	-> test -z "$cmd"
4	4	-> return 1
18	215	> __fish_git_using_command add
62	188	-> set -l cmd (__fish_git_needs_command)
13	126	--> __fish_git_needs_command
70	80	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
10	33	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
17	226	> __fish_git_using_command show-branch
62	200	-> set -l cmd (__fish_git_needs_command)
13	138	--> __fish_git_needs_command
80	94	---> set -l cmdline "$(commandline -c)"
14	14	----> commandline -c
9	31	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
13	175	> __fish_git_using_command show
55	155	-> set -l cmd (__fish_git_needs_command)
10	100	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
18	280	> __fish_git_needs_rev_files
35	262	-> __fish_git_using_command show
77	219	--> set -l cmd (__fish_git_needs_command)
12	142	---> __fish_git_needs_command
70	81	----> set -l cmdline "$(commandline -c)"
11	11	-----> commandline -c
22	49	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
14	14	-----> test "$cmdline" = "$__fish_git_cmdline"
2	6	-----> if set -q __fish_git_cmd[1]...
4	4	------> set -q __fish_git_cmd[1]
3	3	-----> return 0
5	5	--> test -z "$cmd"
3	3	--> return 1
23	220	> __fish_git_using_command remote
72	188	-> set -l cmd (__fish_git_needs_command)
11	116	--> __fish_git_needs_command
67	76	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
13	186	> __fish_git_using_command filter-branch
71	166	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	222	> __fish_git_using_command fetch
80	201	-> set -l cmd (__fish_git_needs_command)
17	121	--> __fish_git_needs_command
60	66	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
13	38	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
12	172	> __fish_git_using_command fetch pull
53	152	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	161	> __fish_git_using_command diff log show range-diff
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	170	> __fish_git_using_command diff show range-diff
52	151	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
15	31	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
16	163	> __fish_git_using_command diff show range-diff apply
51	141	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	161	> __fish_git_using_command log show diff-tree rev-list
51	141	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
30	538	> __fish_git_using_command upload-pack
68	499	-> set -l cmd (__fish_git_needs_command)
40	431	--> __fish_git_needs_command
86	103	---> set -l cmdline "$(commandline -c)"
17	17	----> commandline -c
5	26	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
13	13	----> test "$cmdline" = "$__fish_git_cmdline"
8	8	---> set -g __fish_git_cmdline $cmdline
50	60	---> set -l cmd (commandline -opc)
10	10	----> commandline -opc
7	7	---> set -e cmd[1]
120	157	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
12	37	----> __fish_git_global_optspecs
25	25	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
7	7	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
2	5	---> if set -q argv[1]...
3	3	----> set -q argv[1]
5	5	---> set -g __fish_git_cmd
4	4	---> return 0
7	7	-> test -z "$cmd"
2	2	-> return 1
14	174	> __fish_git_using_command upload-archive
54	153	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	161	> __fish_git_using_command shell
51	144	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	163	> __fish_git_using_command receive-pack
53	145	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
17	184	> __fish_git_using_command flow
61	152	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
53	58	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
11	11	-> test -z "$cmd"
4	4	-> return 1
15	199	> __fish_git_using_command cvsserver
56	175	-> set -l cmd (__fish_git_needs_command)
9	119	--> __fish_git_needs_command
61	71	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
14	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
9	97	> __fish_git_needs_command
55	61	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
7	27	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
8	8	--> test "$cmdline" = "$__fish_git_cmdline"
2	5	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
3	3	--> return 0
10	53331	> __fish_git_custom_commands
161	53321	-> for name in (string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*)...
53067	53067	--> string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*
9	9	--> switch $name...
8	58	--> switch $name...
50	50	---> echo $name
3	3	--> switch $name...
3	3	--> switch $name...
4	4	--> switch $name...
4	4	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
23	93	> __fish_seen_subcommand_from branch for-each-ref tag
43	54	-> set -l cmd (commandline -poc)
11	11	--> commandline -poc
6	6	-> set -e cmd[1]
6	6	-> for i in $cmd...
4	4	-> return 1
15	188	> __fish_git_using_command for-each-ref
55	166	-> set -l cmd (__fish_git_needs_command)
11	111	--> __fish_git_needs_command
59	66	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
10	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
1	6	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	178	> __fish_git_using_command config
56	159	-> set -l cmd (__fish_git_needs_command)
10	103	--> __fish_git_needs_command
59	66	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
19	204	> __fish_git_using_command help
58	176	-> set -l cmd (__fish_git_needs_command)
12	118	--> __fish_git_needs_command
62	74	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
8	32	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
22	236	> __fish_git_using_command blame
82	204	-> set -l cmd (__fish_git_needs_command)
14	122	--> __fish_git_needs_command
65	75	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
9	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
7	7	-> test -z "$cmd"
3	3	-> return 1
12	182	> __fish_git_using_command clean
58	162	-> set -l cmd (__fish_git_needs_command)
10	104	--> __fish_git_needs_command
58	65	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
15	57093	> __fish_git_aliases
248	57078	-> __fish_git config -z --get-regexp '^alias\.' 2>/dev/null | while read -lz key value
        begin
            set -l name (string replace -r '^.*\.' '' -- $key)
            set -l val (string shorten --no-newline -m 36 -- $value)
            printf "%s\t%s\n" $name "alias: $val"
        end
    end
18	18	--> set -l saved_args $argv
6	6	--> set -l global_args
40	48	--> set -l cmd (commandline -opc)
8	8	---> commandline -opc
5	5	--> set -e cmd[1]
9	343	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
103	135	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	32	----> __fish_git_global_optspecs
23	23	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
43	189	---> set -l num_global_args (math (count $cmd) - (count $argv))
104	146	----> math (count $cmd) - (count $argv)
30	30	-----> count $cmd
12	12	-----> count $argv
1	10	---> if test $num_global_args -ne 0...
9	9	----> test $num_global_args -ne 0
65	56388	--> eval command git $global_args \$saved_args 2>/dev/null
56323	56323	---> command git $saved_args
22	22	--> read -lz key value
18	207	> __fish_git_using_command submodule
58	181	-> set -l cmd (__fish_git_needs_command)
11	123	--> __fish_git_needs_command
61	75	---> set -l cmdline "$(commandline -c)"
14	14	----> commandline -c
11	37	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
12	167	> __fish_git_using_command format-patch
52	148	-> set -l cmd (__fish_git_needs_command)
10	96	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	160	> __fish_git_using_command format-patch log
49	141	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	162	> __fish_git_using_command stash
51	143	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	203	> __fish_git_using_command worktree
55	182	-> set -l cmd (__fish_git_needs_command)
13	127	--> __fish_git_needs_command
65	76	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
11	38	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
14	239	> __fish_git_using_command update-index
86	215	-> set -l cmd (__fish_git_needs_command)
20	129	--> __fish_git_needs_command
64	73	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
7	7	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
4	4	-> return 1
13	178	> __fish_git_using_command tag
54	157	-> set -l cmd (__fish_git_needs_command)
10	103	--> __fish_git_needs_command
56	65	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	28	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	167	> __fish_git_using_command stripspace
51	147	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	167	> __fish_git_using_command status
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
11	162	> __fish_git_using_command rm
50	144	-> set -l cmd (__fish_git_needs_command)
9	94	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	200	> __fish_git_using_command revert
80	179	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
53	64	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
13	166	> __fish_git_using_command rev-parse
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	162	> __fish_git_using_command restore switch
50	143	-> set -l cmd (__fish_git_needs_command)
10	93	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	168	> __fish_git_using_command switch
53	149	-> set -l cmd (__fish_git_needs_command)
10	96	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	28	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	160	> __fish_git_using_command restore
50	141	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command reset
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	158	> __fish_git_using_command reflog
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
9	156	> __fish_git_using_command rebase
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	159	> __fish_git_using_command push
52	141	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	159	> __fish_git_using_command range-diff
49	141	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	8	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	155	> __fish_git_using_command pull
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
9	156	> __fish_git_using_command prune
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	163	> __fish_git_using_command notes
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
59	64	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	156	> __fish_git_using_command mv
48	137	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
15	160	> __fish_git_using_command mergetool
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
0	4	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	156	> __fish_git_using_command merge-base
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	156	> __fish_git_using_command merge
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	158	> __fish_git_using_command maintenance
51	140	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command mailsplit
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	214	> __fish_git_using_command mailsplit am
51	194	-> set -l cmd (__fish_git_needs_command)
11	143	--> __fish_git_needs_command
98	104	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	168	> __fish_git_using_command mailinfo
51	148	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	161	> __fish_git_using_command mailinfo am
50	142	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	160	> __fish_git_using_command ls-files
50	142	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	159	> __fish_git_using_command log
49	139	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	160	> __fish_git_using_command init
50	142	-> set -l cmd (__fish_git_needs_command)
10	92	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	160	> __fish_git_using_command grep
49	142	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	160	> __fish_git_using_command gc
50	143	-> set -l cmd (__fish_git_needs_command)
10	93	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	171	> __fish_git_using_command difftool
50	152	-> set -l cmd (__fish_git_needs_command)
10	102	--> __fish_git_needs_command
60	66	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command diff
49	140	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	168	> __fish_git_using_command describe
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
58	64	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	174	> __fish_git_using_command daemon
54	154	-> set -l cmd (__fish_git_needs_command)
11	100	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	164	> __fish_git_using_command count-objects
51	144	-> set -l cmd (__fish_git_needs_command)
10	93	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	158	> __fish_git_using_command commit
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	156	> __fish_git_using_command clone
49	138	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	157	> __fish_git_using_command cherry-pick
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	166	> __fish_git_using_command cherry
59	147	-> set -l cmd (__fish_git_needs_command)
7	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	156	> __fish_git_using_command bundle
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	155	> __fish_git_using_command branch
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	155	> __fish_git_using_command bisect
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	155	> __fish_git_using_command archive
49	138	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
9	154	> __fish_git_using_command apply
49	137	-> set -l cmd (__fish_git_needs_command)
7	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	154	> __fish_git_using_command apply am
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	160	> __fish_git_using_command checkout
49	142	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
51	60	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	169	> __fish_git_using_command am
51	149	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
9	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
14	161	> __fish_git_using_command add
51	141	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	164	> __fish_git_using_command show-branch
52	145	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command show
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	183	> __fish_git_needs_rev_files
27	174	-> __fish_git_using_command show
50	140	--> set -l cmd (__fish_git_needs_command)
8	90	---> __fish_git_needs_command
51	57	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
8	25	----> if set -q __fish_git_cmdline...
3	3	-----> set -q __fish_git_cmdline
6	6	-----> test "$cmdline" = "$__fish_git_cmdline"
2	5	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
3	3	-----> return 0
4	4	--> test -z "$cmd"
3	3	--> return 1
12	156	> __fish_git_using_command remote
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	156	> __fish_git_using_command filter-branch
51	139	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
9	154	> __fish_git_using_command fetch
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	155	> __fish_git_using_command fetch pull
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	156	> __fish_git_using_command diff log show range-diff
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	156	> __fish_git_using_command diff show range-diff
50	137	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	155	> __fish_git_using_command diff show range-diff apply
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	161	> __fish_git_using_command log show diff-tree rev-list
49	141	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
11	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
32	531	> __fish_git_using_command upload-pack
78	483	-> set -l cmd (__fish_git_needs_command)
34	405	--> __fish_git_needs_command
75	90	---> set -l cmdline "$(commandline -c)"
15	15	----> commandline -c
5	23	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
8	8	---> set -g __fish_git_cmdline $cmdline
40	48	---> set -l cmd (commandline -opc)
8	8	----> commandline -opc
7	7	---> set -e cmd[1]
122	164	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
18	42	----> __fish_git_global_optspecs
24	24	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
4	4	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
2	5	---> if set -q argv[1]...
3	3	----> set -q argv[1]
6	6	---> set -g __fish_git_cmd
4	4	---> return 0
12	12	-> test -z "$cmd"
4	4	-> return 1
16	194	> __fish_git_using_command upload-archive
59	170	-> set -l cmd (__fish_git_needs_command)
10	111	--> __fish_git_needs_command
58	71	---> set -l cmdline "$(commandline -c)"
13	13	----> commandline -c
9	30	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	168	> __fish_git_using_command shell
53	148	-> set -l cmd (__fish_git_needs_command)
9	95	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command receive-pack
50	142	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	158	> __fish_git_using_command flow
51	140	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
0	4	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	157	> __fish_git_using_command cvsserver
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
9	89	> __fish_git_needs_command
51	56	-> set -l cmdline "$(commandline -c)"
5	5	--> commandline -c
7	24	-> if set -q __fish_git_cmdline...
3	3	--> set -q __fish_git_cmdline
6	6	--> test "$cmdline" = "$__fish_git_cmdline"
2	5	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
3	3	--> return 0
9	53221	> __fish_git_custom_commands
257	53212	-> for name in (string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*)...
52900	52900	--> string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*
9	9	--> switch $name...
7	21	--> switch $name...
14	14	---> echo $name
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
4	4	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
24	102	> __fish_seen_subcommand_from branch for-each-ref tag
48	60	-> set -l cmd (commandline -poc)
12	12	--> commandline -poc
7	7	-> set -e cmd[1]
7	7	-> for i in $cmd...
4	4	-> return 1
20	220	> __fish_git_using_command for-each-ref
69	185	-> set -l cmd (__fish_git_needs_command)
9	116	--> __fish_git_needs_command
63	73	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
10	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
11	11	-> test -z "$cmd"
4	4	-> return 1
16	247	> __fish_git_using_command config
103	223	-> set -l cmd (__fish_git_needs_command)
14	120	--> __fish_git_needs_command
64	73	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	33	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
20	187	> __fish_git_using_command help
54	159	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
57	65	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
10	30	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	166	> __fish_git_using_command blame
52	147	-> set -l cmd (__fish_git_needs_command)
9	95	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
13	198	> __fish_git_using_command clean
82	178	-> set -l cmd (__fish_git_needs_command)
11	96	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
13	57267	> __fish_git_aliases
171	57254	-> __fish_git config -z --get-regexp '^alias\.' 2>/dev/null | while read -lz key value
        begin
            set -l name (string replace -r '^.*\.' '' -- $key)
            set -l val (string shorten --no-newline -m 36 -- $value)
            printf "%s\t%s\n" $name "alias: $val"
        end
    end
14	14	--> set -l saved_args $argv
6	6	--> set -l global_args
35	42	--> set -l cmd (commandline -opc)
7	7	---> commandline -opc
6	6	--> set -e cmd[1]
7	320	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
105	139	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	34	----> __fish_git_global_optspecs
25	25	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	166	---> set -l num_global_args (math (count $cmd) - (count $argv))
108	127	----> math (count $cmd) - (count $argv)
12	12	-----> count $cmd
7	7	-----> count $argv
1	8	---> if test $num_global_args -ne 0...
7	7	----> test $num_global_args -ne 0
54	56674	--> eval command git $global_args \$saved_args 2>/dev/null
56620	56620	---> command git $saved_args
21	21	--> read -lz key value
27	242	> __fish_git_using_command submodule
59	189	-> set -l cmd (__fish_git_needs_command)
13	130	--> __fish_git_needs_command
68	82	---> set -l cmdline "$(commandline -c)"
14	14	----> commandline -c
9	35	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
8	8	-> test -z "$cmd"
18	18	-> return 1
16	194	> __fish_git_using_command format-patch
58	170	-> set -l cmd (__fish_git_needs_command)
12	112	--> __fish_git_needs_command
58	69	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
8	31	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	171	> __fish_git_using_command format-patch log
55	152	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	162	> __fish_git_using_command stash
50	143	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	160	> __fish_git_using_command worktree
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	157	> __fish_git_using_command update-index
49	138	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	161	> __fish_git_using_command tag
51	143	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	167	> __fish_git_using_command stripspace
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
10	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	169	> __fish_git_using_command status
50	150	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	59	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
13	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	171	> __fish_git_using_command rm
52	152	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
14	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
4	4	-> return 1
11	159	> __fish_git_using_command revert
51	141	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
13	161	> __fish_git_using_command rev-parse
51	142	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	161	> __fish_git_using_command restore switch
49	142	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
51	60	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	160	> __fish_git_using_command switch
49	141	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
4	4	-> return 1
11	158	> __fish_git_using_command restore
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	160	> __fish_git_using_command reset
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	155	> __fish_git_using_command reflog
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	155	> __fish_git_using_command rebase
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	157	> __fish_git_using_command push
48	139	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	161	> __fish_git_using_command range-diff
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command pull
50	142	-> set -l cmd (__fish_git_needs_command)
10	92	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	159	> __fish_git_using_command prune
50	141	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
19	200	> __fish_git_using_command notes
58	172	-> set -l cmd (__fish_git_needs_command)
13	114	--> __fish_git_needs_command
60	70	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
8	31	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
15	182	> __fish_git_using_command mv
59	158	-> set -l cmd (__fish_git_needs_command)
10	99	--> __fish_git_needs_command
52	60	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
12	170	> __fish_git_using_command mergetool
52	150	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	179	> __fish_git_using_command merge-base
51	144	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
20	20	-> test -z "$cmd"
3	3	-> return 1
12	163	> __fish_git_using_command merge
50	144	-> set -l cmd (__fish_git_needs_command)
8	94	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	163	> __fish_git_using_command maintenance
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
52	62	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	159	> __fish_git_using_command mailsplit
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	158	> __fish_git_using_command mailsplit am
50	140	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
10	158	> __fish_git_using_command mailinfo
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
13	165	> __fish_git_using_command mailinfo am
51	146	-> set -l cmd (__fish_git_needs_command)
9	95	--> __fish_git_needs_command
57	62	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	159	> __fish_git_using_command ls-files
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
13	163	> __fish_git_using_command log
49	144	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	157	> __fish_git_using_command init
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	159	> __fish_git_using_command grep
50	142	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
11	29	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	154	> __fish_git_using_command gc
50	137	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	154	> __fish_git_using_command difftool
48	135	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	157	> __fish_git_using_command diff
48	135	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	154	> __fish_git_using_command describe
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	153	> __fish_git_using_command daemon
48	134	-> set -l cmd (__fish_git_needs_command)
8	86	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	154	> __fish_git_using_command count-objects
48	135	-> set -l cmd (__fish_git_needs_command)
9	87	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	154	> __fish_git_using_command commit
48	135	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	158	> __fish_git_using_command clone
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	154	> __fish_git_using_command cherry-pick
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	153	> __fish_git_using_command cherry
48	136	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	155	> __fish_git_using_command bundle
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	155	> __fish_git_using_command branch
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	153	> __fish_git_using_command bisect
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
0	4	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	155	> __fish_git_using_command archive
49	137	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	177	> __fish_git_using_command apply
54	157	-> set -l cmd (__fish_git_needs_command)
10	103	--> __fish_git_needs_command
55	64	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	29	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	180	> __fish_git_using_command apply am
55	160	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
60	69	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	160	> __fish_git_using_command checkout
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	159	> __fish_git_using_command am
53	141	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	172	> __fish_git_using_command add
52	151	-> set -l cmd (__fish_git_needs_command)
10	99	--> __fish_git_needs_command
55	63	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	161	> __fish_git_using_command show-branch
52	142	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
12	158	> __fish_git_using_command show
50	140	-> set -l cmd (__fish_git_needs_command)
10	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
9	190	> __fish_git_needs_rev_files
28	181	-> __fish_git_using_command show
51	147	--> set -l cmd (__fish_git_needs_command)
8	96	---> __fish_git_needs_command
52	63	----> set -l cmdline "$(commandline -c)"
11	11	-----> commandline -c
8	25	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
6	6	-----> test "$cmdline" = "$__fish_git_cmdline"
2	5	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
2	2	-----> return 0
4	4	--> test -z "$cmd"
2	2	--> return 1
11	158	> __fish_git_using_command remote
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	161	> __fish_git_using_command filter-branch
51	143	-> set -l cmd (__fish_git_needs_command)
7	92	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	161	> __fish_git_using_command fetch
49	142	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
12	30	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	155	> __fish_git_using_command fetch pull
50	137	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
14	160	> __fish_git_using_command diff log show range-diff
49	140	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	158	> __fish_git_using_command diff show range-diff
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	161	> __fish_git_using_command diff show range-diff apply
50	141	-> set -l cmd (__fish_git_needs_command)
10	91	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	159	> __fish_git_using_command log show diff-tree rev-list
49	139	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
35	695	> __fish_git_using_command upload-pack
70	534	-> set -l cmd (__fish_git_needs_command)
38	464	--> __fish_git_needs_command
75	89	---> set -l cmdline "$(commandline -c)"
14	14	----> commandline -c
5	21	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
7	7	---> set -g __fish_git_cmdline $cmdline
62	73	---> set -l cmd (commandline -opc)
11	11	----> commandline -opc
10	10	---> set -e cmd[1]
130	177	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
15	47	----> __fish_git_global_optspecs
32	32	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
9	34	---> if set -q argv[1]...
4	4	----> set -q argv[1]
10	10	----> set -g __fish_git_cmd $argv[1]
8	8	----> echo $argv[1]
3	3	----> return 1
7	7	-> test -z "$cmd"
49	49	-> contains -- $cmd $argv
51	60	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
29	313	> __fish_git_using_command upload-archive
66	185	-> set -l cmd (__fish_git_needs_command)
10	119	--> __fish_git_needs_command
60	68	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	41	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
62	70	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
12	12	-> set -q $varname
4	4	-> return 1
23	294	> __fish_git_using_command shell
66	196	-> set -l cmd (__fish_git_needs_command)
12	130	--> __fish_git_needs_command
61	70	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	48	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
5	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
5	5	-----> return 1
8	8	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
41	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
23	277	> __fish_git_using_command receive-pack
58	185	-> set -l cmd (__fish_git_needs_command)
12	127	--> __fish_git_needs_command
68	75	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	40	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
41	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
27	314	> __fish_git_using_command flow
61	210	-> set -l cmd (__fish_git_needs_command)
12	149	--> __fish_git_needs_command
68	79	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
7	58	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
7	36	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
17	17	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
46	55	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	276	> __fish_git_using_command cvsserver
57	189	-> set -l cmd (__fish_git_needs_command)
12	132	--> __fish_git_needs_command
69	77	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	43	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
8	22	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
38	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
10	104	> __fish_git_needs_command
54	60	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
7	34	-> if set -q __fish_git_cmdline...
3	3	--> set -q __fish_git_cmdline
7	7	--> test "$cmdline" = "$__fish_git_cmdline"
5	17	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
6	6	---> echo -- $__fish_git_cmd
3	3	---> return 1
18	87	> __fish_seen_subcommand_from branch for-each-ref tag
35	42	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
5	5	-> set -e cmd[1]
9	19	-> for i in $cmd...
2	10	--> if contains -- $i $argv...
8	8	---> contains -- $i $argv
3	3	-> return 1
18	259	> __fish_git_using_command for-each-ref
53	164	-> set -l cmd (__fish_git_needs_command)
11	111	--> __fish_git_needs_command
53	65	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	58	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
20	20	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	242	> __fish_git_using_command config
55	158	-> set -l cmd (__fish_git_needs_command)
10	103	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
42	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	228	> __fish_git_using_command help
51	153	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	227	> __fish_git_using_command blame
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	232	> __fish_git_using_command clean
51	155	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	21	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
10	10	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	223	> __fish_git_using_command submodule
51	149	-> set -l cmd (__fish_git_needs_command)
10	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	232	> __fish_git_using_command format-patch
51	155	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	38	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
10	22	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	226	> __fish_git_using_command format-patch log
52	148	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	230	> __fish_git_using_command stash
50	152	-> set -l cmd (__fish_git_needs_command)
12	102	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
31	236	> __fish_git_using_command worktree
50	147	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
26	231	> __fish_git_using_command update-index
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command tag
50	153	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	245	> __fish_git_using_command stripspace
67	164	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
13	13	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	289	> __fish_git_using_command status
53	196	-> set -l cmd (__fish_git_needs_command)
11	143	--> __fish_git_needs_command
79	89	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
8	43	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
46	54	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
4	4	-> return 1
22	310	> __fish_git_using_command rm
87	214	-> set -l cmd (__fish_git_needs_command)
11	127	--> __fish_git_needs_command
61	71	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
7	45	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
10	24	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
42	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	238	> __fish_git_using_command revert
52	157	-> set -l cmd (__fish_git_needs_command)
9	105	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	230	> __fish_git_using_command rev-parse
52	152	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	241	> __fish_git_using_command restore switch
52	159	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	233	> __fish_git_using_command switch
55	156	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	464	> __fish_git_using_command restore
62	301	-> set -l cmd (__fish_git_needs_command)
29	239	--> __fish_git_needs_command
95	101	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
16	109	---> if set -q __fish_git_cmdline...
19	19	----> set -q __fish_git_cmdline
47	47	----> test "$cmdline" = "$__fish_git_cmdline"
7	27	----> if set -q __fish_git_cmd[1]...
7	7	-----> set -q __fish_git_cmd[1]
9	9	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
7	7	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
97	115	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
18	18	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
18	242	> __fish_git_using_command reset
57	161	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	250	> __fish_git_using_command reflog
60	162	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
46	53	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
21	272	> __fish_git_using_command rebase
69	186	-> set -l cmd (__fish_git_needs_command)
12	117	--> __fish_git_needs_command
60	68	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	246	> __fish_git_using_command push
56	163	-> set -l cmd (__fish_git_needs_command)
8	107	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
11	41	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	263	> __fish_git_using_command range-diff
57	179	-> set -l cmd (__fish_git_needs_command)
11	122	--> __fish_git_needs_command
71	77	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	233	> __fish_git_using_command pull
52	153	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	349	> __fish_git_using_command prune
94	244	-> set -l cmd (__fish_git_needs_command)
12	150	--> __fish_git_needs_command
61	67	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
19	71	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
18	41	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
15	15	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
60	67	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	251	> __fish_git_using_command notes
56	172	-> set -l cmd (__fish_git_needs_command)
13	116	--> __fish_git_needs_command
62	68	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	233	> __fish_git_using_command mv
56	156	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	279	> __fish_git_using_command mergetool
58	185	-> set -l cmd (__fish_git_needs_command)
12	127	--> __fish_git_needs_command
65	70	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	45	---> if set -q __fish_git_cmdline...
7	7	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
8	22	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
45	53	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	316	> __fish_git_using_command merge-base
61	209	-> set -l cmd (__fish_git_needs_command)
13	148	--> __fish_git_needs_command
81	89	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	46	---> if set -q __fish_git_cmdline...
7	7	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
7	22	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
51	60	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
4	4	-> return 1
26	346	> __fish_git_using_command merge
69	237	-> set -l cmd (__fish_git_needs_command)
13	168	--> __fish_git_needs_command
85	93	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	62	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
25	25	----> test "$cmdline" = "$__fish_git_cmdline"
7	22	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
49	57	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
26	333	> __fish_git_using_command maintenance
92	215	-> set -l cmd (__fish_git_needs_command)
12	123	--> __fish_git_needs_command
64	71	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	40	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
9	9	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
54	64	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	271	> __fish_git_using_command mailsplit
57	177	-> set -l cmd (__fish_git_needs_command)
10	120	--> __fish_git_needs_command
59	67	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
10	43	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
43	53	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	260	> __fish_git_using_command mailsplit am
60	174	-> set -l cmd (__fish_git_needs_command)
9	114	--> __fish_git_needs_command
57	64	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
10	41	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
24	285	> __fish_git_using_command mailinfo
64	163	-> set -l cmd (__fish_git_needs_command)
10	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
66	74	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
24	275	> __fish_git_using_command mailinfo am
61	171	-> set -l cmd (__fish_git_needs_command)
8	110	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
49	56	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
24	271	> __fish_git_using_command ls-files
54	164	-> set -l cmd (__fish_git_needs_command)
9	110	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
10	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
52	61	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
3	3	-> return 1
18	277	> __fish_git_using_command log
56	193	-> set -l cmd (__fish_git_needs_command)
12	137	--> __fish_git_needs_command
79	88	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	235	> __fish_git_using_command init
52	153	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	267	> __fish_git_using_command grep
57	178	-> set -l cmd (__fish_git_needs_command)
12	121	--> __fish_git_needs_command
62	68	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	41	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
43	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
23	341	> __fish_git_using_command gc
95	215	-> set -l cmd (__fish_git_needs_command)
10	120	--> __fish_git_needs_command
58	70	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
7	40	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
67	80	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
13	13	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
24	336	> __fish_git_using_command difftool
100	225	-> set -l cmd (__fish_git_needs_command)
11	125	--> __fish_git_needs_command
69	77	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
10	10	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
47	57	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
23	285	> __fish_git_using_command diff
55	172	-> set -l cmd (__fish_git_needs_command)
9	117	--> __fish_git_needs_command
61	69	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
57	65	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
5	5	-> return 1
23	315	> __fish_git_using_command describe
67	200	-> set -l cmd (__fish_git_needs_command)
13	133	--> __fish_git_needs_command
67	75	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	45	---> if set -q __fish_git_cmdline...
7	7	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
8	8	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
59	68	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	260	> __fish_git_using_command daemon
53	169	-> set -l cmd (__fish_git_needs_command)
13	116	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
10	42	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
46	53	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	238	> __fish_git_using_command count-objects
51	158	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	252	> __fish_git_using_command commit
52	164	-> set -l cmd (__fish_git_needs_command)
8	112	--> __fish_git_needs_command
59	66	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
38	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	239	> __fish_git_using_command clone
50	157	-> set -l cmd (__fish_git_needs_command)
8	107	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	40	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	227	> __fish_git_using_command cherry-pick
51	150	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	224	> __fish_git_using_command cherry
50	149	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	225	> __fish_git_using_command bundle
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	228	> __fish_git_using_command branch
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
10	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	227	> __fish_git_using_command bisect
52	152	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	223	> __fish_git_using_command archive
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	233	> __fish_git_using_command apply
51	151	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
40	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
22	263	> __fish_git_using_command apply am
55	168	-> set -l cmd (__fish_git_needs_command)
10	113	--> __fish_git_needs_command
55	64	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
7	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
43	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
24	237	> __fish_git_using_command checkout
52	154	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	234	> __fish_git_using_command am
50	151	-> set -l cmd (__fish_git_needs_command)
10	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
38	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
12	178	> __fish_git_using_command add
53	153	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
2	2	-> return 0
80	177730	> __fish_git_files modified untracked deleted unmerged modified-staged-deleted
67	59500	-> set -l root (__fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null)
59	59433	--> __fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null
14	14	---> set -l saved_args $argv
6	6	---> set -l global_args
54	63	---> set -l cmd (commandline -opc)
9	9	----> commandline -opc
6	6	---> set -e cmd[1]
9	272	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
100	131	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	31	-----> __fish_git_global_optspecs
22	22	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
38	123	----> set -l num_global_args (math (count $cmd) - (count $argv))
67	85	-----> math (count $cmd) - (count $argv)
11	11	------> count $cmd
7	7	------> count $argv
2	9	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
53	59013	---> eval command git $global_args \$saved_args 2>/dev/null
58960	58960	----> command git $saved_args
15	15	-> test "$root[2]" = true
7	7	-> set -e root[2]
13	13	-> contains -- all-staged $argv
8	8	-> contains -- unmerged $argv
5	5	-> set -l unmerged
6	6	-> set -l unmerged_desc "Unmerged File"
7	7	-> contains -- added $argv
3	3	-> set -ql all_staged
6	6	-> contains -- modified $argv
5	5	-> set -l modified
6	6	-> set -l modified_desc "Modified file"
6	6	-> contains -- untracked $argv
3	3	-> set -l untracked
10	10	-> set -l untracked_desc "Untracked file"
7	7	-> contains -- modified-staged $argv
2	2	-> set -ql all_staged
7	7	-> contains -- modified-staged-deleted $argv
4	4	-> set -l modified_staged_deleted
6	6	-> set -l modified_staged_deleted_desc "Staged modified and deleted file"
6	6	-> contains -- deleted $argv
4	4	-> set -l deleted
5	5	-> set -l deleted_desc "Deleted file"
6	6	-> contains -- deleted-staged $argv
3	3	-> set -ql all_staged
6	6	-> contains -- ignored $argv
6	6	-> contains -- renamed $argv
7	7	-> contains -- copied $argv
5	5	-> set -l q '\\?'
2	8	-> if status test-feature qmark-noglob...
6	6	--> status test-feature qmark-noglob
5	5	-> set -l use_next
5	5	-> set -l status_opt --ignore-submodules=all
3	3	-> set -q ignored
3	3	-> set -q untracked
5	5	-> set -a status_opt -uall
6	6	-> set -l git_opt -c status.relativePaths -c core.quotePath=
79	56963	-> set -l ver (__fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2')
104	56884	--> __fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2'
8	8	---> set -l saved_args $argv
4	4	---> set -l global_args
42	52	---> set -l cmd (commandline -opc)
10	10	----> commandline -opc
5	5	---> set -e cmd[1]
7	280	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
101	134	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	33	-----> __fish_git_global_optspecs
23	23	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
45	130	----> set -l num_global_args (math (count $cmd) - (count $argv))
67	85	-----> math (count $cmd) - (count $argv)
11	11	------> count $cmd
7	7	------> count $argv
1	9	----> if test $num_global_args -ne 0...
8	8	-----> test $num_global_args -ne 0
53	56431	---> eval command git $global_args \$saved_args 2>/dev/null
56378	56378	----> command git $saved_args
55	60978	-> if test "$ver[1]" -gt 2 2>/dev/null...
42	42	--> test "$ver[1]" -gt 2 2>/dev/null
26	26	--> test "$ver[1]" -eq 2 -a "$ver[2]" -ge 11 2>/dev/null
135	60855	--> __fish_git $git_opt status --porcelain=2 $status_opt \
            | while read -la -d ' ' line
            set -l file
            set -l desc
            # The basic status format is "XY", where X is "our" state (meaning the staging area),
            # and "Y" is "their" state.
            # A "." means it's unmodified.
            switch "$line[1..2]"
                case 'u *'
                    # Unmerged
                    # "Unmerged entries have the following format; the first character is a "u" to distinguish from ordinary changed entries."
                    # "u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>"
                    # This is first to distinguish it from normal modifications et al.
                    set -ql unmerged
                    and set file "$line[11..-1]"
                    and set desc $unmerged_desc
                case '2 .R*' '2 R.*'
                    # Renamed/Copied
                    # From the docs: "Renamed or copied entries have the following format:"
                    # "2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>"
                    # Since <sep> is \t, we can't really parse it unambiguously.
                    # The "-z" format would be great here!
                    set -ql renamed
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    and set desc $renamed_desc
                case '2 RM*' '2 RT*'
                    # Staged as renamed, with unstaged modifications (issue #6031)
                    set -ql renamed
                    or set -ql modified
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql modified
                    and set --append desc $modified_desc
                case '2 RD*'
                    # Staged as renamed, but deleted in the worktree
                    set -ql renamed
                    or set -ql deleted
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql deleted
                    and set --append desc $deleted_desc
                case '2 .C*' '2 C.*'
                    set -ql copied
                    and set file (string replace -r '\t[^\t].*' '' -- "$line[10..-1]")
                    and set desc $copied_desc
                case '1 A.*'
                    # Additions are only shown here if they are staged.
                    # Otherwise it's an untracked file.
                    set -ql added
                    and set file "$line[9..-1]"
                    and set desc $added_desc
                case '1 AD*'
                    # Added files that were since deleted
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql deleted
                        set file "$line[9..-1]"
                        set desc $deleted_desc
                    end
                case "1 AM*" "1 AT*"
                    # Added files with additional modifications
                    # ("T" is type-changed. As of git 2.33 this appears to be undocumented.
                    # it happens when e.g. a file is replaced with a symlink.
                    # For our purposes it's the same as modified)
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    end
                case '1 .A*'
                    # Files added with git add --intent-to-add.
                    set -ql untracked
                    and set file "$line[9..-1]"
                    and set desc $untracked_desc
                case '1 .M*' '1 .T*'
                    # Modified
                    # From the docs: "Ordinary changed entries have the following format:"
                    # "1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>"
                    # Since <path> can contain spaces, print from element 9 onwards
                    set -ql modified
                    and set file "$line[9..-1]"
                    and set desc $modified_desc
                case '1 MD*' '1 TD*'
                    set -ql modified_staged_deleted
                    and set file "$line[9..-1]"
                    and set desc $modified_staged_deleted_desc
                case '1 M.*' '1 T.*'
                    # If the character is first ("M."), then that means it's "our" change,
                    # which means it is staged.
                    # This is useless for many commands - e.g. `checkout` won't do anything with this.
                    # So it needs to be requested explicitly.
                    set -ql modified_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_modified_desc
                case '1 MM*' '1 MT*' '1 TM*' '1 TT*'
                    # Staged-modified with unstaged modifications
                    # These need to be offered for both kinds of modified.
                    if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    else if set -ql modified_staged
                        set file "$line[9..-1]"
                        set desc $staged_modified_desc
                    end
                case '1 .D*'
                    set -ql deleted
                    and set file "$line[9..-1]"
                    and set desc $deleted_desc
                case '1 D.*'
                    # TODO: The docs are unclear on this.
                    # There is both X unmodified and Y either M or D ("not updated")
                    # and Y is D and X is unmodified or [MARC] ("deleted in work tree").
                    # For our purposes, we assume this is a staged deletion.
                    set -ql deleted_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_deleted_desc
                case "$q"' *'
                    # Untracked
                    # "? <path>" - print from element 2 on.
                    set -ql untracked
                    and set file "$line[2..-1]"
                    and set desc $untracked_desc
                case '! *'
                    # Ignored
                    # "! <path>" - print from element 2 on.
                    set -ql ignored
                    and set file "$line[2..-1]"
                    and set desc $ignored_desc
            end
            # Only try printing if the file was selected.
            if set -q file[1]
                for d in $desc
                    # Without "-z", git sometimes _quotes_ filenames.
                    # It adds quotes around it _and_ escapes the character.
                    # e.g. `"a\\b"`.
                    # We just remove the quotes and hope it works out.
                    # If this contains newlines or tabs,
                    # there is nothing we can do, but that's a general issue with scripted completions.
                    set file (string trim -c \" -- $file)
                    # The relative filename.
                    if string match -q './*' -- (commandline -ct)
                        printf './%s\t%s\n' $file $d
                    else
                        printf '%s\t%s\n' "$file" $d
                    end
                    # Now from repo root.
                    # Only do this if the filename isn't a simple child,
                    # or the current token starts with ":"
                    if string match -q '../*' -- $file
                        or string match -q ':*' -- (commandline -ct)
                        set -l fromroot (builtin realpath -- $file 2>/dev/null)
                        # `:` starts pathspec "magic", and the second `:` terminates it.
                        # `/` is the magic letter for "from repo root".
                        # If we didn't terminate it we'd have to escape any special chars
                        # (non-alphanumeric, glob or regex special characters, in whatever dialect git uses)
                        and set fromroot (string replace -- "$root/" ":/:" "$fromroot")
                        and printf '%s\t%s\n' "$fromroot" $d
                    end
                end
            end
        end
15	15	---> set -l saved_args $argv
5	5	---> set -l global_args
70	84	---> set -l cmd (commandline -opc)
14	14	----> commandline -opc
6	6	---> set -e cmd[1]
10	305	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
118	149	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	31	-----> __fish_git_global_optspecs
22	22	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
47	137	----> set -l num_global_args (math (count $cmd) - (count $argv))
70	90	-----> math (count $cmd) - (count $argv)
12	12	------> count $cmd
8	8	------> count $argv
2	9	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
65	60280	---> eval command git $global_args \$saved_args 2>/dev/null
60215	60215	----> command git $saved_args
25	25	---> read -la -d ' ' line
23	330	> __fish_git_using_command show-branch
66	229	-> set -l cmd (__fish_git_needs_command)
10	163	--> __fish_git_needs_command
66	80	---> set -l cmdline "$(commandline -c)"
14	14	----> commandline -c
8	73	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
10	49	----> if set -q __fish_git_cmd[1]...
28	28	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
46	55	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
25	336	> __fish_git_using_command show
69	219	-> set -l cmd (__fish_git_needs_command)
14	150	--> __fish_git_needs_command
80	87	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	49	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
5	23	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
9	9	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
10	10	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
52	62	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
11	282	> __fish_git_needs_rev_files
35	271	-> __fish_git_using_command show
54	167	--> set -l cmd (__fish_git_needs_command)
9	113	---> __fish_git_needs_command
57	65	----> set -l cmdline "$(commandline -c)"
8	8	-----> commandline -c
7	39	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
9	9	-----> test "$cmdline" = "$__fish_git_cmdline"
6	19	-----> if set -q __fish_git_cmd[1]...
4	4	------> set -q __fish_git_cmd[1]
6	6	------> echo -- $__fish_git_cmd
3	3	------> return 1
5	5	--> test -z "$cmd"
7	7	--> contains -- $cmd $argv
41	48	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	---> string escape --style=var -- $cmd
6	6	--> set -q $varname
3	3	--> return 1
24	300	> __fish_git_using_command remote
56	177	-> set -l cmd (__fish_git_needs_command)
12	121	--> __fish_git_needs_command
60	66	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	43	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
67	75	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
3	3	-> return 1
29	334	> __fish_git_using_command filter-branch
79	203	-> set -l cmd (__fish_git_needs_command)
11	124	--> __fish_git_needs_command
65	74	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
13	13	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
57	71	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
14	14	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
25	271	> __fish_git_using_command fetch
57	174	-> set -l cmd (__fish_git_needs_command)
13	117	--> __fish_git_needs_command
55	63	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	41	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
44	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
25	289	> __fish_git_using_command fetch pull
62	171	-> set -l cmd (__fish_git_needs_command)
11	109	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
60	68	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
24	328	> __fish_git_using_command diff log show range-diff
70	215	-> set -l cmd (__fish_git_needs_command)
13	145	--> __fish_git_needs_command
67	75	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	57	---> if set -q __fish_git_cmdline...
16	16	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
9	22	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
54	62	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
4	4	-> return 1
20	260	> __fish_git_using_command diff show range-diff
66	172	-> set -l cmd (__fish_git_needs_command)
9	106	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	254	> __fish_git_using_command diff show range-diff apply
61	162	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
42	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
23	270	> __fish_git_using_command log show diff-tree rev-list
69	170	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
43	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
29	552	> __fish_git_using_command upload-pack
72	513	-> set -l cmd (__fish_git_needs_command)
37	441	--> __fish_git_needs_command
82	132	---> set -l cmdline "$(commandline -c)"
50	50	----> commandline -c
6	23	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
8	8	---> set -g __fish_git_cmdline $cmdline
40	47	---> set -l cmd (commandline -opc)
7	7	----> commandline -opc
6	6	---> set -e cmd[1]
121	160	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
12	39	----> __fish_git_global_optspecs
27	27	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
2	2	---> set -q _flag_info_path
2	5	---> if set -q argv[1]...
3	3	----> set -q argv[1]
6	6	---> set -g __fish_git_cmd
3	3	---> return 0
7	7	-> test -z "$cmd"
3	3	-> return 1
12	171	> __fish_git_using_command upload-archive
53	151	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	162	> __fish_git_using_command shell
51	143	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	166	> __fish_git_using_command receive-pack
56	148	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
53	58	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	157	> __fish_git_using_command flow
49	138	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command cvsserver
51	144	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
54	59	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
15	120	> __fish_git_needs_command
69	75	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
9	30	-> if set -q __fish_git_cmdline...
6	6	--> set -q __fish_git_cmdline
7	7	--> test "$cmdline" = "$__fish_git_cmdline"
1	5	--> if set -q __fish_git_cmd[1]...
4	4	---> set -q __fish_git_cmd[1]
3	3	--> return 0
15	53645	> __fish_git_custom_commands
185	53630	-> for name in (string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*)...
53389	53389	--> string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*
9	9	--> switch $name...
7	22	--> switch $name...
15	15	---> echo $name
3	3	--> switch $name...
3	3	--> switch $name...
4	4	--> switch $name...
4	4	--> switch $name...
2	2	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
66	137	> __fish_seen_subcommand_from branch for-each-ref tag
43	54	-> set -l cmd (commandline -poc)
11	11	--> commandline -poc
7	7	-> set -e cmd[1]
6	6	-> for i in $cmd...
4	4	-> return 1
15	189	> __fish_git_using_command for-each-ref
56	166	-> set -l cmd (__fish_git_needs_command)
10	110	--> __fish_git_needs_command
56	67	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
9	33	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
1	6	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
11	162	> __fish_git_using_command config
50	143	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	157	> __fish_git_using_command help
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	207	> __fish_git_using_command blame
56	186	-> set -l cmd (__fish_git_needs_command)
13	130	--> __fish_git_needs_command
73	78	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
11	39	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
26	231	> __fish_git_using_command clean
84	187	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
55	65	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
13	13	-> test -z "$cmd"
5	5	-> return 1
14	58108	> __fish_git_aliases
172	58094	-> __fish_git config -z --get-regexp '^alias\.' 2>/dev/null | while read -lz key value
        begin
            set -l name (string replace -r '^.*\.' '' -- $key)
            set -l val (string shorten --no-newline -m 36 -- $value)
            printf "%s\t%s\n" $name "alias: $val"
        end
    end
14	14	--> set -l saved_args $argv
6	6	--> set -l global_args
39	46	--> set -l cmd (commandline -opc)
7	7	---> commandline -opc
6	6	--> set -e cmd[1]
8	306	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
100	131	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	31	----> __fish_git_global_optspecs
21	21	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
41	158	---> set -l num_global_args (math (count $cmd) - (count $argv))
72	117	----> math (count $cmd) - (count $argv)
39	39	-----> count $cmd
6	6	-----> count $argv
2	9	---> if test $num_global_args -ne 0...
7	7	----> test $num_global_args -ne 0
54	57522	--> eval command git $global_args \$saved_args 2>/dev/null
57468	57468	---> command git $saved_args
22	22	--> read -lz key value
17	216	> __fish_git_using_command submodule
62	190	-> set -l cmd (__fish_git_needs_command)
11	128	--> __fish_git_needs_command
60	79	---> set -l cmdline "$(commandline -c)"
19	19	----> commandline -c
11	38	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
14	174	> __fish_git_using_command format-patch
53	153	-> set -l cmd (__fish_git_needs_command)
10	100	--> __fish_git_needs_command
55	63	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
17	174	> __fish_git_using_command format-patch log
53	150	-> set -l cmd (__fish_git_needs_command)
10	97	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	165	> __fish_git_using_command stash
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
56	62	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
13	162	> __fish_git_using_command worktree
50	143	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	161	> __fish_git_using_command update-index
50	142	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
13	164	> __fish_git_using_command tag
52	145	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	165	> __fish_git_using_command stripspace
49	146	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
57	63	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	160	> __fish_git_using_command status
50	142	-> set -l cmd (__fish_git_needs_command)
11	92	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	157	> __fish_git_using_command rm
50	139	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	161	> __fish_git_using_command revert
51	142	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
18	204	> __fish_git_using_command rev-parse
57	178	-> set -l cmd (__fish_git_needs_command)
15	121	--> __fish_git_needs_command
62	73	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
11	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	170	> __fish_git_using_command restore switch
51	149	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
56	63	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
9	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	166	> __fish_git_using_command switch
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
58	64	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	158	> __fish_git_using_command restore
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	161	> __fish_git_using_command reset
51	143	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
51	59	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command reflog
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	157	> __fish_git_using_command rebase
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	157	> __fish_git_using_command push
50	138	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	164	> __fish_git_using_command range-diff
58	145	-> set -l cmd (__fish_git_needs_command)
6	87	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	155	> __fish_git_using_command pull
49	137	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	158	> __fish_git_using_command prune
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	59	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	156	> __fish_git_using_command notes
50	139	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	206	> __fish_git_using_command mv
54	187	-> set -l cmd (__fish_git_needs_command)
12	133	--> __fish_git_needs_command
75	85	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
11	36	---> if set -q __fish_git_cmdline...
7	7	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	188	> __fish_git_using_command mergetool
56	166	-> set -l cmd (__fish_git_needs_command)
12	110	--> __fish_git_needs_command
61	70	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	163	> __fish_git_using_command merge-base
49	144	-> set -l cmd (__fish_git_needs_command)
9	95	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	159	> __fish_git_using_command merge
48	140	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
54	59	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	155	> __fish_git_using_command maintenance
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	155	> __fish_git_using_command mailsplit
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	154	> __fish_git_using_command mailsplit am
50	137	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	155	> __fish_git_using_command mailinfo
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	155	> __fish_git_using_command mailinfo am
48	136	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	154	> __fish_git_using_command ls-files
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command log
48	138	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	8	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	158	> __fish_git_using_command init
49	141	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
51	59	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	156	> __fish_git_using_command grep
48	139	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	154	> __fish_git_using_command gc
47	135	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	155	> __fish_git_using_command difftool
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	155	> __fish_git_using_command diff
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	155	> __fish_git_using_command describe
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command daemon
54	144	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
4	7	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
17	164	> __fish_git_using_command count-objects
49	141	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
50	59	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	156	> __fish_git_using_command commit
50	137	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	165	> __fish_git_using_command clone
55	147	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command cherry-pick
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	158	> __fish_git_using_command cherry
50	139	-> set -l cmd (__fish_git_needs_command)
7	89	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	164	> __fish_git_using_command bundle
51	145	-> set -l cmd (__fish_git_needs_command)
9	94	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
12	28	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command branch
49	138	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	159	> __fish_git_using_command bisect
51	141	-> set -l cmd (__fish_git_needs_command)
10	90	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command archive
50	140	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	159	> __fish_git_using_command apply
51	140	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	163	> __fish_git_using_command apply am
50	145	-> set -l cmd (__fish_git_needs_command)
9	95	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
11	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command checkout
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	159	> __fish_git_using_command am
50	142	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
50	59	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
17	163	> __fish_git_using_command add
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	164	> __fish_git_using_command show-branch
52	145	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	153	> __fish_git_using_command show
50	136	-> set -l cmd (__fish_git_needs_command)
8	86	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	238	> __fish_git_needs_rev_files
32	228	-> __fish_git_using_command show
92	181	--> set -l cmd (__fish_git_needs_command)
8	89	---> __fish_git_needs_command
50	56	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
6	25	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
7	7	-----> test "$cmdline" = "$__fish_git_cmdline"
2	5	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
3	3	-----> return 0
10	10	--> test -z "$cmd"
5	5	--> return 1
15	226	> __fish_git_using_command remote
90	203	-> set -l cmd (__fish_git_needs_command)
12	113	--> __fish_git_needs_command
62	70	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	31	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	173	> __fish_git_using_command filter-branch
55	153	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	164	> __fish_git_using_command fetch
51	145	-> set -l cmd (__fish_git_needs_command)
11	94	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
13	162	> __fish_git_using_command fetch pull
49	142	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
14	161	> __fish_git_using_command diff log show range-diff
51	141	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	164	> __fish_git_using_command diff show range-diff
51	145	-> set -l cmd (__fish_git_needs_command)
10	94	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
19	215	> __fish_git_using_command diff show range-diff apply
58	187	-> set -l cmd (__fish_git_needs_command)
13	129	--> __fish_git_needs_command
76	83	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
10	33	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
1	6	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
15	180	> __fish_git_using_command log show diff-tree rev-list
53	157	-> set -l cmd (__fish_git_needs_command)
10	104	--> __fish_git_needs_command
55	67	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
34	572	> __fish_git_using_command upload-pack
83	521	-> set -l cmd (__fish_git_needs_command)
37	438	--> __fish_git_needs_command
78	95	---> set -l cmdline "$(commandline -c)"
17	17	----> commandline -c
6	23	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
8	8	---> set -g __fish_git_cmdline $cmdline
50	58	---> set -l cmd (commandline -opc)
8	8	----> commandline -opc
11	11	---> set -e cmd[1]
134	174	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
13	40	----> __fish_git_global_optspecs
27	27	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
4	4	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
2	6	---> if set -q argv[1]...
4	4	----> set -q argv[1]
6	6	---> set -g __fish_git_cmd
4	4	---> return 0
12	12	-> test -z "$cmd"
5	5	-> return 1
21	199	> __fish_git_using_command upload-archive
57	170	-> set -l cmd (__fish_git_needs_command)
12	113	--> __fish_git_needs_command
60	69	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	32	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	168	> __fish_git_using_command shell
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
10	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	164	> __fish_git_using_command receive-pack
51	145	-> set -l cmd (__fish_git_needs_command)
9	94	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	158	> __fish_git_using_command flow
50	141	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	165	> __fish_git_using_command cvsserver
51	147	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	91	> __fish_git_needs_command
51	57	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
7	25	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
7	7	--> test "$cmdline" = "$__fish_git_cmdline"
1	5	--> if set -q __fish_git_cmd[1]...
4	4	---> set -q __fish_git_cmd[1]
2	2	--> return 0
10	52699	> __fish_git_custom_commands
134	52689	-> for name in (string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*)...
52501	52501	--> string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*
9	9	--> switch $name...
8	21	--> switch $name...
13	13	---> echo $name
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
25	94	> __fish_seen_subcommand_from branch for-each-ref tag
41	53	-> set -l cmd (commandline -poc)
12	12	--> commandline -poc
6	6	-> set -e cmd[1]
6	6	-> for i in $cmd...
4	4	-> return 1
22	235	> __fish_git_using_command for-each-ref
65	204	-> set -l cmd (__fish_git_needs_command)
14	139	--> __fish_git_needs_command
68	86	---> set -l cmdline "$(commandline -c)"
18	18	----> commandline -c
12	39	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
12	171	> __fish_git_using_command config
54	151	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
3	7	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command help
50	143	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
10	163	> __fish_git_using_command blame
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	157	> __fish_git_using_command clean
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
14	57871	> __fish_git_aliases
154	57857	-> __fish_git config -z --get-regexp '^alias\.' 2>/dev/null | while read -lz key value
        begin
            set -l name (string replace -r '^.*\.' '' -- $key)
            set -l val (string shorten --no-newline -m 36 -- $value)
            printf "%s\t%s\n" $name "alias: $val"
        end
    end
13	13	--> set -l saved_args $argv
5	5	--> set -l global_args
37	44	--> set -l cmd (commandline -opc)
7	7	---> commandline -opc
6	6	--> set -e cmd[1]
7	264	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
95	128	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	33	----> __fish_git_global_optspecs
24	24	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
38	120	---> set -l num_global_args (math (count $cmd) - (count $argv))
65	82	----> math (count $cmd) - (count $argv)
10	10	-----> count $cmd
7	7	-----> count $argv
1	9	---> if test $num_global_args -ne 0...
8	8	----> test $num_global_args -ne 0
56	57348	--> eval command git $global_args \$saved_args 2>/dev/null
57292	57292	---> command git $saved_args
23	23	--> read -lz key value
18	207	> __fish_git_using_command submodule
59	181	-> set -l cmd (__fish_git_needs_command)
11	122	--> __fish_git_needs_command
62	76	---> set -l cmdline "$(commandline -c)"
14	14	----> commandline -c
9	35	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
2	2	-> return 1
11	167	> __fish_git_using_command format-patch
52	148	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	160	> __fish_git_using_command format-patch log
51	141	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	159	> __fish_git_using_command stash
49	140	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
10	158	> __fish_git_using_command worktree
49	140	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command update-index
48	138	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command tag
50	139	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
9	155	> __fish_git_using_command stripspace
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command status
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	161	> __fish_git_using_command rm
49	142	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
3	6	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	158	> __fish_git_using_command revert
48	139	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	158	> __fish_git_using_command rev-parse
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	161	> __fish_git_using_command restore switch
49	142	-> set -l cmd (__fish_git_needs_command)
10	93	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command switch
50	139	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	171	> __fish_git_using_command restore
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
52	63	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
12	30	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	162	> __fish_git_using_command reset
50	144	-> set -l cmd (__fish_git_needs_command)
10	94	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	156	> __fish_git_using_command reflog
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	158	> __fish_git_using_command rebase
49	141	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	161	> __fish_git_using_command push
55	143	-> set -l cmd (__fish_git_needs_command)
7	88	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
0	4	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	161	> __fish_git_using_command range-diff
52	143	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	308	> __fish_git_using_command pull
59	284	-> set -l cmd (__fish_git_needs_command)
14	225	--> __fish_git_needs_command
104	110	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
28	101	---> if set -q __fish_git_cmdline...
13	13	----> set -q __fish_git_cmdline
32	32	----> test "$cmdline" = "$__fish_git_cmdline"
3	23	----> if set -q __fish_git_cmd[1]...
20	20	-----> set -q __fish_git_cmd[1]
5	5	----> return 0
8	8	-> test -z "$cmd"
3	3	-> return 1
14	185	> __fish_git_using_command prune
55	163	-> set -l cmd (__fish_git_needs_command)
11	108	--> __fish_git_needs_command
59	68	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	29	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
16	190	> __fish_git_using_command notes
62	161	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
57	64	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
9	9	-> test -z "$cmd"
4	4	-> return 1
15	253	> __fish_git_using_command mv
82	230	-> set -l cmd (__fish_git_needs_command)
11	148	--> __fish_git_needs_command
94	106	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
8	31	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	178	> __fish_git_using_command mergetool
53	159	-> set -l cmd (__fish_git_needs_command)
9	106	--> __fish_git_needs_command
63	70	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
16	256	> __fish_git_using_command merge-base
72	226	-> set -l cmd (__fish_git_needs_command)
12	154	--> __fish_git_needs_command
62	68	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
18	74	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
19	19	----> test "$cmdline" = "$__fish_git_cmdline"
4	25	----> if set -q __fish_git_cmd[1]...
21	21	-----> set -q __fish_git_cmd[1]
8	8	----> return 0
10	10	-> test -z "$cmd"
4	4	-> return 1
14	180	> __fish_git_using_command merge
54	158	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
55	64	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	31	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	171	> __fish_git_using_command maintenance
50	151	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
53	65	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	160	> __fish_git_using_command mailsplit
50	141	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	157	> __fish_git_using_command mailsplit am
49	138	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command mailinfo
51	140	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	230	> __fish_git_using_command mailinfo am
55	211	-> set -l cmd (__fish_git_needs_command)
12	156	--> __fish_git_needs_command
104	114	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
8	30	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command ls-files
50	142	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	158	> __fish_git_using_command log
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	170	> __fish_git_using_command init
57	152	-> set -l cmd (__fish_git_needs_command)
13	95	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	165	> __fish_git_using_command grep
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
16	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	154	> __fish_git_using_command gc
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	155	> __fish_git_using_command difftool
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	164	> __fish_git_using_command diff
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
58	64	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	156	> __fish_git_using_command describe
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
17	188	> __fish_git_using_command daemon
53	163	-> set -l cmd (__fish_git_needs_command)
11	110	--> __fish_git_needs_command
59	65	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	34	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
16	182	> __fish_git_using_command count-objects
52	159	-> set -l cmd (__fish_git_needs_command)
10	107	--> __fish_git_needs_command
60	69	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	163	> __fish_git_using_command commit
51	144	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	159	> __fish_git_using_command clone
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	163	> __fish_git_using_command cherry-pick
49	144	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
51	61	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command cherry
52	142	-> set -l cmd (__fish_git_needs_command)
7	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command bundle
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command branch
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	156	> __fish_git_using_command bisect
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	159	> __fish_git_using_command archive
48	141	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	176	> __fish_git_using_command apply
48	157	-> set -l cmd (__fish_git_needs_command)
8	109	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
27	45	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	156	> __fish_git_using_command apply am
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command checkout
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	155	> __fish_git_using_command am
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	156	> __fish_git_using_command add
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command show-branch
49	138	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	165	> __fish_git_using_command show
59	148	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	185	> __fish_git_needs_rev_files
27	176	-> __fish_git_using_command show
52	142	--> set -l cmd (__fish_git_needs_command)
8	90	---> __fish_git_needs_command
51	57	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
7	25	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
7	7	-----> test "$cmdline" = "$__fish_git_cmdline"
1	5	-----> if set -q __fish_git_cmd[1]...
4	4	------> set -q __fish_git_cmd[1]
2	2	-----> return 0
4	4	--> test -z "$cmd"
3	3	--> return 1
11	157	> __fish_git_using_command remote
51	140	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
9	157	> __fish_git_using_command filter-branch
50	140	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	162	> __fish_git_using_command fetch
51	143	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
12	29	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	164	> __fish_git_using_command fetch pull
51	145	-> set -l cmd (__fish_git_needs_command)
9	94	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	29	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	8	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
14	161	> __fish_git_using_command diff log show range-diff
52	141	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	183	> __fish_git_using_command diff show range-diff
51	163	-> set -l cmd (__fish_git_needs_command)
10	112	--> __fish_git_needs_command
66	71	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	31	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
13	172	> __fish_git_using_command diff show range-diff apply
58	152	-> set -l cmd (__fish_git_needs_command)
8	94	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	159	> __fish_git_using_command log show diff-tree rev-list
49	140	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
28	530	> __fish_git_using_command upload-pack
72	492	-> set -l cmd (__fish_git_needs_command)
34	420	--> __fish_git_needs_command
74	121	---> set -l cmdline "$(commandline -c)"
47	47	----> commandline -c
4	21	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
8	8	---> set -g __fish_git_cmdline $cmdline
41	48	---> set -l cmd (commandline -opc)
7	7	----> commandline -opc
7	7	---> set -e cmd[1]
117	151	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	34	----> __fish_git_global_optspecs
23	23	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
2	5	---> if set -q argv[1]...
3	3	----> set -q argv[1]
6	6	---> set -g __fish_git_cmd
4	4	---> return 0
7	7	-> test -z "$cmd"
3	3	-> return 1
12	170	> __fish_git_using_command upload-archive
54	150	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	160	> __fish_git_using_command shell
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	157	> __fish_git_using_command receive-pack
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	155	> __fish_git_using_command flow
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	155	> __fish_git_using_command cvsserver
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	88	> __fish_git_needs_command
50	55	-> set -l cmdline "$(commandline -c)"
5	5	--> commandline -c
8	24	-> if set -q __fish_git_cmdline...
3	3	--> set -q __fish_git_cmdline
6	6	--> test "$cmdline" = "$__fish_git_cmdline"
2	5	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
2	2	--> return 0
10	54178	> __fish_git_custom_commands
237	54168	-> for name in (string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*)...
53831	53831	--> string replace -r "^.*/git-([^/]*)" '$1' $PATH/git-*
10	10	--> switch $name...
9	63	--> switch $name...
54	54	---> echo $name
4	4	--> switch $name...
3	3	--> switch $name...
4	4	--> switch $name...
4	4	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
3	3	--> switch $name...
58	148	> __fish_seen_subcommand_from branch for-each-ref tag
54	66	-> set -l cmd (commandline -poc)
12	12	--> commandline -poc
10	10	-> set -e cmd[1]
9	9	-> for i in $cmd...
5	5	-> return 1
15	205	> __fish_git_using_command for-each-ref
65	181	-> set -l cmd (__fish_git_needs_command)
14	116	--> __fish_git_needs_command
59	68	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
9	34	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
17	169	> __fish_git_using_command config
51	145	-> set -l cmd (__fish_git_needs_command)
8	94	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	159	> __fish_git_using_command help
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	156	> __fish_git_using_command blame
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	158	> __fish_git_using_command clean
50	138	-> set -l cmd (__fish_git_needs_command)
9	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	58145	> __fish_git_aliases
174	58132	-> __fish_git config -z --get-regexp '^alias\.' 2>/dev/null | while read -lz key value
        begin
            set -l name (string replace -r '^.*\.' '' -- $key)
            set -l val (string shorten --no-newline -m 36 -- $value)
            printf "%s\t%s\n" $name "alias: $val"
        end
    end
13	13	--> set -l saved_args $argv
5	5	--> set -l global_args
35	42	--> set -l cmd (commandline -opc)
7	7	---> commandline -opc
6	6	--> set -e cmd[1]
8	324	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
101	132	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	31	----> __fish_git_global_optspecs
22	22	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
45	176	---> set -l num_global_args (math (count $cmd) - (count $argv))
95	131	----> math (count $cmd) - (count $argv)
29	29	-----> count $cmd
7	7	-----> count $argv
1	8	---> if test $num_global_args -ne 0...
7	7	----> test $num_global_args -ne 0
54	57547	--> eval command git $global_args \$saved_args 2>/dev/null
57493	57493	---> command git $saved_args
21	21	--> read -lz key value
16	208	> __fish_git_using_command submodule
64	183	-> set -l cmd (__fish_git_needs_command)
10	119	--> __fish_git_needs_command
60	74	---> set -l cmdline "$(commandline -c)"
14	14	----> commandline -c
8	35	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	7	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
14	254	> __fish_git_using_command format-patch
58	231	-> set -l cmd (__fish_git_needs_command)
16	173	--> __fish_git_needs_command
111	118	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
10	39	---> if set -q __fish_git_cmdline...
8	8	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
14	176	> __fish_git_using_command format-patch log
53	154	-> set -l cmd (__fish_git_needs_command)
10	101	--> __fish_git_needs_command
55	64	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	163	> __fish_git_using_command stash
51	144	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
13	160	> __fish_git_using_command worktree
50	141	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	26	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	158	> __fish_git_using_command update-index
50	140	-> set -l cmd (__fish_git_needs_command)
9	90	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	163	> __fish_git_using_command tag
50	144	-> set -l cmd (__fish_git_needs_command)
8	94	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	159	> __fish_git_using_command stripspace
50	142	-> set -l cmd (__fish_git_needs_command)
9	92	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	158	> __fish_git_using_command status
48	139	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	161	> __fish_git_using_command rm
50	143	-> set -l cmd (__fish_git_needs_command)
9	93	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	211	> __fish_git_using_command revert
58	190	-> set -l cmd (__fish_git_needs_command)
15	132	--> __fish_git_needs_command
71	77	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	40	---> if set -q __fish_git_cmdline...
10	10	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
14	176	> __fish_git_using_command rev-parse
53	154	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
56	64	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	161	> __fish_git_using_command restore switch
51	142	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command switch
50	139	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
12	156	> __fish_git_using_command restore
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	155	> __fish_git_using_command reset
50	137	-> set -l cmd (__fish_git_needs_command)
9	87	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	155	> __fish_git_using_command reflog
50	137	-> set -l cmd (__fish_git_needs_command)
7	87	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	155	> __fish_git_using_command rebase
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	154	> __fish_git_using_command push
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	155	> __fish_git_using_command range-diff
50	138	-> set -l cmd (__fish_git_needs_command)
7	88	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
9	155	> __fish_git_using_command pull
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	153	> __fish_git_using_command prune
49	135	-> set -l cmd (__fish_git_needs_command)
8	86	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	154	> __fish_git_using_command notes
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	153	> __fish_git_using_command mv
50	136	-> set -l cmd (__fish_git_needs_command)
8	86	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	161	> __fish_git_using_command mergetool
50	143	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	155	> __fish_git_using_command merge-base
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	154	> __fish_git_using_command merge
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
10	154	> __fish_git_using_command maintenance
49	136	-> set -l cmd (__fish_git_needs_command)
9	87	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	153	> __fish_git_using_command mailsplit
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	152	> __fish_git_using_command mailsplit am
49	135	-> set -l cmd (__fish_git_needs_command)
7	86	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
11	153	> __fish_git_using_command mailinfo
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	159	> __fish_git_using_command mailinfo am
55	142	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	161	> __fish_git_using_command ls-files
50	143	-> set -l cmd (__fish_git_needs_command)
8	93	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	160	> __fish_git_using_command log
55	142	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	157	> __fish_git_using_command init
51	139	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	155	> __fish_git_using_command grep
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	154	> __fish_git_using_command gc
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
12	164	> __fish_git_using_command difftool
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
10	13	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	155	> __fish_git_using_command diff
50	137	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	155	> __fish_git_using_command describe
48	136	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	154	> __fish_git_using_command daemon
48	135	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
9	154	> __fish_git_using_command count-objects
50	137	-> set -l cmd (__fish_git_needs_command)
7	87	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	157	> __fish_git_using_command commit
51	138	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
11	156	> __fish_git_using_command clone
49	139	-> set -l cmd (__fish_git_needs_command)
10	90	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	160	> __fish_git_using_command cherry-pick
51	142	-> set -l cmd (__fish_git_needs_command)
12	91	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
13	158	> __fish_git_using_command cherry
50	139	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
14	166	> __fish_git_using_command bundle
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
51	60	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
8	27	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	159	> __fish_git_using_command branch
49	139	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	167	> __fish_git_using_command bisect
52	148	-> set -l cmd (__fish_git_needs_command)
7	96	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
16	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
3	3	-> return 1
10	156	> __fish_git_using_command archive
50	139	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
4	4	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
11	158	> __fish_git_using_command apply
50	141	-> set -l cmd (__fish_git_needs_command)
9	91	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
10	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	162	> __fish_git_using_command apply am
49	144	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
57	63	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	159	> __fish_git_using_command checkout
50	140	-> set -l cmd (__fish_git_needs_command)
8	90	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	27	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
4	7	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	155	> __fish_git_using_command am
49	137	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
15	227	> __fish_git_using_command add
58	203	-> set -l cmd (__fish_git_needs_command)
13	145	--> __fish_git_needs_command
57	65	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
10	67	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
4	40	----> if set -q __fish_git_cmd[1]...
36	36	-----> set -q __fish_git_cmd[1]
5	5	----> return 0
6	6	-> test -z "$cmd"
3	3	-> return 1
13	183	> __fish_git_using_command show-branch
57	162	-> set -l cmd (__fish_git_needs_command)
12	105	--> __fish_git_needs_command
58	65	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
9	28	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
12	162	> __fish_git_using_command show
49	143	-> set -l cmd (__fish_git_needs_command)
10	94	--> __fish_git_needs_command
51	59	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
9	25	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
8	183	> __fish_git_needs_rev_files
27	175	-> __fish_git_using_command show
50	140	--> set -l cmd (__fish_git_needs_command)
8	90	---> __fish_git_needs_command
51	57	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
8	25	----> if set -q __fish_git_cmdline...
3	3	-----> set -q __fish_git_cmdline
6	6	-----> test "$cmdline" = "$__fish_git_cmdline"
2	5	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
3	3	-----> return 0
5	5	--> test -z "$cmd"
3	3	--> return 1
11	156	> __fish_git_using_command remote
48	137	-> set -l cmd (__fish_git_needs_command)
8	89	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	162	> __fish_git_using_command filter-branch
52	143	-> set -l cmd (__fish_git_needs_command)
8	91	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
11	166	> __fish_git_using_command fetch
59	148	-> set -l cmd (__fish_git_needs_command)
9	89	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
2	2	-> return 1
10	156	> __fish_git_using_command fetch pull
50	138	-> set -l cmd (__fish_git_needs_command)
8	88	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	25	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
3	3	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	155	> __fish_git_using_command diff log show range-diff
49	136	-> set -l cmd (__fish_git_needs_command)
8	87	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
1	5	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
12	153	> __fish_git_using_command diff show range-diff
49	135	-> set -l cmd (__fish_git_needs_command)
8	86	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	6	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
10	154	> __fish_git_using_command diff show range-diff apply
50	136	-> set -l cmd (__fish_git_needs_command)
8	86	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	24	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
5	5	-> test -z "$cmd"
3	3	-> return 1
13	160	> __fish_git_using_command log show diff-tree rev-list
49	141	-> set -l cmd (__fish_git_needs_command)
8	92	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	24	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
2	5	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
2	2	----> return 0
4	4	-> test -z "$cmd"
2	2	-> return 1
38	736	> __fish_git_using_command upload-pack
124	583	-> set -l cmd (__fish_git_needs_command)
40	459	--> __fish_git_needs_command
97	114	---> set -l cmdline "$(commandline -c)"
17	17	----> commandline -c
4	23	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
13	13	----> test "$cmdline" = "$__fish_git_cmdline"
8	8	---> set -g __fish_git_cmdline $cmdline
43	51	---> set -l cmd (commandline -opc)
8	8	----> commandline -opc
6	6	---> set -e cmd[1]
130	169	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
12	39	----> __fish_git_global_optspecs
27	27	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
4	4	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
9	32	---> if set -q argv[1]...
3	3	----> set -q argv[1]
9	9	----> set -g __fish_git_cmd $argv[1]
7	7	----> echo $argv[1]
4	4	----> return 1
7	7	-> test -z "$cmd"
49	49	-> contains -- $cmd $argv
42	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	239	> __fish_git_using_command upload-archive
53	157	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
4	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
27	283	> __fish_git_using_command shell
60	186	-> set -l cmd (__fish_git_needs_command)
10	126	--> __fish_git_needs_command
63	74	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
7	42	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
7	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	236	> __fish_git_using_command receive-pack
52	155	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	234	> __fish_git_using_command flow
52	156	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
12	39	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	225	> __fish_git_using_command cvsserver
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
8	97	> __fish_git_needs_command
50	56	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
6	33	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
7	7	--> test "$cmdline" = "$__fish_git_cmdline"
5	16	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
5	5	---> echo -- $__fish_git_cmd
3	3	---> return 1
19	86	> __fish_seen_subcommand_from branch for-each-ref tag
34	41	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
5	5	-> set -e cmd[1]
8	18	-> for i in $cmd...
2	10	--> if contains -- $i $argv...
8	8	---> contains -- $i $argv
3	3	-> return 1
16	239	> __fish_git_using_command for-each-ref
63	161	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	223	> __fish_git_using_command config
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	222	> __fish_git_using_command help
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	220	> __fish_git_using_command blame
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	226	> __fish_git_using_command clean
53	150	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	282	> __fish_git_using_command submodule
55	189	-> set -l cmd (__fish_git_needs_command)
11	134	--> __fish_git_needs_command
67	77	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
7	46	---> if set -q __fish_git_cmdline...
7	7	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	22	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
43	52	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	247	> __fish_git_using_command format-patch
53	165	-> set -l cmd (__fish_git_needs_command)
10	112	--> __fish_git_needs_command
59	67	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	232	> __fish_git_using_command format-patch log
52	152	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
35	286	> __fish_git_using_command stash
52	179	-> set -l cmd (__fish_git_needs_command)
24	127	--> __fish_git_needs_command
63	69	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
17	17	-> set -q $varname
3	3	-> return 1
18	229	> __fish_git_using_command worktree
52	152	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	241	> __fish_git_using_command update-index
64	163	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	224	> __fish_git_using_command tag
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
2	2	-> return 1
17	229	> __fish_git_using_command stripspace
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	222	> __fish_git_using_command status
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
14	221	> __fish_git_using_command rm
50	147	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	222	> __fish_git_using_command revert
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	223	> __fish_git_using_command rev-parse
51	148	-> set -l cmd (__fish_git_needs_command)
7	97	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	224	> __fish_git_using_command restore switch
50	147	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
4	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	225	> __fish_git_using_command switch
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	223	> __fish_git_using_command restore
49	147	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
28	256	> __fish_git_using_command reset
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
22	22	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
39	253	> __fish_git_using_command reflog
52	152	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command rebase
50	149	-> set -l cmd (__fish_git_needs_command)
10	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command push
50	148	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	226	> __fish_git_using_command range-diff
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	233	> __fish_git_using_command pull
53	157	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
51	61	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	229	> __fish_git_using_command prune
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command notes
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	232	> __fish_git_using_command mv
50	154	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
4	4	-> return 1
19	229	> __fish_git_using_command mergetool
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	227	> __fish_git_using_command merge-base
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	234	> __fish_git_using_command merge
50	157	-> set -l cmd (__fish_git_needs_command)
8	107	--> __fish_git_needs_command
51	61	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
9	38	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
27	267	> __fish_git_using_command maintenance
50	150	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
54	62	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
10	10	-> set -q $varname
6	6	-> return 1
24	268	> __fish_git_using_command mailsplit
55	172	-> set -l cmd (__fish_git_needs_command)
11	117	--> __fish_git_needs_command
57	66	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	40	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
44	52	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	237	> __fish_git_using_command mailsplit am
50	154	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command mailinfo
51	150	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	226	> __fish_git_using_command mailinfo am
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	224	> __fish_git_using_command ls-files
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	224	> __fish_git_using_command log
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	233	> __fish_git_using_command init
50	153	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
11	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	225	> __fish_git_using_command grep
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	221	> __fish_git_using_command gc
49	146	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	222	> __fish_git_using_command difftool
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
20	222	> __fish_git_using_command diff
49	146	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
2	2	-> return 1
16	223	> __fish_git_using_command describe
50	148	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
54	266	> __fish_git_using_command daemon
51	153	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	220	> __fish_git_using_command count-objects
49	145	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	220	> __fish_git_using_command commit
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	220	> __fish_git_using_command clone
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	237	> __fish_git_using_command cherry-pick
60	161	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	221	> __fish_git_using_command cherry
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	219	> __fish_git_using_command bundle
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
32	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	220	> __fish_git_using_command branch
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	220	> __fish_git_using_command bisect
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	219	> __fish_git_using_command archive
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
2	2	-> return 1
16	224	> __fish_git_using_command apply
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	230	> __fish_git_using_command apply am
54	150	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
22	269	> __fish_git_using_command checkout
64	163	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
50	58	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
19	237	> __fish_git_using_command am
52	155	-> set -l cmd (__fish_git_needs_command)
10	103	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	237	> __fish_git_using_command add
50	156	-> set -l cmd (__fish_git_needs_command)
14	106	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	264	> __fish_git_using_command show-branch
83	181	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	235	> __fish_git_using_command show
53	157	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
7	252	> __fish_git_needs_rev_files
35	245	-> __fish_git_using_command show
52	151	--> set -l cmd (__fish_git_needs_command)
9	99	---> __fish_git_needs_command
50	56	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
6	34	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
7	7	-----> test "$cmdline" = "$__fish_git_cmdline"
6	17	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
6	6	------> echo -- $__fish_git_cmd
2	2	------> return 1
5	5	--> test -z "$cmd"
5	5	--> contains -- $cmd $argv
36	42	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	---> string escape --style=var -- $cmd
5	5	--> set -q $varname
2	2	--> return 1
14	174	> __fish_git_using_command remote
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
2	2	-> return 0
21	85	> __fish_seen_subcommand_from update
33	40	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
5	5	-> set -e cmd[1]
8	16	-> for i in $cmd...
2	8	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
3	3	-> return 1
13	72	> __fish_seen_subcommand_from prune
32	38	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
5	5	-> set -e cmd[1]
5	13	-> for i in $cmd...
2	8	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
3	3	-> return 1
15	71	> __fish_seen_subcommand_from show
32	37	-> set -l cmd (commandline -poc)
5	5	--> commandline -poc
4	4	-> set -e cmd[1]
5	13	-> for i in $cmd...
2	8	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
2	2	-> return 1
14	70	> __fish_seen_subcommand_from get-url
32	37	-> set -l cmd (commandline -poc)
5	5	--> commandline -poc
4	4	-> set -e cmd[1]
5	12	-> for i in $cmd...
2	7	--> if contains -- $i $argv...
5	5	---> contains -- $i $argv
3	3	-> return 1
12	70	> __fish_seen_subcommand_from set-url
31	37	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
5	5	-> set -e cmd[1]
6	13	-> for i in $cmd...
2	7	--> if contains -- $i $argv...
5	5	---> contains -- $i $argv
3	3	-> return 1
14	71	> __fish_seen_subcommand_from set-branches
32	37	-> set -l cmd (commandline -poc)
5	5	--> commandline -poc
4	4	-> set -e cmd[1]
5	13	-> for i in $cmd...
2	8	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
3	3	-> return 1
14	70	> __fish_seen_subcommand_from remove
31	37	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
4	4	-> set -e cmd[1]
5	13	-> for i in $cmd...
2	8	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
2	2	-> return 1
13	69	> __fish_seen_subcommand_from add
32	37	-> set -l cmd (commandline -poc)
5	5	--> commandline -poc
4	4	-> set -e cmd[1]
5	12	-> for i in $cmd...
2	7	--> if contains -- $i $argv...
5	5	---> contains -- $i $argv
3	3	-> return 1
18	82	> not __fish_seen_subcommand_from add rm remove show prune update rename set-head set-url set-branches get-url
31	37	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
5	5	-> set -e cmd[1]
6	19	-> for i in $cmd...
1	13	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
3	3	-> return 1
17	83	> __fish_seen_subcommand_from add rm remove show prune update rename set-head set-url set-branches get-url
33	40	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
5	5	-> set -e cmd[1]
6	18	-> for i in $cmd...
2	12	--> if contains -- $i $argv...
10	10	---> contains -- $i $argv
3	3	-> return 1
17	229	> __fish_git_using_command filter-branch
51	151	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
4	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	249	> __fish_git_using_command fetch
62	160	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
40	53	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
13	13	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command fetch pull
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	224	> __fish_git_using_command diff log show range-diff
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	224	> __fish_git_using_command diff show range-diff
49	147	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
2	2	-> return 1
18	225	> __fish_git_using_command diff show range-diff apply
52	148	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	223	> __fish_git_using_command log show diff-tree rev-list
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
144	1795	> __fish_start_bracketed_paste
103	103	-> set -g __fish_last_bind_mode $fish_bind_mode
476	1548	-> string match -q 'single*' (__fish_tokenizer_state -- (commandline -ct | string collect))
426	1072	--> __fish_tokenizer_state -- (commandline -ct | string collect)
193	193	---> commandline -ct | string collect
48	48	---> argparse --min-args 1 --max-args 1 i/initial-state= -- $argv
22	22	---> set -l state normal
7	20	---> if set -q _flag_initial_state...
13	13	----> set -q _flag_initial_state
214	304	---> for char in (string split -- "" $argv[1])...
37	37	----> string split -- "" $argv[1]
35	53	----> switch $char...
18	18	-----> switch $state...
59	59	---> echo $state
45	97	> __fish_stop_bracketed_paste
37	37	-> set fish_bind_mode $__fish_last_bind_mode
15	15	-> set -e __fish_paste_quoted
130	317	> __fish_disable_bracketed_paste 'git remote add origin https://github.com/mostlymaxi/franz.git'
187	187	-> printf "\e[?2004l"
307	3343	> fish_title git\ remote\ add\ origin\ https://github.com/mostlymaxi/franz.git
66	3036	-> if not set -q INSIDE_EMACS...
55	55	--> not set -q INSIDE_EMACS
121	121	--> set -l ssh
55	55	--> set -q SSH_TTY
34	2739	--> if set -q argv[1]...
74	74	---> set -q argv[1]
447	2631	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
39	39	----> string sub -l 20 -- $argv[1]
225	2145	----> prompt_pwd -d 1 -D 1
41	41	-----> set -l options h/help d/dir-length= D/full-length-dirs=
66	66	-----> argparse -n prompt_pwd $options -- $argv
5	18	-----> if set -q _flag_help...
13	13	------> set -q _flag_help
28	28	-----> set -q argv[1]
20	20	-----> set argv $PWD
19	19	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
9	9	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
51	1654	-----> for path in $argv...
187	219	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
207	281	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
74	74	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
135	1103	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
34	34	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
26	578	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
224	464	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
201	240	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
39	39	----------> math $fish_prompt_pwd_full_dirs - 1
46	46	--------> set tmp $all[1]
25	25	--------> set full $all[2..]
255	341	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
86	86	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
75961	75961	> git remote add origin https://github.com/mostlymaxi/franz.git
34	62	> __fish_enable_bracketed_paste
28	28	-> printf "\e[?2004h"
13	89	> fish_mode_prompt
36	76	-> fish_default_mode_prompt
6	40	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
26	26	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
27	223680	> fish_prompt
13	13	-> set -l last_status $status
44	76	-> set -l normal (set_color normal)
32	32	--> set_color normal
39	48	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
37	47	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
34	41	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
12	12	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
2	121	-> if functions -q fish_is_root_user...
53	53	--> functions -q fish_is_root_user
13	66	--> fish_is_root_user
2	34	---> if test "$EUID" = 0 2>/dev/null...
32	32	----> test "$EUID" = 0 2>/dev/null
1	16	---> if contains -- $USER root toor Administrator...
15	15	----> contains -- $USER root toor Administrator
3	3	---> return 1
8	89	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
45	55	--> set status_color (set_color $fish_color_error)
10	10	---> set_color $fish_color_error
19	19	--> set prompt_status $status_color "[" $last_status "]" $normal
120	223178	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
39	332	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
164	267	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
10	10	----> set_color $fish_color_user
6	6	----> set_color normal
7	7	----> set_color $color_host
41	71	----> prompt_hostname
30	30	-----> string replace -r -- "\..*" "" $hostname
9	9	----> set_color normal
21	218	--> prompt_pwd
8	8	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
2	6	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
15	139	---> for path in $argv...
37	48	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
38	58	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
40	222508	--> fish_vcs_prompt
111	222468	---> fish_git_prompt $argv
11	50968	----> if not command -sq git...
50957	50957	-----> not command -sq git
2	81	----> if functions -q __fish_git_prompt_ready...
79	79	-----> functions -q __fish_git_prompt_ready
146	56909	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56763	56763	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
11	11	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
8	8	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
63	56991	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	56928	-----> __fish_git_prompt_operation_branch_bare $repo_info
11	11	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
5	5	------> set -l detached no
3	3	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
28	79	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	40	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
9	9	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
9	56700	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	56687	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
95	56683	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56588	56588	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
5	5	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
5	5	----> set -l dirty
6	6	----> set -l untracked
50839	56807	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5968	5968	-----> read -lz key value
7	42	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
16	16	----> contains dirtystate $__fish_git_prompt_status_order
3	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
11	78	----> if test true = $inside_worktree...
9	9	-----> test true = $inside_worktree
7	44	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
5	5	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
5	14	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
60	79	----> set b (string replace refs/heads/ '' -- $b)
19	19	-----> string replace refs/heads/ '' -- $b
2	29	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
27	27	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	32	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
9	591	> fish_title
6	582	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
5	562	--> if set -q argv[1]...
4	4	---> set -q argv[1]
36	41	---> set -l command (status current-command)
5	5	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
92	499	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
25	400	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
20	20	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	306	-----> for path in $argv...
36	47	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
36	57	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	190	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
4	112	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	91	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	54	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
40	60	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
97	160	> __fish_disable_bracketed_paste 'git remote'
63	63	-> printf "\e[?2004l"
57	2510	> fish_title git\ remote
44	2453	-> if not set -q INSIDE_EMACS...
34	34	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
15	15	--> set -q SSH_TTY
18	2335	--> if set -q argv[1]...
18	18	---> set -q argv[1]
517	2299	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
92	92	----> string sub -l 20 -- $argv[1]
97	1690	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
67	67	-----> argparse -n prompt_pwd $options -- $argv
5	17	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
21	21	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
9	9	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
43	1361	-----> for path in $argv...
147	179	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
148	228	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
80	80	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
39	911	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
19	433	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
116	362	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
132	246	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
114	114	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
299	397	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
98	98	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
76259	76259	> git remote
29	63	> __fish_enable_bracketed_paste
34	34	-> printf "\e[?2004h"
11	63	> fish_mode_prompt
13	52	-> fish_default_mode_prompt
5	39	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
26	26	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
26	221981	> fish_prompt
12	12	-> set -l last_status $status
44	57	-> set -l normal (set_color normal)
13	13	--> set_color normal
39	48	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
37	51	-> set -l cwd_color (set_color $fish_color_cwd)
14	14	--> set_color $fish_color_cwd
35	42	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
12	12	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
2	75	-> if functions -q fish_is_root_user...
8	8	--> functions -q fish_is_root_user
13	65	--> fish_is_root_user
3	34	---> if test "$EUID" = 0 2>/dev/null...
31	31	----> test "$EUID" = 0 2>/dev/null
1	14	---> if contains -- $USER root toor Administrator...
13	13	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
125	221622	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
16	292	--> prompt_login
2	7	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
0	4	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
174	253	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
13	13	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
15	45	----> prompt_hostname
30	30	-----> string replace -r -- "\..*" "" $hostname
6	6	----> set_color normal
25	230	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
15	15	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
15	149	---> for path in $argv...
38	50	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
39	66	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
13	220975	--> fish_vcs_prompt
108	220962	---> fish_git_prompt $argv
10	50156	----> if not command -sq git...
50146	50146	-----> not command -sq git
2	35	----> if functions -q __fish_git_prompt_ready...
33	33	-----> functions -q __fish_git_prompt_ready
148	56571	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56423	56423	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
17	17	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
8	8	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
62	57017	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	56955	-----> __fish_git_prompt_operation_branch_bare $repo_info
14	14	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
25	81	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
6	45	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
11	11	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
13	56720	------> if test -z "$branch"...
5	5	-------> test -z "$branch"
6	56702	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
93	56696	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56603	56603	---------> command git symbolic-ref HEAD 2>/dev/null
3	17	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
13	13	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50601	56487	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5886	5886	-----> read -lz key value
6	42	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
20	20	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
4	16	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
9	9	----> contains untrackedfiles $__fish_git_prompt_status_order
9	76	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	48	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	12	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	17	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
6	6	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
1	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	51	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	9	-----> if test -n "$$i"...
8	8	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
59	74	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
2	22	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
20	20	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	36	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
7	19	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
6	6	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
16	578	> fish_title
6	562	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
6	542	--> if set -q argv[1]...
3	3	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
63	480	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
6	6	----> string sub -l 20 -- $command
23	411	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	5	-----> if set -q _flag_help...
3	3	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
16	316	-----> for path in $argv...
35	46	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
40	62	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
22	22	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	192	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	114	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	92	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
37	53	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
40	59	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
111	178	> __fish_disable_bracketed_paste 'git remote origin'
67	67	-> printf "\e[?2004l"
76	2871	> fish_title git\ remote\ origin
40	2795	-> if not set -q INSIDE_EMACS...
34	34	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
20	20	--> set -q SSH_TTY
23	2676	--> if set -q argv[1]...
17	17	---> set -q argv[1]
492	2636	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
46	46	----> string sub -l 20 -- $argv[1]
118	2098	----> prompt_pwd -d 1 -D 1
48	48	-----> set -l options h/help d/dir-length= D/full-length-dirs=
100	100	-----> argparse -n prompt_pwd $options -- $argv
7	26	-----> if set -q _flag_help...
19	19	------> set -q _flag_help
15	15	-----> set -q argv[1]
67	67	-----> set argv $PWD
9	9	-----> set -ql _flag_d
27	27	-----> set -l fish_prompt_pwd_dir_length $_flag_d
11	11	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
17	17	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
50	1631	-----> for path in $argv...
271	303	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
229	360	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
131	131	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
33	918	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
31	31	-------> test "$fish_prompt_pwd_dir_length" -eq 0
27	27	-------> set -l full
23	528	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
25	25	--------> test $fish_prompt_pwd_full_dirs -gt 0
229	438	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
170	209	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
39	39	----------> math $fish_prompt_pwd_full_dirs - 1
26	26	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
220	299	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
79	79	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
76830	76830	> git remote origin
24	57	> __fish_enable_bracketed_paste
33	33	-> printf "\e[?2004h"
11	53	> fish_mode_prompt
11	42	-> fish_default_mode_prompt
7	31	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
18	18	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
24	227073	> fish_prompt
15	15	-> set -l last_status $status
42	55	-> set -l normal (set_color normal)
13	13	--> set_color normal
36	45	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
37	47	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
34	41	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	78	-> if functions -q fish_is_root_user...
11	11	--> functions -q fish_is_root_user
13	64	--> fish_is_root_user
1	33	---> if test "$EUID" = 0 2>/dev/null...
32	32	----> test "$EUID" = 0 2>/dev/null
4	14	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
5	72	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
40	49	--> set status_color (set_color $fish_color_error)
9	9	---> set_color $fish_color_error
11	11	--> set prompt_status $status_color "[" $last_status "]" $normal
159	226663	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	275	--> prompt_login
3	8	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
7	7	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
165	236	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
9	9	----> set_color $fish_color_user
6	6	----> set_color normal
7	7	----> set_color $color_host
13	42	----> prompt_hostname
29	29	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
21	218	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
15	140	---> for path in $argv...
38	49	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
38	59	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	17	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
7	7	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
20	226011	--> fish_vcs_prompt
104	225991	---> fish_git_prompt $argv
12	50916	----> if not command -sq git...
50904	50904	-----> not command -sq git
5	36	----> if functions -q __fish_git_prompt_ready...
31	31	-----> functions -q __fish_git_prompt_ready
135	59288	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
59153	59153	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
59	57812	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	57753	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
5	5	------> set -l branch
4	4	------> set -l operation
5	5	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
30	83	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
6	41	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
11	57511	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
5	57496	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
103	57491	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57388	57388	---------> command git symbolic-ref HEAD 2>/dev/null
2	25	------> if test true = $inside_gitdir...
23	23	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
10	10	----> set -l r $rbc[1]
8	8	----> set -l b $rbc[2]
11	11	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
7	7	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
4	12	----> if not set -q ___fish_git_prompt_init...
8	8	-----> not set -q ___fish_git_prompt_init
24	24	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
51051	57210	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6159	6159	-----> read -lz key value
8	50	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
24	24	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
3	16	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	78	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
7	51	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
5	13	------> begin...
8	8	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	10	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
9	9	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	45	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
63	85	----> set b (string replace refs/heads/ '' -- $b)
22	22	-----> string replace refs/heads/ '' -- $b
1	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
24	24	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
8	34	----> if test -n "$b"...
5	5	-----> test -n "$b"
6	6	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
2	5	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
29	29	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
9	668	> fish_title
10	659	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
5	635	--> if set -q argv[1]...
3	3	---> set -q argv[1]
39	45	---> set -l command (status current-command)
6	6	----> status current-command
2	14	---> if test "$command" = fish...
7	7	----> test "$command" = fish
5	5	----> set command
73	568	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
23	486	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
9	9	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
17	386	-----> for path in $argv...
54	66	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
59	84	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
25	25	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	219	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	130	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
43	106	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
46	63	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
48	67	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
48	72	> __fish_disable_bracketed_paste 'git pull -v'
24	24	-> printf "\e[?2004l"
14	612	> fish_title git\ pull\ -v
9	598	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
4	4	--> set -q SSH_TTY
5	570	--> if set -q argv[1]...
6	6	---> set -q argv[1]
87	559	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
13	13	----> string sub -l 20 -- $argv[1]
28	459	----> prompt_pwd -d 1 -D 1
9	9	-----> set -l options h/help d/dir-length= D/full-length-dirs=
25	25	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	355	-----> for path in $argv...
45	56	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
50	78	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
28	28	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	208	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	122	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	99	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
43	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
6	6	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	63	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
18979341	18979341	> git pull -v
295	410	> fish_job_summary 1 1 'git pull -v' SIGINT 'Quit request from job control (^C)'
20	115	-> if test "$signal_or_end_name" = SIGINT...
63	63	--> test "$signal_or_end_name" = SIGINT
23	23	--> test $is_foreground -eq 1
9	9	--> return
32	145	> __fish_enable_bracketed_paste
113	113	-> printf "\e[?2004h"
34	225	> fish_mode_prompt
101	191	-> fish_default_mode_prompt
26	90	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
44	44	---> test "$fish_key_bindings" = fish_vi_key_bindings
20	20	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
110	237586	> fish_prompt
49	49	-> set -l last_status $status
340	455	-> set -l normal (set_color normal)
115	115	--> set_color normal
243	324	-> set -l status_color (set_color brgreen)
81	81	--> set_color brgreen
256	349	-> set -l cwd_color (set_color $fish_color_cwd)
93	93	--> set_color $fish_color_cwd
143	173	-> set -l vcs_color (set_color brpurple)
30	30	--> set_color brpurple
19	19	-> set -l prompt_status ""
12	12	-> set -q fish_prompt_pwd_dir_length
15	15	-> set -lx fish_prompt_pwd_dir_length 0
15	15	-> set -l suffix '❯'
7	441	-> if functions -q fish_is_root_user...
180	180	--> functions -q fish_is_root_user
40	254	--> fish_is_root_user
5	126	---> if test "$EUID" = 0 2>/dev/null...
121	121	----> test "$EUID" = 0 2>/dev/null
8	79	---> if contains -- $USER root toor Administrator...
71	71	----> contains -- $USER root toor Administrator
9	9	---> return 1
13	259	-> if test $last_status -ne 0...
15	15	--> test $last_status -ne 0
174	198	--> set status_color (set_color $fish_color_error)
24	24	---> set_color $fish_color_error
33	33	--> set prompt_status $status_color "[" $last_status "]" $normal
373	235352	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
97	1042	--> prompt_login
3	19	---> if not set -q __fish_machine...
16	16	----> not set -q __fish_machine
2	14	---> if set -q __fish_machine[1]...
12	12	----> set -q __fish_machine[1]
18	18	---> set -l color_host $fish_color_host
2	10	---> if set -q SSH_TTY...
8	8	----> set -q SSH_TTY
616	884	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
30	30	----> set_color $fish_color_user
18	18	----> set_color normal
25	25	----> set_color $color_host
97	155	----> prompt_hostname
58	58	-----> string replace -r -- "\..*" "" $hostname
40	40	----> set_color normal
150	775	--> prompt_pwd
28	28	---> set -l options h/help d/dir-length= D/full-length-dirs=
35	35	---> argparse -n prompt_pwd $options -- $argv
4	14	---> if set -q _flag_help...
10	10	----> set -q _flag_help
8	8	---> set -q argv[1]
15	15	---> set argv $PWD
8	8	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
8	8	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
44	473	---> for path in $argv...
148	176	----> set -l realhome (string escape --style=regex -- ~)
28	28	-----> string escape --style=regex -- ~
115	199	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
84	84	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
13	54	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
23	23	-----> test "$fish_prompt_pwd_dir_length" -eq 0
18	18	-----> echo $tmp
143	233162	--> fish_vcs_prompt
154	233019	---> fish_git_prompt $argv
12	61187	----> if not command -sq git...
61175	61175	-----> not command -sq git
3	78	----> if functions -q __fish_git_prompt_ready...
75	75	-----> functions -q __fish_git_prompt_ready
134	56530	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56396	56396	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
25	25	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
8	8	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
59	57257	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
49	57198	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
7	7	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
26	76	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	39	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	11	------> if test -n "$step" -a -n "$total"...
10	10	-------> test -n "$step" -a -n "$total"
8	56968	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
2	56956	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
84	56954	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56870	56870	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
5	5	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
19	19	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50494	57218	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6724	6724	-----> read -lz key value
8	43	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
5	16	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	78	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	46	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
4	12	------> begin...
8	8	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
3	3	-------> test "$dirty" = true
1	6	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
5	16	-----> if set -q __fish_git_prompt_showupstream...
3	3	------> set -q __fish_git_prompt_showupstream
8	8	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
66	78	----> set b (string replace refs/heads/ '' -- $b)
12	12	-----> string replace refs/heads/ '' -- $b
1	24	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	31	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
5	5	-----> test -z "$format"
4	4	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
13	13	-> echo -n -s $status_color $suffix ' ' $normal
13	732	> fish_title
8	719	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
14	697	--> if set -q argv[1]...
3	3	---> set -q argv[1]
39	44	---> set -l command (status current-command)
5	5	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
76	624	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
9	9	----> string sub -l 20 -- $command
26	539	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
20	20	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
22	22	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
32	32	-----> set -q fish_prompt_pwd_full_dirs
21	396	-----> for path in $argv...
54	68	------> set -l realhome (string escape --style=regex -- ~)
14	14	-------> string escape --style=regex -- ~
40	63	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	244	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
9	159	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
44	132	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
44	88	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
44	44	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
42	62	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
42	668	> __fish_git_using_command upload-pack
72	554	-> set -l cmd (__fish_git_needs_command)
38	482	--> __fish_git_needs_command
80	127	---> set -l cmdline "$(commandline -c)"
47	47	----> commandline -c
5	22	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
9	9	---> set -g __fish_git_cmdline $cmdline
43	53	---> set -l cmd (commandline -opc)
10	10	----> commandline -opc
7	7	---> set -e cmd[1]
132	178	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
12	46	----> __fish_git_global_optspecs
34	34	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
7	7	---> set -q _flag_version
3	3	---> set -q _flag_html_path
3	3	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
8	32	---> if set -q argv[1]...
3	3	----> set -q argv[1]
10	10	----> set -g __fish_git_cmd $argv[1]
8	8	----> echo $argv[1]
3	3	----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
40	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	245	> __fish_git_using_command upload-archive
54	161	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	252	> __fish_git_using_command shell
52	162	-> set -l cmd (__fish_git_needs_command)
12	110	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
41	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	233	> __fish_git_using_command receive-pack
52	154	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	245	> __fish_git_using_command flow
52	156	-> set -l cmd (__fish_git_needs_command)
10	104	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
12	12	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
22	242	> __fish_git_using_command cvsserver
51	157	-> set -l cmd (__fish_git_needs_command)
9	106	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
11	39	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
9	103	> __fish_git_needs_command
52	58	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
6	36	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
9	9	--> test "$cmdline" = "$__fish_git_cmdline"
6	17	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
6	6	---> echo -- $__fish_git_cmd
2	2	---> return 1
48	121	> __fish_seen_subcommand_from branch for-each-ref tag
37	45	-> set -l cmd (commandline -poc)
8	8	--> commandline -poc
6	6	-> set -e cmd[1]
8	19	-> for i in $cmd...
2	11	--> if contains -- $i $argv...
9	9	---> contains -- $i $argv
3	3	-> return 1
19	251	> __fish_git_using_command for-each-ref
54	169	-> set -l cmd (__fish_git_needs_command)
11	115	--> __fish_git_needs_command
55	65	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
9	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	245	> __fish_git_using_command config
52	157	-> set -l cmd (__fish_git_needs_command)
9	105	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
42	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	235	> __fish_git_using_command help
51	156	-> set -l cmd (__fish_git_needs_command)
9	105	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	38	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	243	> __fish_git_using_command blame
52	158	-> set -l cmd (__fish_git_needs_command)
8	106	--> __fish_git_needs_command
53	58	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
10	40	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
12	12	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	243	> __fish_git_using_command clean
53	166	-> set -l cmd (__fish_git_needs_command)
10	113	--> __fish_git_needs_command
58	64	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	235	> __fish_git_using_command submodule
51	155	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	240	> __fish_git_using_command format-patch
54	156	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	59	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
40	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	250	> __fish_git_using_command format-patch log
52	169	-> set -l cmd (__fish_git_needs_command)
8	117	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	48	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
13	28	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	230	> __fish_git_using_command stash
51	153	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
15	232	> __fish_git_using_command worktree
52	157	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	224	> __fish_git_using_command update-index
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	229	> __fish_git_using_command tag
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	227	> __fish_git_using_command stripspace
52	148	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command status
50	148	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	224	> __fish_git_using_command rm
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	239	> __fish_git_using_command revert
51	150	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
43	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
2	2	-> return 1
22	246	> __fish_git_using_command rev-parse
54	159	-> set -l cmd (__fish_git_needs_command)
10	105	--> __fish_git_needs_command
52	60	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	235	> __fish_git_using_command restore switch
53	155	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	228	> __fish_git_using_command switch
49	149	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	236	> __fish_git_using_command restore
53	157	-> set -l cmd (__fish_git_needs_command)
9	104	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	226	> __fish_git_using_command reset
50	150	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	231	> __fish_git_using_command reflog
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
9	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	227	> __fish_git_using_command rebase
50	149	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command push
51	149	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
15	235	> __fish_git_using_command range-diff
52	155	-> set -l cmd (__fish_git_needs_command)
10	103	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
9	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
17	240	> __fish_git_using_command pull
52	158	-> set -l cmd (__fish_git_needs_command)
11	106	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	240	> __fish_git_using_command prune
54	157	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	234	> __fish_git_using_command notes
53	153	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	243	> __fish_git_using_command mv
52	167	-> set -l cmd (__fish_git_needs_command)
10	115	--> __fish_git_needs_command
66	72	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
2	2	-> return 1
18	226	> __fish_git_using_command mergetool
52	150	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	234	> __fish_git_using_command merge-base
50	151	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	224	> __fish_git_using_command merge
50	148	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command maintenance
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	228	> __fish_git_using_command mailsplit
51	148	-> set -l cmd (__fish_git_needs_command)
10	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	232	> __fish_git_using_command mailsplit am
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	236	> __fish_git_using_command mailinfo
52	156	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	39	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	235	> __fish_git_using_command mailinfo am
51	154	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	227	> __fish_git_using_command ls-files
51	151	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	232	> __fish_git_using_command log
52	150	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
16	224	> __fish_git_using_command init
51	148	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	234	> __fish_git_using_command grep
51	153	-> set -l cmd (__fish_git_needs_command)
11	102	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	222	> __fish_git_using_command gc
51	148	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	236	> __fish_git_using_command difftool
54	159	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	226	> __fish_git_using_command diff
52	151	-> set -l cmd (__fish_git_needs_command)
11	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	228	> __fish_git_using_command describe
49	152	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
52	60	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	226	> __fish_git_using_command daemon
53	150	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	230	> __fish_git_using_command count-objects
50	152	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
50	58	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	225	> __fish_git_using_command commit
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command clone
51	153	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
50	59	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
21	233	> __fish_git_using_command cherry-pick
50	155	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
14	42	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	220	> __fish_git_using_command cherry
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	224	> __fish_git_using_command bundle
52	147	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
16	223	> __fish_git_using_command branch
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	220	> __fish_git_using_command bisect
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	227	> __fish_git_using_command archive
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	220	> __fish_git_using_command apply
52	147	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	232	> __fish_git_using_command apply am
50	153	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	224	> __fish_git_using_command checkout
51	149	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command am
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command add
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	222	> __fish_git_using_command show-branch
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
15	221	> __fish_git_using_command show
50	146	-> set -l cmd (__fish_git_needs_command)
9	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	32	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
8	254	> __fish_git_needs_rev_files
33	246	-> __fish_git_using_command show
52	155	--> set -l cmd (__fish_git_needs_command)
9	103	---> __fish_git_needs_command
54	60	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
7	34	----> if set -q __fish_git_cmdline...
3	3	-----> set -q __fish_git_cmdline
7	7	-----> test "$cmdline" = "$__fish_git_cmdline"
5	17	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
6	6	------> echo -- $__fish_git_cmd
3	3	------> return 1
5	5	--> test -z "$cmd"
5	5	--> contains -- $cmd $argv
34	41	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	---> string escape --style=var -- $cmd
5	5	--> set -q $varname
2	2	--> return 1
12	180	> __fish_git_using_command remote
55	154	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
3	3	-> return 0
17	80	> __fish_seen_subcommand_from update
32	39	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
5	5	-> set -e cmd[1]
8	16	-> for i in $cmd...
1	8	--> if contains -- $i $argv...
7	7	---> contains -- $i $argv
3	3	-> return 1
15	75	> __fish_seen_subcommand_from prune
33	39	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
5	5	-> set -e cmd[1]
6	13	-> for i in $cmd...
2	7	--> if contains -- $i $argv...
5	5	---> contains -- $i $argv
3	3	-> return 1
15	73	> __fish_seen_subcommand_from show
34	40	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
4	4	-> set -e cmd[1]
4	12	-> for i in $cmd...
2	8	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
2	2	-> return 1
13	75	> __fish_seen_subcommand_from get-url
34	40	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
5	5	-> set -e cmd[1]
7	14	-> for i in $cmd...
1	7	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
3	3	-> return 1
14	72	> __fish_seen_subcommand_from set-url
33	39	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
4	4	-> set -e cmd[1]
5	13	-> for i in $cmd...
2	8	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
2	2	-> return 1
13	75	> __fish_seen_subcommand_from set-branches
32	38	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
5	5	-> set -e cmd[1]
9	16	-> for i in $cmd...
1	7	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
3	3	-> return 1
13	71	> __fish_seen_subcommand_from remove
33	39	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
4	4	-> set -e cmd[1]
6	13	-> for i in $cmd...
2	7	--> if contains -- $i $argv...
5	5	---> contains -- $i $argv
2	2	-> return 1
13	73	> __fish_seen_subcommand_from add
33	39	-> set -l cmd (commandline -poc)
6	6	--> commandline -poc
5	5	-> set -e cmd[1]
6	13	-> for i in $cmd...
1	7	--> if contains -- $i $argv...
6	6	---> contains -- $i $argv
3	3	-> return 1
22	89	> not __fish_seen_subcommand_from add rm remove show prune update rename set-head set-url set-branches get-url
34	41	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
4	4	-> set -e cmd[1]
5	19	-> for i in $cmd...
2	14	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
3	3	-> return 1
20	97	> __fish_seen_subcommand_from add rm remove show prune update rename set-head set-url set-branches get-url
41	48	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
5	5	-> set -e cmd[1]
6	21	-> for i in $cmd...
3	15	--> if contains -- $i $argv...
12	12	---> contains -- $i $argv
3	3	-> return 1
19	247	> __fish_git_using_command filter-branch
53	160	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	256	> __fish_git_using_command fetch
52	177	-> set -l cmd (__fish_git_needs_command)
8	125	--> __fish_git_needs_command
73	79	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	38	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	227	> __fish_git_using_command fetch pull
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	232	> __fish_git_using_command diff log show range-diff
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	226	> __fish_git_using_command diff show range-diff
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
31	292	> __fish_git_using_command diff show range-diff apply
60	187	-> set -l cmd (__fish_git_needs_command)
12	127	--> __fish_git_needs_command
62	73	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
7	42	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
41	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
18	238	> __fish_git_using_command log show diff-tree rev-list
52	155	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
134	2355	> __fish_start_bracketed_paste
227	227	-> set -g __fish_last_bind_mode $fish_bind_mode
433	1994	-> string match -q 'single*' (__fish_tokenizer_state -- (commandline -ct | string collect))
585	1561	--> __fish_tokenizer_state -- (commandline -ct | string collect)
230	230	---> commandline -ct | string collect
74	74	---> argparse --min-args 1 --max-args 1 i/initial-state= -- $argv
43	43	---> set -l state normal
39	147	---> if set -q _flag_initial_state...
108	108	----> set -q _flag_initial_state
308	439	---> for char in (string split -- "" $argv[1])...
64	64	----> string split -- "" $argv[1]
41	67	----> switch $char...
26	26	-----> switch $state...
43	43	---> echo $state
118	248	> __fish_stop_bracketed_paste
83	83	-> set fish_bind_mode $__fish_last_bind_mode
47	47	-> set -e __fish_paste_quoted
99	161	> __fish_disable_bracketed_paste 'git remote set-url origin https://github.com/mostlymaxi/franz.git'
62	62	-> printf "\e[?2004l"
62	2413	> fish_title git\ remote\ set-url\ origin\ https://github.com/mostlymaxi/franz.git
35	2351	-> if not set -q INSIDE_EMACS...
34	34	--> not set -q INSIDE_EMACS
27	27	--> set -l ssh
17	17	--> set -q SSH_TTY
24	2238	--> if set -q argv[1]...
16	16	---> set -q argv[1]
479	2198	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
51	51	----> string sub -l 20 -- $argv[1]
78	1668	----> prompt_pwd -d 1 -D 1
24	24	-----> set -l options h/help d/dir-length= D/full-length-dirs=
62	62	-----> argparse -n prompt_pwd $options -- $argv
3	15	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
9	9	-----> set -q argv[1]
18	18	-----> set argv $PWD
9	9	-----> set -ql _flag_d
19	19	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
16	16	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
9	9	-----> set -q fish_prompt_pwd_full_dirs
42	1378	-----> for path in $argv...
177	208	------> set -l realhome (string escape --style=regex -- ~)
31	31	-------> string escape --style=regex -- ~
168	243	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
75	75	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
42	885	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
18	382	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
17	17	--------> test $fish_prompt_pwd_full_dirs -gt 0
118	311	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
154	193	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
39	39	----------> math $fish_prompt_pwd_full_dirs - 1
21	21	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
184	418	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
234	234	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
76974	76974	> git remote set-url origin https://github.com/mostlymaxi/franz.git
34	68	> __fish_enable_bracketed_paste
34	34	-> printf "\e[?2004h"
12	57	> fish_mode_prompt
16	45	-> fish_default_mode_prompt
4	29	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
37	224040	> fish_prompt
13	13	-> set -l last_status $status
42	56	-> set -l normal (set_color normal)
14	14	--> set_color normal
61	70	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
63	77	-> set -l cwd_color (set_color $fish_color_cwd)
14	14	--> set_color $fish_color_cwd
43	53	-> set -l vcs_color (set_color brpurple)
10	10	--> set_color brpurple
7	7	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
4	4	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
5	85	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
15	70	--> fish_is_root_user
3	39	---> if test "$EUID" = 0 2>/dev/null...
36	36	----> test "$EUID" = 0 2>/dev/null
2	12	---> if contains -- $USER root toor Administrator...
10	10	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
126	223608	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
16	280	--> prompt_login
1	8	---> if not set -q __fish_machine...
7	7	----> not set -q __fish_machine
0	4	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
166	239	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
7	7	----> set_color normal
8	8	----> set_color $color_host
14	40	----> prompt_hostname
26	26	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
23	245	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
13	13	---> argparse -n prompt_pwd $options -- $argv
2	5	---> if set -q _flag_help...
3	3	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
15	165	---> for path in $argv...
42	53	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
43	75	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
32	32	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	22	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
13	222957	--> fish_vcs_prompt
115	222944	---> fish_git_prompt $argv
10	51957	----> if not command -sq git...
51947	51947	-----> not command -sq git
3	31	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
155	56398	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56243	56243	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
19	19	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
65	57460	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	57395	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
26	94	------> if test -d $git_dir/rebase-merge...
15	15	-------> test -d $git_dir/rebase-merge
8	53	-------> if test -d $git_dir/rebase-apply...
10	10	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
10	10	--------> test -f $git_dir/CHERRY_PICK_HEAD
9	9	--------> test -f $git_dir/REVERT_HEAD
7	7	--------> test -f $git_dir/BISECT_LOG
1	12	------> if test -n "$step" -a -n "$total"...
11	11	-------> test -n "$step" -a -n "$total"
12	57148	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	57132	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
101	57128	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57027	57027	---------> command git symbolic-ref HEAD 2>/dev/null
1	18	------> if test true = $inside_gitdir...
17	17	-------> test true = $inside_gitdir
13	13	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
29	29	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
50318	56318	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6000	6000	-----> read -lz key value
7	47	----> if not set -q dirty[1]...
20	20	-----> not set -q dirty[1]
20	20	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
24	24	----> contains dirtystate $__fish_git_prompt_status_order
3	17	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
9	9	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	74	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
5	15	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	45	----> for i in $__fish_git_prompt_status_order...
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
101	115	----> set b (string replace refs/heads/ '' -- $b)
14	14	-----> string replace refs/heads/ '' -- $b
2	30	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
28	28	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	40	----> if test -n "$b"...
7	7	-----> test -n "$b"
11	11	-----> set b "$branch_color$b$branch_done"
2	17	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
8	8	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
5	5	-----> test -z "$format"
5	5	-----> set format " (%s)"
35	35	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	628	> fish_title
6	618	-> if not set -q INSIDE_EMACS...
7	7	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
6	597	--> if set -q argv[1]...
4	4	---> set -q argv[1]
37	42	---> set -l command (status current-command)
5	5	----> status current-command
2	13	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
69	532	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
22	456	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
23	23	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
13	360	-----> for path in $argv...
37	47	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
39	59	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	241	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
8	141	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
50	114	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
48	64	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
9	9	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
56	80	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
24	24	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
29	47	> __fish_disable_bracketed_paste 'git pull -v'
18	18	-> printf "\e[?2004l"
13	1063	> fish_title git\ pull\ -v
8	1050	-> if not set -q INSIDE_EMACS...
44	44	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
4	4	--> set -q SSH_TTY
4	987	--> if set -q argv[1]...
5	5	---> set -q argv[1]
182	978	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
42	42	----> string sub -l 20 -- $argv[1]
63	754	----> prompt_pwd -d 1 -D 1
40	40	-----> set -l options h/help d/dir-length= D/full-length-dirs=
26	26	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
4	4	-----> set -q fish_prompt_pwd_full_dirs
60	577	-----> for path in $argv...
55	67	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
73	100	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
69	350	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	157	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
71	131	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
45	60	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
51	108	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
57	57	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
6368947	6368947	> git pull -v
28	98	> __fish_enable_bracketed_paste
70	70	-> printf "\e[?2004h"
14	99	> fish_mode_prompt
48	85	-> fish_default_mode_prompt
4	37	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
25	25	---> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
79	225693	> fish_prompt
15	15	-> set -l last_status $status
56	93	-> set -l normal (set_color normal)
37	37	--> set_color normal
105	116	-> set -l status_color (set_color brgreen)
11	11	--> set_color brgreen
85	95	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
92	99	-> set -l vcs_color (set_color brpurple)
7	7	--> set_color brpurple
5	5	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
2	138	-> if functions -q fish_is_root_user...
52	52	--> functions -q fish_is_root_user
15	84	--> fish_is_root_user
1	34	---> if test "$EUID" = 0 2>/dev/null...
33	33	----> test "$EUID" = 0 2>/dev/null
3	31	---> if contains -- $USER root toor Administrator...
28	28	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
177	225019	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
44	468	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
270	400	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
16	16	----> set_color normal
11	11	----> set_color $color_host
53	85	----> prompt_hostname
32	32	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
69	359	--> prompt_pwd
14	14	---> set -l options h/help d/dir-length= D/full-length-dirs=
18	18	---> argparse -n prompt_pwd $options -- $argv
1	6	---> if set -q _flag_help...
5	5	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
55	222	---> for path in $argv...
45	57	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
58	91	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
33	33	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
3	19	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
42	224015	--> fish_vcs_prompt
116	223973	---> fish_git_prompt $argv
11	51622	----> if not command -sq git...
51611	51611	-----> not command -sq git
4	84	----> if functions -q __fish_git_prompt_ready...
80	80	-----> functions -q __fish_git_prompt_ready
130	56622	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56492	56492	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
22	22	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
58	58425	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
47	58367	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
3	3	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	92	------> if test -d $git_dir/rebase-merge...
16	16	-------> test -d $git_dir/rebase-merge
5	52	-------> if test -d $git_dir/rebase-apply...
12	12	--------> test -d $git_dir/rebase-apply
9	9	--------> test -f $git_dir/MERGE_HEAD
9	9	--------> test -f $git_dir/CHERRY_PICK_HEAD
9	9	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	58127	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	58115	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
89	58112	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58023	58023	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
5	5	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
12	12	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
5	5	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
19	19	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50646	56518	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5872	5872	-----> read -lz key value
10	42	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
2	15	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	75	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	9	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	14	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
2	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
6	16	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
16	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
58	71	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
1	27	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
26	26	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	31	----> if test -n "$b"...
5	5	-----> test -n "$b"
6	6	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
2	5	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	635	> fish_title
8	625	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
10	603	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	43	---> set -l command (status current-command)
6	6	----> status current-command
5	15	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
72	532	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
27	453	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
22	22	-----> argparse -n prompt_pwd $options -- $argv
0	4	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
16	358	-----> for path in $argv...
39	49	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
38	58	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
10	235	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
5	139	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	117	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
39	77	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
38	38	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
55	74	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
24	83	> __fish_enable_bracketed_paste
59	59	-> printf "\e[?2004h"
9	72	> fish_mode_prompt
18	63	-> fish_default_mode_prompt
7	45	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
32	32	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
40	225042	> fish_prompt
39	39	-> set -l last_status $status
117	149	-> set -l normal (set_color normal)
32	32	--> set_color normal
81	97	-> set -l status_color (set_color brgreen)
16	16	--> set_color brgreen
74	89	-> set -l cwd_color (set_color $fish_color_cwd)
15	15	--> set_color $fish_color_cwd
56	69	-> set -l vcs_color (set_color brpurple)
13	13	--> set_color brpurple
8	8	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	119	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
13	106	--> fish_is_root_user
2	48	---> if test "$EUID" = 0 2>/dev/null...
46	46	----> test "$EUID" = 0 2>/dev/null
2	41	---> if contains -- $USER root toor Administrator...
39	39	----> contains -- $USER root toor Administrator
4	4	---> return 1
0	8	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
123	224392	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
19	329	--> prompt_login
1	7	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	5	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
9	9	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
203	285	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
13	13	----> set_color normal
10	10	----> set_color $color_host
14	41	----> prompt_hostname
27	27	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
23	254	--> prompt_pwd
14	14	---> set -l options h/help d/dir-length= D/full-length-dirs=
16	16	---> argparse -n prompt_pwd $options -- $argv
4	8	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
7	7	---> set argv $PWD
2	2	---> set -ql _flag_d
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
15	162	---> for path in $argv...
43	60	----> set -l realhome (string escape --style=regex -- ~)
17	17	-----> string escape --style=regex -- ~
43	67	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
24	24	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	20	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
11	223686	--> fish_vcs_prompt
87	223675	---> fish_git_prompt $argv
12	51711	----> if not command -sq git...
51699	51699	-----> not command -sq git
1	28	----> if functions -q __fish_git_prompt_ready...
27	27	-----> functions -q __fish_git_prompt_ready
133	56234	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56101	56101	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
57	57551	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
36	57494	-----> __fish_git_prompt_operation_branch_bare $repo_info
7	7	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
8	8	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	73	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	39	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
12	57277	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	57261	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
85	57258	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
57173	57173	---------> command git symbolic-ref HEAD 2>/dev/null
2	19	------> if test true = $inside_gitdir...
17	17	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
3	3	----> set -l stagedstate
5	5	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
4	4	----> set -q __fish_git_prompt_status_order
1	5	----> if not set -q ___fish_git_prompt_init...
4	4	-----> not set -q ___fish_git_prompt_init
17	17	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
51699	57511	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5812	5812	-----> read -lz key value
5	39	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
2	14	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	70	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
6	43	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
1	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
15	45	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
61	78	----> set b (string replace refs/heads/ '' -- $b)
17	17	-----> string replace refs/heads/ '' -- $b
1	20	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
19	19	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
3	29	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	14	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
5	5	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
26	26	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
17	17	-> echo -n -s $status_color $suffix ' ' $normal
10	633	> fish_title
7	623	-> if not set -q INSIDE_EMACS...
5	5	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
6	602	--> if set -q argv[1]...
3	3	---> set -q argv[1]
36	42	---> set -l command (status current-command)
6	6	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
86	538	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
31	445	----> prompt_pwd -d 1 -D 1
11	11	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	334	-----> for path in $argv...
45	56	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
40	67	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	196	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	116	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
38	92	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
41	54	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
13	13	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	60	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
41	664	> __fish_git_using_command upload-pack
77	549	-> set -l cmd (__fish_git_needs_command)
35	472	--> __fish_git_needs_command
82	135	---> set -l cmdline "$(commandline -c)"
53	53	----> commandline -c
6	23	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
10	10	---> set -g __fish_git_cmdline $cmdline
41	50	---> set -l cmd (commandline -opc)
9	9	----> commandline -opc
7	7	---> set -e cmd[1]
127	166	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	39	----> __fish_git_global_optspecs
28	28	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
6	6	---> set -q _flag_version
4	4	---> set -q _flag_html_path
2	2	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
8	31	---> if set -q argv[1]...
3	3	----> set -q argv[1]
9	9	----> set -g __fish_git_cmd $argv[1]
7	7	----> echo $argv[1]
4	4	----> return 1
7	7	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
40	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
17	245	> __fish_git_using_command upload-archive
54	160	-> set -l cmd (__fish_git_needs_command)
9	106	--> __fish_git_needs_command
53	60	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
40	48	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
15	232	> __fish_git_using_command shell
52	153	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	239	> __fish_git_using_command receive-pack
53	156	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	233	> __fish_git_using_command flow
53	156	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
11	38	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	226	> __fish_git_using_command cvsserver
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
9	97	> __fish_git_needs_command
49	55	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
7	33	-> if set -q __fish_git_cmdline...
3	3	--> set -q __fish_git_cmdline
7	7	--> test "$cmdline" = "$__fish_git_cmdline"
6	16	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
5	5	---> echo -- $__fish_git_cmd
2	2	---> return 1
50	121	> __fish_seen_subcommand_from branch for-each-ref tag
38	45	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
5	5	-> set -e cmd[1]
8	18	-> for i in $cmd...
2	10	--> if contains -- $i $argv...
8	8	---> contains -- $i $argv
3	3	-> return 1
18	229	> __fish_git_using_command for-each-ref
53	152	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	225	> __fish_git_using_command config
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command help
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
2	2	-> return 1
21	229	> __fish_git_using_command blame
50	150	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	247	> __fish_git_using_command clean
60	162	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	230	> __fish_git_using_command submodule
51	153	-> set -l cmd (__fish_git_needs_command)
11	102	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	238	> __fish_git_using_command format-patch
53	159	-> set -l cmd (__fish_git_needs_command)
9	106	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	233	> __fish_git_using_command format-patch log
52	151	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command stash
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
49	57	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
21	228	> __fish_git_using_command worktree
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	226	> __fish_git_using_command update-index
53	151	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	227	> __fish_git_using_command tag
51	151	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	221	> __fish_git_using_command stripspace
51	147	-> set -l cmd (__fish_git_needs_command)
7	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	220	> __fish_git_using_command status
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	223	> __fish_git_using_command rm
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
9	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	224	> __fish_git_using_command revert
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	314	> __fish_git_using_command rev-parse
68	223	-> set -l cmd (__fish_git_needs_command)
19	155	--> __fish_git_needs_command
80	92	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
7	44	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
40	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	244	> __fish_git_using_command restore switch
51	160	-> set -l cmd (__fish_git_needs_command)
10	109	--> __fish_git_needs_command
57	64	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	228	> __fish_git_using_command switch
52	150	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	231	> __fish_git_using_command restore
51	154	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	229	> __fish_git_using_command reset
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	222	> __fish_git_using_command reflog
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	227	> __fish_git_using_command rebase
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
16	222	> __fish_git_using_command push
52	147	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	32	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
24	229	> __fish_git_using_command range-diff
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	231	> __fish_git_using_command pull
50	145	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
49	54	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
42	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
21	304	> __fish_git_using_command prune
58	195	-> set -l cmd (__fish_git_needs_command)
12	137	--> __fish_git_needs_command
65	72	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	53	---> if set -q __fish_git_cmdline...
10	10	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
6	23	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
55	64	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
21	264	> __fish_git_using_command notes
53	174	-> set -l cmd (__fish_git_needs_command)
11	121	--> __fish_git_needs_command
54	66	---> set -l cmdline "$(commandline -c)"
12	12	----> commandline -c
9	44	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	20	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	47	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
21	246	> __fish_git_using_command mv
54	163	-> set -l cmd (__fish_git_needs_command)
14	109	--> __fish_git_needs_command
52	59	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
15	237	> __fish_git_using_command mergetool
50	155	-> set -l cmd (__fish_git_needs_command)
9	105	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
17	235	> __fish_git_using_command merge-base
52	158	-> set -l cmd (__fish_git_needs_command)
8	106	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
11	40	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	247	> __fish_git_using_command merge
71	171	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	226	> __fish_git_using_command maintenance
52	151	-> set -l cmd (__fish_git_needs_command)
10	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
20	252	> __fish_git_using_command mailsplit
55	168	-> set -l cmd (__fish_git_needs_command)
10	113	--> __fish_git_needs_command
55	65	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
9	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	236	> __fish_git_using_command mailsplit am
50	157	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
52	61	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
5	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	234	> __fish_git_using_command mailinfo
53	156	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	38	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
10	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	231	> __fish_git_using_command mailinfo am
51	153	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	286	> __fish_git_using_command ls-files
51	156	-> set -l cmd (__fish_git_needs_command)
9	105	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	40	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
9	9	-> test -z "$cmd"
14	14	-> contains -- $cmd $argv
70	81	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
24	282	> __fish_git_using_command log
63	183	-> set -l cmd (__fish_git_needs_command)
9	120	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
12	49	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
13	13	----> test "$cmdline" = "$__fish_git_cmdline"
9	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
8	8	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
44	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
17	352	> __fish_git_using_command init
53	268	-> set -l cmd (__fish_git_needs_command)
36	215	--> __fish_git_needs_command
117	142	---> set -l cmdline "$(commandline -c)"
25	25	----> commandline -c
7	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
21	291	> __fish_git_using_command grep
57	203	-> set -l cmd (__fish_git_needs_command)
11	146	--> __fish_git_needs_command
88	94	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	41	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
42	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	231	> __fish_git_using_command gc
52	153	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	241	> __fish_git_using_command difftool
51	156	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
55	61	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
40	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	231	> __fish_git_using_command diff
52	150	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	233	> __fish_git_using_command describe
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
15	15	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	229	> __fish_git_using_command daemon
49	149	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	222	> __fish_git_using_command count-objects
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	222	> __fish_git_using_command commit
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	226	> __fish_git_using_command clone
50	150	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	223	> __fish_git_using_command cherry-pick
50	146	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	228	> __fish_git_using_command cherry
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
7	7	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	241	> __fish_git_using_command bundle
52	156	-> set -l cmd (__fish_git_needs_command)
8	104	--> __fish_git_needs_command
53	62	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
8	8	-> test -z "$cmd"
10	10	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	238	> __fish_git_using_command branch
52	157	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
10	10	----> test "$cmdline" = "$__fish_git_cmdline"
5	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
20	238	> __fish_git_using_command bisect
52	152	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
37	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	228	> __fish_git_using_command archive
50	149	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	230	> __fish_git_using_command apply
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
49	56	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
4	4	-> return 1
20	236	> __fish_git_using_command apply am
52	154	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	183	> __fish_git_using_command checkout
49	151	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
3	3	-> return 0
79	175085	> __fish_git_files modified deleted modified-staged-deleted
69	58050	-> set -l root (__fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null)
72	57981	--> __fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null
18	18	---> set -l saved_args $argv
6	6	---> set -l global_args
83	95	---> set -l cmd (commandline -opc)
12	12	----> commandline -opc
8	8	---> set -e cmd[1]
10	380	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
128	174	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
14	46	-----> __fish_git_global_optspecs
32	32	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
40	187	----> set -l num_global_args (math (count $cmd) - (count $argv))
77	147	-----> math (count $cmd) - (count $argv)
58	58	------> count $cmd
12	12	------> count $argv
1	9	----> if test $num_global_args -ne 0...
8	8	-----> test $num_global_args -ne 0
62	57402	---> eval command git $global_args \$saved_args 2>/dev/null
57340	57340	----> command git $saved_args
17	17	-> test "$root[2]" = true
6	6	-> set -e root[2]
12	12	-> contains -- all-staged $argv
7	7	-> contains -- unmerged $argv
5	5	-> contains -- added $argv
4	4	-> set -ql all_staged
5	5	-> contains -- modified $argv
5	5	-> set -l modified
6	6	-> set -l modified_desc "Modified file"
6	6	-> contains -- untracked $argv
6	6	-> contains -- modified-staged $argv
3	3	-> set -ql all_staged
5	5	-> contains -- modified-staged-deleted $argv
5	5	-> set -l modified_staged_deleted
10	10	-> set -l modified_staged_deleted_desc "Staged modified and deleted file"
6	6	-> contains -- deleted $argv
4	4	-> set -l deleted
5	5	-> set -l deleted_desc "Deleted file"
6	6	-> contains -- deleted-staged $argv
4	4	-> set -ql all_staged
5	5	-> contains -- ignored $argv
6	6	-> contains -- renamed $argv
5	5	-> contains -- copied $argv
5	5	-> set -l q '\\?'
2	7	-> if status test-feature qmark-noglob...
5	5	--> status test-feature qmark-noglob
6	6	-> set -l use_next
6	6	-> set -l status_opt --ignore-submodules=all
4	4	-> set -q ignored
4	4	-> set -q untracked
6	6	-> set -a status_opt -uno
6	6	-> set -l git_opt -c status.relativePaths -c core.quotePath=
94	57139	-> set -l ver (__fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2')
112	57045	--> __fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2'
10	10	---> set -l saved_args $argv
5	5	---> set -l global_args
38	49	---> set -l cmd (commandline -opc)
11	11	----> commandline -opc
5	5	---> set -e cmd[1]
8	291	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
106	151	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
14	45	-----> __fish_git_global_optspecs
31	31	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	124	----> set -l num_global_args (math (count $cmd) - (count $argv))
67	85	-----> math (count $cmd) - (count $argv)
12	12	------> count $cmd
6	6	------> count $argv
1	8	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
51	56573	---> eval command git $global_args \$saved_args 2>/dev/null
56522	56522	----> command git $saved_args
62	59630	-> if test "$ver[1]" -gt 2 2>/dev/null...
46	46	--> test "$ver[1]" -gt 2 2>/dev/null
28	28	--> test "$ver[1]" -eq 2 -a "$ver[2]" -ge 11 2>/dev/null
152	59494	--> __fish_git $git_opt status --porcelain=2 $status_opt \
            | while read -la -d ' ' line
            set -l file
            set -l desc
            # The basic status format is "XY", where X is "our" state (meaning the staging area),
            # and "Y" is "their" state.
            # A "." means it's unmodified.
            switch "$line[1..2]"
                case 'u *'
                    # Unmerged
                    # "Unmerged entries have the following format; the first character is a "u" to distinguish from ordinary changed entries."
                    # "u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>"
                    # This is first to distinguish it from normal modifications et al.
                    set -ql unmerged
                    and set file "$line[11..-1]"
                    and set desc $unmerged_desc
                case '2 .R*' '2 R.*'
                    # Renamed/Copied
                    # From the docs: "Renamed or copied entries have the following format:"
                    # "2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>"
                    # Since <sep> is \t, we can't really parse it unambiguously.
                    # The "-z" format would be great here!
                    set -ql renamed
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    and set desc $renamed_desc
                case '2 RM*' '2 RT*'
                    # Staged as renamed, with unstaged modifications (issue #6031)
                    set -ql renamed
                    or set -ql modified
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql modified
                    and set --append desc $modified_desc
                case '2 RD*'
                    # Staged as renamed, but deleted in the worktree
                    set -ql renamed
                    or set -ql deleted
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql deleted
                    and set --append desc $deleted_desc
                case '2 .C*' '2 C.*'
                    set -ql copied
                    and set file (string replace -r '\t[^\t].*' '' -- "$line[10..-1]")
                    and set desc $copied_desc
                case '1 A.*'
                    # Additions are only shown here if they are staged.
                    # Otherwise it's an untracked file.
                    set -ql added
                    and set file "$line[9..-1]"
                    and set desc $added_desc
                case '1 AD*'
                    # Added files that were since deleted
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql deleted
                        set file "$line[9..-1]"
                        set desc $deleted_desc
                    end
                case "1 AM*" "1 AT*"
                    # Added files with additional modifications
                    # ("T" is type-changed. As of git 2.33 this appears to be undocumented.
                    # it happens when e.g. a file is replaced with a symlink.
                    # For our purposes it's the same as modified)
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    end
                case '1 .A*'
                    # Files added with git add --intent-to-add.
                    set -ql untracked
                    and set file "$line[9..-1]"
                    and set desc $untracked_desc
                case '1 .M*' '1 .T*'
                    # Modified
                    # From the docs: "Ordinary changed entries have the following format:"
                    # "1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>"
                    # Since <path> can contain spaces, print from element 9 onwards
                    set -ql modified
                    and set file "$line[9..-1]"
                    and set desc $modified_desc
                case '1 MD*' '1 TD*'
                    set -ql modified_staged_deleted
                    and set file "$line[9..-1]"
                    and set desc $modified_staged_deleted_desc
                case '1 M.*' '1 T.*'
                    # If the character is first ("M."), then that means it's "our" change,
                    # which means it is staged.
                    # This is useless for many commands - e.g. `checkout` won't do anything with this.
                    # So it needs to be requested explicitly.
                    set -ql modified_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_modified_desc
                case '1 MM*' '1 MT*' '1 TM*' '1 TT*'
                    # Staged-modified with unstaged modifications
                    # These need to be offered for both kinds of modified.
                    if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    else if set -ql modified_staged
                        set file "$line[9..-1]"
                        set desc $staged_modified_desc
                    end
                case '1 .D*'
                    set -ql deleted
                    and set file "$line[9..-1]"
                    and set desc $deleted_desc
                case '1 D.*'
                    # TODO: The docs are unclear on this.
                    # There is both X unmodified and Y either M or D ("not updated")
                    # and Y is D and X is unmodified or [MARC] ("deleted in work tree").
                    # For our purposes, we assume this is a staged deletion.
                    set -ql deleted_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_deleted_desc
                case "$q"' *'
                    # Untracked
                    # "? <path>" - print from element 2 on.
                    set -ql untracked
                    and set file "$line[2..-1]"
                    and set desc $untracked_desc
                case '! *'
                    # Ignored
                    # "! <path>" - print from element 2 on.
                    set -ql ignored
                    and set file "$line[2..-1]"
                    and set desc $ignored_desc
            end
            # Only try printing if the file was selected.
            if set -q file[1]
                for d in $desc
                    # Without "-z", git sometimes _quotes_ filenames.
                    # It adds quotes around it _and_ escapes the character.
                    # e.g. `"a\\b"`.
                    # We just remove the quotes and hope it works out.
                    # If this contains newlines or tabs,
                    # there is nothing we can do, but that's a general issue with scripted completions.
                    set file (string trim -c \" -- $file)
                    # The relative filename.
                    if string match -q './*' -- (commandline -ct)
                        printf './%s\t%s\n' $file $d
                    else
                        printf '%s\t%s\n' "$file" $d
                    end
                    # Now from repo root.
                    # Only do this if the filename isn't a simple child,
                    # or the current token starts with ":"
                    if string match -q '../*' -- $file
                        or string match -q ':*' -- (commandline -ct)
                        set -l fromroot (builtin realpath -- $file 2>/dev/null)
                        # `:` starts pathspec "magic", and the second `:` terminates it.
                        # `/` is the magic letter for "from repo root".
                        # If we didn't terminate it we'd have to escape any special chars
                        # (non-alphanumeric, glob or regex special characters, in whatever dialect git uses)
                        and set fromroot (string replace -- "$root/" ":/:" "$fromroot")
                        and printf '%s\t%s\n' "$fromroot" $d
                    end
                end
            end
        end
17	17	---> set -l saved_args $argv
5	5	---> set -l global_args
53	66	---> set -l cmd (commandline -opc)
13	13	----> commandline -opc
6	6	---> set -e cmd[1]
8	323	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
101	139	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	38	-----> __fish_git_global_optspecs
27	27	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
47	166	----> set -l num_global_args (math (count $cmd) - (count $argv))
85	119	-----> math (count $cmd) - (count $argv)
14	14	------> count $cmd
20	20	------> count $argv
1	10	----> if test $num_global_args -ne 0...
9	9	-----> test $num_global_args -ne 0
69	58900	---> eval command git $global_args \$saved_args 2>/dev/null
58831	58831	----> command git $saved_args
25	25	---> read -la -d ' ' line
54	67	> not contains -- -- (commandline -opc)
13	13	-> commandline -opc
19	118651	> __fish_git_branches
56	58077	-> __fish_git for-each-ref --format='%(refname:strip=2)%09Local Branch' --sort=-committerdate refs/heads/ 2>/dev/null
17	17	--> set -l saved_args $argv
6	6	--> set -l global_args
41	52	--> set -l cmd (commandline -opc)
11	11	---> commandline -opc
7	7	--> set -e cmd[1]
8	282	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
98	140	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
13	42	----> __fish_git_global_optspecs
29	29	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
40	124	---> set -l num_global_args (math (count $cmd) - (count $argv))
67	84	----> math (count $cmd) - (count $argv)
10	10	-----> count $cmd
7	7	-----> count $argv
1	10	---> if test $num_global_args -ne 0...
9	9	----> test $num_global_args -ne 0
57	57657	--> eval command git $global_args \$saved_args 2>/dev/null
57600	57600	---> command git $saved_args
66	60555	-> __fish_git for-each-ref --format='%(refname:strip=2)%09Remote Branch' refs/remotes/ 2>/dev/null
18	18	--> set -l saved_args $argv
5	5	--> set -l global_args
54	68	--> set -l cmd (commandline -opc)
14	14	---> commandline -opc
6	6	--> set -e cmd[1]
11	278	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
101	133	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	32	----> __fish_git_global_optspecs
23	23	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	123	---> set -l num_global_args (math (count $cmd) - (count $argv))
66	84	----> math (count $cmd) - (count $argv)
11	11	-----> count $cmd
7	7	-----> count $argv
2	11	---> if test $num_global_args -ne 0...
9	9	----> test $num_global_args -ne 0
58	60114	--> eval command git $global_args \$saved_args 2>/dev/null
60056	60056	---> command git $saved_args
33	107593	> __fish_git_unique_remote_branches
50397	107560	-> __fish_git for-each-ref --format="%(refname:strip=3)" \
        --sort="refname:strip=3" \
        "refs/remotes/*/$match*" "refs/remotes/*/*/**" 2>/dev/null | uniq -u
29	29	--> set -l saved_args $argv
6	6	--> set -l global_args
77	96	--> set -l cmd (commandline -opc)
19	19	---> commandline -opc
10	10	--> set -e cmd[1]
10	335	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
129	166	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
13	37	----> __fish_git_global_optspecs
24	24	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
42	149	---> set -l num_global_args (math (count $cmd) - (count $argv))
86	107	----> math (count $cmd) - (count $argv)
14	14	-----> count $cmd
7	7	-----> count $argv
1	10	---> if test $num_global_args -ne 0...
9	9	----> test $num_global_args -ne 0
91	56687	--> eval command git $global_args \$saved_args 2>/dev/null
56596	56596	---> command git $saved_args
18	56925	> __fish_git_heads
69	56816	-> set -l gitdir (__fish_git rev-parse --git-dir 2>/dev/null)
48	56747	--> __fish_git rev-parse --git-dir 2>/dev/null
16	16	---> set -l saved_args $argv
6	6	---> set -l global_args
47	61	---> set -l cmd (commandline -opc)
14	14	----> commandline -opc
6	6	---> set -e cmd[1]
7	270	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
96	129	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	33	-----> __fish_git_global_optspecs
23	23	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	123	----> set -l num_global_args (math (count $cmd) - (count $argv))
66	84	-----> math (count $cmd) - (count $argv)
11	11	------> count $cmd
7	7	------> count $argv
1	11	----> if test $num_global_args -ne 0...
10	10	-----> test $num_global_args -ne 0
56	56340	---> eval command git $global_args \$saved_args 2>/dev/null
56284	56284	----> command git $saved_args
16	91	-> for head in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD...
3	32	--> if test -f $gitdir/$head...
19	19	---> test -f $gitdir/$head
10	10	---> echo $head
3	18	--> if test -f $gitdir/$head...
10	10	---> test -f $gitdir/$head
5	5	---> echo $head
2	16	--> if test -f $gitdir/$head...
9	9	---> test -f $gitdir/$head
5	5	---> echo $head
1	9	--> if test -f $gitdir/$head...
8	8	---> test -f $gitdir/$head
12	58985	> __fish_git_tags
50	58973	-> __fish_git tag --sort=-creatordate 2>/dev/null
11	11	--> set -l saved_args $argv
5	5	--> set -l global_args
50	61	--> set -l cmd (commandline -opc)
11	11	---> commandline -opc
9	9	--> set -e cmd[1]
9	304	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
113	153	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	40	----> __fish_git_global_optspecs
30	30	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
41	133	---> set -l num_global_args (math (count $cmd) - (count $argv))
75	92	----> math (count $cmd) - (count $argv)
10	10	-----> count $cmd
7	7	-----> count $argv
1	9	---> if test $num_global_args -ne 0...
8	8	----> test $num_global_args -ne 0
57	58533	--> eval command git $global_args \$saved_args 2>/dev/null
58476	58476	---> command git $saved_args
20	60065	> __fish_git_recent_commits --all
64	60045	-> __fish_git log --no-show-signature --pretty=tformat:"%h"\t"%<(64,trunc)%s" --max-count=50 $argv 2>/dev/null
18	18	--> set -l saved_args $argv
6	6	--> set -l global_args
55	69	--> set -l cmd (commandline -opc)
14	14	---> commandline -opc
12	12	--> set -e cmd[1]
13	362	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
126	168	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
12	42	----> __fish_git_global_optspecs
30	30	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
69	168	---> set -l num_global_args (math (count $cmd) - (count $argv))
78	99	----> math (count $cmd) - (count $argv)
13	13	-----> count $cmd
8	8	-----> count $argv
2	13	---> if test $num_global_args -ne 0...
11	11	----> test $num_global_args -ne 0
63	59514	--> eval command git $global_args \$saved_args 2>/dev/null
59451	59451	---> command git $saved_args
49	64	> contains -- -- (commandline -opc)
15	15	-> commandline -opc
23	278	> __fish_git_using_command am
61	184	-> set -l cmd (__fish_git_needs_command)
11	123	--> __fish_git_needs_command
58	66	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	46	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
5	22	----> if set -q __fish_git_cmd[1]...
5	5	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
41	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
21	238	> __fish_git_using_command add
52	154	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	230	> __fish_git_using_command show-branch
53	152	-> set -l cmd (__fish_git_needs_command)
10	99	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
4	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	226	> __fish_git_using_command show
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
9	252	> __fish_git_needs_rev_files
34	243	-> __fish_git_using_command show
51	150	--> set -l cmd (__fish_git_needs_command)
8	99	---> __fish_git_needs_command
51	57	----> set -l cmdline "$(commandline -c)"
6	6	-----> commandline -c
6	34	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
7	7	-----> test "$cmdline" = "$__fish_git_cmdline"
6	17	-----> if set -q __fish_git_cmd[1]...
3	3	------> set -q __fish_git_cmd[1]
5	5	------> echo -- $__fish_git_cmd
3	3	------> return 1
5	5	--> test -z "$cmd"
5	5	--> contains -- $cmd $argv
36	42	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	---> string escape --style=var -- $cmd
5	5	--> set -q $varname
2	2	--> return 1
17	231	> __fish_git_using_command remote
51	153	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	225	> __fish_git_using_command filter-branch
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	224	> __fish_git_using_command fetch
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	228	> __fish_git_using_command fetch pull
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	230	> __fish_git_using_command diff log show range-diff
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	226	> __fish_git_using_command diff show range-diff
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	224	> __fish_git_using_command diff show range-diff apply
49	145	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	227	> __fish_git_using_command log show diff-tree rev-list
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
39	702	> __fish_git_using_command upload-pack
107	572	-> set -l cmd (__fish_git_needs_command)
36	465	--> __fish_git_needs_command
81	97	---> set -l cmdline "$(commandline -c)"
16	16	----> commandline -c
5	22	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
8	8	---> set -g __fish_git_cmdline $cmdline
40	49	---> set -l cmd (commandline -opc)
9	9	----> commandline -opc
6	6	---> set -e cmd[1]
146	190	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
16	44	----> __fish_git_global_optspecs
28	28	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
9	9	---> set -q _flag_version
4	4	---> set -q _flag_html_path
4	4	---> set -q _flag_man_path
3	3	---> set -q _flag_info_path
10	37	---> if set -q argv[1]...
4	4	----> set -q argv[1]
10	10	----> set -g __fish_git_cmd $argv[1]
9	9	----> echo $argv[1]
4	4	----> return 1
13	13	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
50	60	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
22	258	> __fish_git_using_command upload-archive
58	171	-> set -l cmd (__fish_git_needs_command)
9	113	--> __fish_git_needs_command
56	64	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	40	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	240	> __fish_git_using_command shell
53	160	-> set -l cmd (__fish_git_needs_command)
9	107	--> __fish_git_needs_command
57	63	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	227	> __fish_git_using_command receive-pack
50	150	-> set -l cmd (__fish_git_needs_command)
10	100	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
4	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
15	224	> __fish_git_using_command flow
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	232	> __fish_git_using_command cvsserver
49	149	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
39	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
9	99	> __fish_git_needs_command
51	57	-> set -l cmdline "$(commandline -c)"
6	6	--> commandline -c
5	33	-> if set -q __fish_git_cmdline...
4	4	--> set -q __fish_git_cmdline
7	7	--> test "$cmdline" = "$__fish_git_cmdline"
5	17	--> if set -q __fish_git_cmd[1]...
3	3	---> set -q __fish_git_cmd[1]
6	6	---> echo -- $__fish_git_cmd
3	3	---> return 1
18	86	> __fish_seen_subcommand_from branch for-each-ref tag
35	42	-> set -l cmd (commandline -poc)
7	7	--> commandline -poc
5	5	-> set -e cmd[1]
8	18	-> for i in $cmd...
2	10	--> if contains -- $i $argv...
8	8	---> contains -- $i $argv
3	3	-> return 1
17	230	> __fish_git_using_command for-each-ref
50	150	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
17	232	> __fish_git_using_command config
52	150	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
11	11	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	227	> __fish_git_using_command help
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	228	> __fish_git_using_command blame
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	229	> __fish_git_using_command clean
52	153	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
9	9	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	231	> __fish_git_using_command submodule
51	153	-> set -l cmd (__fish_git_needs_command)
8	102	--> __fish_git_needs_command
51	60	---> set -l cmdline "$(commandline -c)"
9	9	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	224	> __fish_git_using_command format-patch
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	231	> __fish_git_using_command format-patch log
56	154	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	223	> __fish_git_using_command stash
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	222	> __fish_git_using_command worktree
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	226	> __fish_git_using_command update-index
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	229	> __fish_git_using_command tag
50	150	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
9	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
36	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	222	> __fish_git_using_command stripspace
49	146	-> set -l cmd (__fish_git_needs_command)
9	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	223	> __fish_git_using_command status
49	147	-> set -l cmd (__fish_git_needs_command)
9	98	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	222	> __fish_git_using_command rm
50	147	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	224	> __fish_git_using_command revert
51	146	-> set -l cmd (__fish_git_needs_command)
8	95	--> __fish_git_needs_command
48	54	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	224	> __fish_git_using_command rev-parse
49	149	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	39	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
19	223	> __fish_git_using_command restore switch
49	146	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
20	227	> __fish_git_using_command switch
52	148	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	223	> __fish_git_using_command restore
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	265	> __fish_git_using_command reset
54	178	-> set -l cmd (__fish_git_needs_command)
11	124	--> __fish_git_needs_command
59	65	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
13	48	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
41	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	240	> __fish_git_using_command reflog
54	159	-> set -l cmd (__fish_git_needs_command)
8	105	--> __fish_git_needs_command
54	61	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	237	> __fish_git_using_command rebase
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
4	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
42	49	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
30	727	> __fish_git_using_command push
318	554	-> set -l cmd (__fish_git_needs_command)
18	236	--> __fish_git_needs_command
80	86	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	132	---> if set -q __fish_git_cmdline...
6	6	----> set -q __fish_git_cmdline
12	12	----> test "$cmdline" = "$__fish_git_cmdline"
20	105	----> if set -q __fish_git_cmd[1]...
43	43	-----> set -q __fish_git_cmd[1]
29	29	-----> echo -- $__fish_git_cmd
13	13	-----> return 1
14	14	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
86	101	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
15	15	--> string escape --style=var -- $cmd
15	15	-> set -q $varname
5	5	-> return 1
30	516	> __fish_git_using_command range-diff
83	394	-> set -l cmd (__fish_git_needs_command)
17	311	--> __fish_git_needs_command
149	213	---> set -l cmdline "$(commandline -c)"
64	64	----> commandline -c
10	81	---> if set -q __fish_git_cmdline...
25	25	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
7	35	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
21	21	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
9	9	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
52	66	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
14	14	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	268	> __fish_git_using_command pull
73	184	-> set -l cmd (__fish_git_needs_command)
10	111	--> __fish_git_needs_command
55	62	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	39	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	238	> __fish_git_using_command prune
52	155	-> set -l cmd (__fish_git_needs_command)
10	103	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	230	> __fish_git_using_command notes
52	153	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	243	> __fish_git_using_command mv
52	167	-> set -l cmd (__fish_git_needs_command)
14	115	--> __fish_git_needs_command
59	66	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	230	> __fish_git_using_command mergetool
52	152	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	35	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
20	227	> __fish_git_using_command merge-base
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	228	> __fish_git_using_command merge
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
25	232	> __fish_git_using_command maintenance
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
6	6	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
20	243	> __fish_git_using_command mailsplit
51	150	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
43	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
8	8	-> set -q $varname
3	3	-> return 1
20	250	> __fish_git_using_command mailsplit am
53	163	-> set -l cmd (__fish_git_needs_command)
10	110	--> __fish_git_needs_command
56	64	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	230	> __fish_git_using_command mailinfo
52	152	-> set -l cmd (__fish_git_needs_command)
9	100	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	232	> __fish_git_using_command mailinfo am
51	154	-> set -l cmd (__fish_git_needs_command)
8	103	--> __fish_git_needs_command
50	61	---> set -l cmdline "$(commandline -c)"
11	11	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
34	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
15	224	> __fish_git_using_command ls-files
52	149	-> set -l cmd (__fish_git_needs_command)
7	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
16	222	> __fish_git_using_command log
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	225	> __fish_git_using_command init
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	225	> __fish_git_using_command grep
52	149	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
21	231	> __fish_git_using_command gc
51	149	-> set -l cmd (__fish_git_needs_command)
7	98	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	226	> __fish_git_using_command difftool
50	149	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	33	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	232	> __fish_git_using_command diff
51	150	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
50	57	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	46	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	224	> __fish_git_using_command describe
51	148	-> set -l cmd (__fish_git_needs_command)
8	97	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
33	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
17	223	> __fish_git_using_command daemon
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	222	> __fish_git_using_command count-objects
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
4	4	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
18	226	> __fish_git_using_command commit
50	149	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	36	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
8	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	225	> __fish_git_using_command clone
50	149	-> set -l cmd (__fish_git_needs_command)
10	99	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	225	> __fish_git_using_command cherry-pick
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
8	35	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	226	> __fish_git_using_command cherry
51	151	-> set -l cmd (__fish_git_needs_command)
8	100	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
10	37	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	41	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
4	4	-> set -q $varname
3	3	-> return 1
18	224	> __fish_git_using_command bundle
50	148	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
8	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
34	40	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
6	6	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	229	> __fish_git_using_command branch
51	152	-> set -l cmd (__fish_git_needs_command)
8	101	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
9	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	225	> __fish_git_using_command bisect
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
50	55	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	16	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
5	5	-> contains -- $cmd $argv
35	43	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
15	223	> __fish_git_using_command archive
51	147	-> set -l cmd (__fish_git_needs_command)
8	96	--> __fish_git_needs_command
49	55	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	227	> __fish_git_using_command apply
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
51	56	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	235	> __fish_git_using_command apply am
51	150	-> set -l cmd (__fish_git_needs_command)
9	99	--> __fish_git_needs_command
52	57	---> set -l cmdline "$(commandline -c)"
5	5	----> commandline -c
6	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	17	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
6	6	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
38	45	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
15	181	> __fish_git_using_command checkout
52	151	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	58	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
7	33	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	16	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
2	2	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
3	3	-> return 0
68	172365	> __fish_git_files modified deleted modified-staged-deleted
69	57312	-> set -l root (__fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null)
75	57243	--> __fish_git rev-parse --show-toplevel --is-bare-repository 2>/dev/null
16	16	---> set -l saved_args $argv
5	5	---> set -l global_args
38	46	---> set -l cmd (commandline -opc)
8	8	----> commandline -opc
6	6	---> set -e cmd[1]
6	276	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
103	134	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	31	-----> __fish_git_global_optspecs
22	22	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	127	----> set -l num_global_args (math (count $cmd) - (count $argv))
65	88	-----> math (count $cmd) - (count $argv)
16	16	------> count $cmd
7	7	------> count $argv
2	9	----> if test $num_global_args -ne 0...
7	7	-----> test $num_global_args -ne 0
56	56819	---> eval command git $global_args \$saved_args 2>/dev/null
56763	56763	----> command git $saved_args
17	17	-> test "$root[2]" = true
7	7	-> set -e root[2]
13	13	-> contains -- all-staged $argv
6	6	-> contains -- unmerged $argv
6	6	-> contains -- added $argv
3	3	-> set -ql all_staged
5	5	-> contains -- modified $argv
6	6	-> set -l modified
9	9	-> set -l modified_desc "Modified file"
6	6	-> contains -- untracked $argv
5	5	-> contains -- modified-staged $argv
3	3	-> set -ql all_staged
6	6	-> contains -- modified-staged-deleted $argv
4	4	-> set -l modified_staged_deleted
8	8	-> set -l modified_staged_deleted_desc "Staged modified and deleted file"
6	6	-> contains -- deleted $argv
4	4	-> set -l deleted
8	8	-> set -l deleted_desc "Deleted file"
5	5	-> contains -- deleted-staged $argv
3	3	-> set -ql all_staged
5	5	-> contains -- ignored $argv
5	5	-> contains -- renamed $argv
6	6	-> contains -- copied $argv
5	5	-> set -l q '\\?'
5	10	-> if status test-feature qmark-noglob...
5	5	--> status test-feature qmark-noglob
4	4	-> set -l use_next
9	9	-> set -l status_opt --ignore-submodules=all
4	4	-> set -q ignored
4	4	-> set -q untracked
5	5	-> set -a status_opt -uno
7	7	-> set -l git_opt -c status.relativePaths -c core.quotePath=
87	56557	-> set -l ver (__fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2')
108	56470	--> __fish_git --version | string replace -rf 'git version (\d+)\.(\d+)\.?.*' '$1\n$2'
8	8	---> set -l saved_args $argv
4	4	---> set -l global_args
39	50	---> set -l cmd (commandline -opc)
11	11	----> commandline -opc
5	5	---> set -e cmd[1]
14	384	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
126	162	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	36	-----> __fish_git_global_optspecs
25	25	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
50	197	----> set -l num_global_args (math (count $cmd) - (count $argv))
115	147	-----> math (count $cmd) - (count $argv)
13	13	------> count $cmd
19	19	------> count $argv
1	11	----> if test $num_global_args -ne 0...
10	10	-----> test $num_global_args -ne 0
60	55911	---> eval command git $global_args \$saved_args 2>/dev/null
55851	55851	----> command git $saved_args
62	58234	-> if test "$ver[1]" -gt 2 2>/dev/null...
42	42	--> test "$ver[1]" -gt 2 2>/dev/null
26	26	--> test "$ver[1]" -eq 2 -a "$ver[2]" -ge 11 2>/dev/null
151	58104	--> __fish_git $git_opt status --porcelain=2 $status_opt \
            | while read -la -d ' ' line
            set -l file
            set -l desc
            # The basic status format is "XY", where X is "our" state (meaning the staging area),
            # and "Y" is "their" state.
            # A "." means it's unmodified.
            switch "$line[1..2]"
                case 'u *'
                    # Unmerged
                    # "Unmerged entries have the following format; the first character is a "u" to distinguish from ordinary changed entries."
                    # "u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>"
                    # This is first to distinguish it from normal modifications et al.
                    set -ql unmerged
                    and set file "$line[11..-1]"
                    and set desc $unmerged_desc
                case '2 .R*' '2 R.*'
                    # Renamed/Copied
                    # From the docs: "Renamed or copied entries have the following format:"
                    # "2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>"
                    # Since <sep> is \t, we can't really parse it unambiguously.
                    # The "-z" format would be great here!
                    set -ql renamed
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    and set desc $renamed_desc
                case '2 RM*' '2 RT*'
                    # Staged as renamed, with unstaged modifications (issue #6031)
                    set -ql renamed
                    or set -ql modified
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql modified
                    and set --append desc $modified_desc
                case '2 RD*'
                    # Staged as renamed, but deleted in the worktree
                    set -ql renamed
                    or set -ql deleted
                    and set file (string replace -r '\t[^\t]*' '' -- "$line[10..-1]")
                    set -ql renamed
                    and set desc $renamed_desc
                    set -ql deleted
                    and set --append desc $deleted_desc
                case '2 .C*' '2 C.*'
                    set -ql copied
                    and set file (string replace -r '\t[^\t].*' '' -- "$line[10..-1]")
                    and set desc $copied_desc
                case '1 A.*'
                    # Additions are only shown here if they are staged.
                    # Otherwise it's an untracked file.
                    set -ql added
                    and set file "$line[9..-1]"
                    and set desc $added_desc
                case '1 AD*'
                    # Added files that were since deleted
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql deleted
                        set file "$line[9..-1]"
                        set desc $deleted_desc
                    end
                case "1 AM*" "1 AT*"
                    # Added files with additional modifications
                    # ("T" is type-changed. As of git 2.33 this appears to be undocumented.
                    # it happens when e.g. a file is replaced with a symlink.
                    # For our purposes it's the same as modified)
                    if set -ql added
                        set file "$line[9..-1]"
                        set desc $added_desc
                    else if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    end
                case '1 .A*'
                    # Files added with git add --intent-to-add.
                    set -ql untracked
                    and set file "$line[9..-1]"
                    and set desc $untracked_desc
                case '1 .M*' '1 .T*'
                    # Modified
                    # From the docs: "Ordinary changed entries have the following format:"
                    # "1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>"
                    # Since <path> can contain spaces, print from element 9 onwards
                    set -ql modified
                    and set file "$line[9..-1]"
                    and set desc $modified_desc
                case '1 MD*' '1 TD*'
                    set -ql modified_staged_deleted
                    and set file "$line[9..-1]"
                    and set desc $modified_staged_deleted_desc
                case '1 M.*' '1 T.*'
                    # If the character is first ("M."), then that means it's "our" change,
                    # which means it is staged.
                    # This is useless for many commands - e.g. `checkout` won't do anything with this.
                    # So it needs to be requested explicitly.
                    set -ql modified_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_modified_desc
                case '1 MM*' '1 MT*' '1 TM*' '1 TT*'
                    # Staged-modified with unstaged modifications
                    # These need to be offered for both kinds of modified.
                    if set -ql modified
                        set file "$line[9..-1]"
                        set desc $modified_desc
                    else if set -ql modified_staged
                        set file "$line[9..-1]"
                        set desc $staged_modified_desc
                    end
                case '1 .D*'
                    set -ql deleted
                    and set file "$line[9..-1]"
                    and set desc $deleted_desc
                case '1 D.*'
                    # TODO: The docs are unclear on this.
                    # There is both X unmodified and Y either M or D ("not updated")
                    # and Y is D and X is unmodified or [MARC] ("deleted in work tree").
                    # For our purposes, we assume this is a staged deletion.
                    set -ql deleted_staged
                    and set file "$line[9..-1]"
                    and set desc $staged_deleted_desc
                case "$q"' *'
                    # Untracked
                    # "? <path>" - print from element 2 on.
                    set -ql untracked
                    and set file "$line[2..-1]"
                    and set desc $untracked_desc
                case '! *'
                    # Ignored
                    # "! <path>" - print from element 2 on.
                    set -ql ignored
                    and set file "$line[2..-1]"
                    and set desc $ignored_desc
            end
            # Only try printing if the file was selected.
            if set -q file[1]
                for d in $desc
                    # Without "-z", git sometimes _quotes_ filenames.
                    # It adds quotes around it _and_ escapes the character.
                    # e.g. `"a\\b"`.
                    # We just remove the quotes and hope it works out.
                    # If this contains newlines or tabs,
                    # there is nothing we can do, but that's a general issue with scripted completions.
                    set file (string trim -c \" -- $file)
                    # The relative filename.
                    if string match -q './*' -- (commandline -ct)
                        printf './%s\t%s\n' $file $d
                    else
                        printf '%s\t%s\n' "$file" $d
                    end
                    # Now from repo root.
                    # Only do this if the filename isn't a simple child,
                    # or the current token starts with ":"
                    if string match -q '../*' -- $file
                        or string match -q ':*' -- (commandline -ct)
                        set -l fromroot (builtin realpath -- $file 2>/dev/null)
                        # `:` starts pathspec "magic", and the second `:` terminates it.
                        # `/` is the magic letter for "from repo root".
                        # If we didn't terminate it we'd have to escape any special chars
                        # (non-alphanumeric, glob or regex special characters, in whatever dialect git uses)
                        and set fromroot (string replace -- "$root/" ":/:" "$fromroot")
                        and printf '%s\t%s\n' "$fromroot" $d
                    end
                end
            end
        end
18	18	---> set -l saved_args $argv
5	5	---> set -l global_args
44	59	---> set -l cmd (commandline -opc)
15	15	----> commandline -opc
6	6	---> set -e cmd[1]
10	351	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
102	135	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
11	33	-----> __fish_git_global_optspecs
22	22	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
79	194	----> set -l num_global_args (math (count $cmd) - (count $argv))
87	115	-----> math (count $cmd) - (count $argv)
12	12	------> count $cmd
16	16	------> count $argv
1	12	----> if test $num_global_args -ne 0...
11	11	-----> test $num_global_args -ne 0
68	57489	---> eval command git $global_args \$saved_args 2>/dev/null
57421	57421	----> command git $saved_args
25	25	---> read -la -d ' ' line
47	60	> not contains -- -- (commandline -opc)
13	13	-> commandline -opc
16	116793	> __fish_git_branches
52	58796	-> __fish_git for-each-ref --format='%(refname:strip=2)%09Local Branch' --sort=-committerdate refs/heads/ 2>/dev/null
17	17	--> set -l saved_args $argv
5	5	--> set -l global_args
41	49	--> set -l cmd (commandline -opc)
8	8	---> commandline -opc
6	6	--> set -e cmd[1]
8	269	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
95	127	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	32	----> __fish_git_global_optspecs
23	23	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	123	---> set -l num_global_args (math (count $cmd) - (count $argv))
66	84	----> math (count $cmd) - (count $argv)
11	11	-----> count $cmd
7	7	-----> count $argv
1	11	---> if test $num_global_args -ne 0...
10	10	----> test $num_global_args -ne 0
57	58398	--> eval command git $global_args \$saved_args 2>/dev/null
58341	58341	---> command git $saved_args
72	57981	-> __fish_git for-each-ref --format='%(refname:strip=2)%09Remote Branch' refs/remotes/ 2>/dev/null
22	22	--> set -l saved_args $argv
6	6	--> set -l global_args
58	72	--> set -l cmd (commandline -opc)
14	14	---> commandline -opc
7	7	--> set -e cmd[1]
8	300	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
117	152	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	35	----> __fish_git_global_optspecs
25	25	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
43	129	---> set -l num_global_args (math (count $cmd) - (count $argv))
68	86	----> math (count $cmd) - (count $argv)
11	11	-----> count $cmd
7	7	-----> count $argv
1	11	---> if test $num_global_args -ne 0...
10	10	----> test $num_global_args -ne 0
57	57502	--> eval command git $global_args \$saved_args 2>/dev/null
57445	57445	---> command git $saved_args
28	107558	> __fish_git_unique_remote_branches
50381	107530	-> __fish_git for-each-ref --format="%(refname:strip=3)" \
        --sort="refname:strip=3" \
        "refs/remotes/*/$match*" "refs/remotes/*/*/**" 2>/dev/null | uniq -u
27	27	--> set -l saved_args $argv
5	5	--> set -l global_args
63	83	--> set -l cmd (commandline -opc)
20	20	---> commandline -opc
7	7	--> set -e cmd[1]
8	292	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
109	142	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
10	33	----> __fish_git_global_optspecs
23	23	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
41	132	---> set -l num_global_args (math (count $cmd) - (count $argv))
68	91	----> math (count $cmd) - (count $argv)
11	11	-----> count $cmd
12	12	-----> count $argv
1	10	---> if test $num_global_args -ne 0...
9	9	----> test $num_global_args -ne 0
86	56735	--> eval command git $global_args \$saved_args 2>/dev/null
56649	56649	---> command git $saved_args
19	55935	> __fish_git_heads
70	55824	-> set -l gitdir (__fish_git rev-parse --git-dir 2>/dev/null)
47	55754	--> __fish_git rev-parse --git-dir 2>/dev/null
16	16	---> set -l saved_args $argv
5	5	---> set -l global_args
42	55	---> set -l cmd (commandline -opc)
13	13	----> commandline -opc
7	7	---> set -e cmd[1]
9	315	---> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
120	154	----> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	34	-----> __fish_git_global_optspecs
25	25	------> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
46	140	----> set -l num_global_args (math (count $cmd) - (count $argv))
73	94	-----> math (count $cmd) - (count $argv)
13	13	------> count $cmd
8	8	------> count $argv
3	12	----> if test $num_global_args -ne 0...
9	9	-----> test $num_global_args -ne 0
57	55309	---> eval command git $global_args \$saved_args 2>/dev/null
55252	55252	----> command git $saved_args
16	92	-> for head in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD...
3	33	--> if test -f $gitdir/$head...
19	19	---> test -f $gitdir/$head
11	11	---> echo $head
2	17	--> if test -f $gitdir/$head...
10	10	---> test -f $gitdir/$head
5	5	---> echo $head
3	17	--> if test -f $gitdir/$head...
9	9	---> test -f $gitdir/$head
5	5	---> echo $head
1	9	--> if test -f $gitdir/$head...
8	8	---> test -f $gitdir/$head
12	57498	> __fish_git_tags
49	57486	-> __fish_git tag --sort=-creatordate 2>/dev/null
12	12	--> set -l saved_args $argv
5	5	--> set -l global_args
40	52	--> set -l cmd (commandline -opc)
12	12	---> commandline -opc
6	6	--> set -e cmd[1]
8	310	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
97	129	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
9	32	----> __fish_git_global_optspecs
23	23	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
43	162	---> set -l num_global_args (math (count $cmd) - (count $argv))
91	119	----> math (count $cmd) - (count $argv)
12	12	-----> count $cmd
16	16	-----> count $argv
2	11	---> if test $num_global_args -ne 0...
9	9	----> test $num_global_args -ne 0
67	57052	--> eval command git $global_args \$saved_args 2>/dev/null
56985	56985	---> command git $saved_args
22	61126	> __fish_git_recent_commits --all
60	61104	-> __fish_git log --no-show-signature --pretty=tformat:"%h"\t"%<(64,trunc)%s" --max-count=50 $argv 2>/dev/null
18	18	--> set -l saved_args $argv
5	5	--> set -l global_args
46	60	--> set -l cmd (commandline -opc)
14	14	---> commandline -opc
7	7	--> set -e cmd[1]
7	279	--> if argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null...
102	137	---> argparse -s (__fish_git_global_optspecs) -- $cmd 2>/dev/null
12	35	----> __fish_git_global_optspecs
23	23	-----> string join \n v-version h/help C= c=+ 'e-exec-path=?' H-html-path M-man-path I-info-path p/paginate \
        P/no-pager o-no-replace-objects b-bare G-git-dir= W-work-tree= N-namespace= S-super-prefix= \
        l-literal-pathspecs g-glob-pathspecs O-noglob-pathspecs i-icase-pathspecs
39	124	---> set -l num_global_args (math (count $cmd) - (count $argv))
67	85	----> math (count $cmd) - (count $argv)
11	11	-----> count $cmd
7	7	-----> count $argv
1	11	---> if test $num_global_args -ne 0...
10	10	----> test $num_global_args -ne 0
56	60675	--> eval command git $global_args \$saved_args 2>/dev/null
60619	60619	---> command git $saved_args
51	67	> contains -- -- (commandline -opc)
16	16	-> commandline -opc
34	394	> __fish_git_using_command am
74	248	-> set -l cmd (__fish_git_needs_command)
18	174	--> __fish_git_needs_command
83	97	---> set -l cmdline "$(commandline -c)"
14	14	----> commandline -c
8	59	---> if set -q __fish_git_cmdline...
11	11	----> set -q __fish_git_cmdline
14	14	----> test "$cmdline" = "$__fish_git_cmdline"
7	26	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
11	11	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
9	9	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
67	79	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
12	12	--> string escape --style=var -- $cmd
11	11	-> set -q $varname
4	4	-> return 1
19	288	> __fish_git_using_command add
60	195	-> set -l cmd (__fish_git_needs_command)
15	135	--> __fish_git_needs_command
62	72	---> set -l cmdline "$(commandline -c)"
10	10	----> commandline -c
11	48	---> if set -q __fish_git_cmdline...
5	5	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
5	21	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
4	4	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
41	51	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
19	300	> __fish_git_using_command show-branch
60	198	-> set -l cmd (__fish_git_needs_command)
13	138	--> __fish_git_needs_command
67	74	---> set -l cmdline "$(commandline -c)"
7	7	----> commandline -c
8	51	---> if set -q __fish_git_cmdline...
7	7	----> set -q __fish_git_cmdline
11	11	----> test "$cmdline" = "$__fish_git_cmdline"
7	25	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
11	11	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
7	7	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
48	58	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
10	10	--> string escape --style=var -- $cmd
7	7	-> set -q $varname
3	3	-> return 1
20	266	> __fish_git_using_command show
58	175	-> set -l cmd (__fish_git_needs_command)
15	117	--> __fish_git_needs_command
56	64	---> set -l cmdline "$(commandline -c)"
8	8	----> commandline -c
6	38	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
9	9	----> test "$cmdline" = "$__fish_git_cmdline"
5	19	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
7	7	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
42	50	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
9	283	> __fish_git_needs_rev_files
36	274	-> __fish_git_using_command show
55	168	--> set -l cmd (__fish_git_needs_command)
9	113	---> __fish_git_needs_command
54	62	----> set -l cmdline "$(commandline -c)"
8	8	-----> commandline -c
8	42	----> if set -q __fish_git_cmdline...
4	4	-----> set -q __fish_git_cmdline
9	9	-----> test "$cmdline" = "$__fish_git_cmdline"
7	21	-----> if set -q __fish_git_cmd[1]...
4	4	------> set -q __fish_git_cmd[1]
7	7	------> echo -- $__fish_git_cmd
3	3	------> return 1
6	6	--> test -z "$cmd"
6	6	--> contains -- $cmd $argv
42	50	--> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	---> string escape --style=var -- $cmd
5	5	--> set -q $varname
3	3	--> return 1
20	250	> __fish_git_using_command remote
59	167	-> set -l cmd (__fish_git_needs_command)
14	108	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
7	7	-> contains -- $cmd $argv
35	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
9	9	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
17	232	> __fish_git_using_command filter-branch
52	153	-> set -l cmd (__fish_git_needs_command)
9	101	--> __fish_git_needs_command
52	58	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
5	5	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
18	248	> __fish_git_using_command fetch
52	166	-> set -l cmd (__fish_git_needs_command)
9	114	--> __fish_git_needs_command
62	68	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	37	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
6	20	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
8	8	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
6	6	-> contains -- $cmd $argv
36	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
20	244	> __fish_git_using_command fetch pull
57	160	-> set -l cmd (__fish_git_needs_command)
9	103	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
6	18	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
36	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
8	8	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
2	2	-> return 1
19	242	> __fish_git_using_command diff log show range-diff
52	158	-> set -l cmd (__fish_git_needs_command)
10	106	--> __fish_git_needs_command
54	60	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	36	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
7	19	----> if set -q __fish_git_cmd[1]...
3	3	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
37	44	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
17	231	> __fish_git_using_command diff show range-diff
51	149	-> set -l cmd (__fish_git_needs_command)
8	98	--> __fish_git_needs_command
50	56	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
4	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
8	8	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
9	9	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
6	6	-> set -q $varname
3	3	-> return 1
17	244	> __fish_git_using_command diff show range-diff apply
62	164	-> set -l cmd (__fish_git_needs_command)
9	102	--> __fish_git_needs_command
53	59	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
5	34	---> if set -q __fish_git_cmdline...
4	4	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
5	5	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
19	237	> __fish_git_using_command log show diff-tree rev-list
55	154	-> set -l cmd (__fish_git_needs_command)
8	99	--> __fish_git_needs_command
51	57	---> set -l cmdline "$(commandline -c)"
6	6	----> commandline -c
6	34	---> if set -q __fish_git_cmdline...
3	3	----> set -q __fish_git_cmdline
7	7	----> test "$cmdline" = "$__fish_git_cmdline"
5	18	----> if set -q __fish_git_cmd[1]...
4	4	-----> set -q __fish_git_cmd[1]
6	6	-----> echo -- $__fish_git_cmd
3	3	-----> return 1
6	6	-> test -z "$cmd"
8	8	-> contains -- $cmd $argv
35	42	-> set -l varname __fish_git_alias_(string escape --style=var -- $cmd)
7	7	--> string escape --style=var -- $cmd
5	5	-> set -q $varname
3	3	-> return 1
63	107	> __fish_disable_bracketed_paste 'git checkout maxi/no-kafka '
44	44	-> printf "\e[?2004l"
39	2181	> fish_title git\ checkout\ maxi/no-kafka\ 
36	2142	-> if not set -q INSIDE_EMACS...
23	23	--> not set -q INSIDE_EMACS
16	16	--> set -l ssh
11	11	--> set -q SSH_TTY
12	2056	--> if set -q argv[1]...
12	12	---> set -q argv[1]
250	2032	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
35	35	----> string sub -l 20 -- $argv[1]
77	1747	----> prompt_pwd -d 1 -D 1
23	23	-----> set -l options h/help d/dir-length= D/full-length-dirs=
62	62	-----> argparse -n prompt_pwd $options -- $argv
4	16	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
10	10	-----> set -q argv[1]
17	17	-----> set argv $PWD
9	9	-----> set -ql _flag_d
22	22	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
13	13	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
17	17	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
11	11	-----> set -q fish_prompt_pwd_full_dirs
53	1452	-----> for path in $argv...
158	190	------> set -l realhome (string escape --style=regex -- ~)
32	32	-------> string escape --style=regex -- ~
242	317	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
75	75	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
25	892	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
35	35	-------> test "$fish_prompt_pwd_dir_length" -eq 0
15	15	-------> set -l full
24	534	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
18	18	--------> test $fish_prompt_pwd_full_dirs -gt 0
218	448	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
189	230	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
41	41	----------> math $fish_prompt_pwd_full_dirs - 1
28	28	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
201	283	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
82	82	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
83894	83894	> git checkout maxi/no-kafka
29	64	> __fish_enable_bracketed_paste
35	35	-> printf "\e[?2004h"
12	62	> fish_mode_prompt
14	50	-> fish_default_mode_prompt
5	36	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
24	24	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
42	224100	> fish_prompt
13	13	-> set -l last_status $status
43	56	-> set -l normal (set_color normal)
13	13	--> set_color normal
37	46	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
36	46	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
107	113	-> set -l vcs_color (set_color brpurple)
6	6	--> set_color brpurple
6	6	-> set -l prompt_status ""
4	4	-> set -q fish_prompt_pwd_dir_length
19	19	-> set -lx fish_prompt_pwd_dir_length 0
7	7	-> set -l suffix '❯'
3	188	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
25	175	--> fish_is_root_user
10	115	---> if test "$EUID" = 0 2>/dev/null...
105	105	----> test "$EUID" = 0 2>/dev/null
3	29	---> if contains -- $USER root toor Administrator...
26	26	----> contains -- $USER root toor Administrator
6	6	---> return 1
1	10	-> if test $last_status -ne 0...
9	9	--> test $last_status -ne 0
196	223539	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
21	643	--> prompt_login
3	80	---> if not set -q __fish_machine...
77	77	----> not set -q __fish_machine
4	10	---> if set -q __fish_machine[1]...
6	6	----> set -q __fish_machine[1]
14	14	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
357	513	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
30	30	----> set_color $fish_color_user
35	35	----> set_color normal
14	14	----> set_color $color_host
18	52	----> prompt_hostname
34	34	-----> string replace -r -- "\..*" "" $hostname
25	25	----> set_color normal
31	321	--> prompt_pwd
12	12	---> set -l options h/help d/dir-length= D/full-length-dirs=
19	19	---> argparse -n prompt_pwd $options -- $argv
3	7	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
4	4	---> set -q fish_prompt_pwd_full_dirs
5	5	---> set -l fish_prompt_pwd_full_dirs 1
18	219	---> for path in $argv...
91	103	----> set -l realhome (string escape --style=regex -- ~)
12	12	-----> string escape --style=regex -- ~
45	72	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	26	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
12	12	-----> test "$fish_prompt_pwd_dir_length" -eq 0
9	9	-----> echo $tmp
16	222379	--> fish_vcs_prompt
102	222363	---> fish_git_prompt $argv
12	51217	----> if not command -sq git...
51205	51205	-----> not command -sq git
3	36	----> if functions -q __fish_git_prompt_ready...
33	33	-----> functions -q __fish_git_prompt_ready
142	57727	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57585	57585	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
9	9	----> set -l sha $repo_info[5]
63	56473	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	56410	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
3	3	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	95	------> if test -d $git_dir/rebase-merge...
15	15	-------> test -d $git_dir/rebase-merge
7	56	-------> if test -d $git_dir/rebase-apply...
11	11	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
13	13	--------> test -f $git_dir/CHERRY_PICK_HEAD
9	9	--------> test -f $git_dir/REVERT_HEAD
8	8	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
10	56166	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	56152	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
101	56148	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56047	56047	---------> command git symbolic-ref HEAD 2>/dev/null
1	15	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
12	12	------> echo $operation
6	6	------> echo $branch
6	6	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
1	8	----> if not set -q ___fish_git_prompt_init...
7	7	-----> not set -q ___fish_git_prompt_init
19	19	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
50304	56215	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5911	5911	-----> read -lz key value
5	39	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
15	15	----> contains dirtystate $__fish_git_prompt_status_order
3	14	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
11	74	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
7	44	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
4	11	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	6	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
5	5	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
4	10	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
6	6	----> set -l f ""
18	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
62	85	----> set b (string replace refs/heads/ '' -- $b)
23	23	-----> string replace refs/heads/ '' -- $b
1	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
7	36	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
2	5	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
31	31	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
9	615	> fish_title
7	606	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
8	8	--> set -l ssh
4	4	--> set -q SSH_TTY
11	581	--> if set -q argv[1]...
3	3	---> set -q argv[1]
36	42	---> set -l command (status current-command)
6	6	----> status current-command
4	14	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
62	511	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
23	442	----> prompt_pwd -d 1 -D 1
8	8	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
11	11	-----> set argv $PWD
4	4	-----> set -ql _flag_d
10	10	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
7	7	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
4	4	-----> set -q fish_prompt_pwd_full_dirs
17	334	-----> for path in $argv...
40	50	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
38	65	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	202	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
12	125	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
40	95	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	55	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
41	59	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
86	157	> __fish_disable_bracketed_paste nvim
71	71	-> printf "\e[?2004l"
46	3467	> fish_title nvim
32	3421	-> if not set -q INSIDE_EMACS...
33	33	--> not set -q INSIDE_EMACS
24	24	--> set -l ssh
16	16	--> set -q SSH_TTY
18	3316	--> if set -q argv[1]...
16	16	---> set -q argv[1]
529	3282	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
45	45	----> string sub -l 20 -- $argv[1]
148	2708	----> prompt_pwd -d 1 -D 1
48	48	-----> set -l options h/help d/dir-length= D/full-length-dirs=
113	113	-----> argparse -n prompt_pwd $options -- $argv
7	27	-----> if set -q _flag_help...
20	20	------> set -q _flag_help
16	16	-----> set -q argv[1]
29	29	-----> set argv $PWD
14	14	-----> set -ql _flag_d
29	29	-----> set -l fish_prompt_pwd_dir_length $_flag_d
14	14	-----> set -q fish_prompt_pwd_dir_length
18	18	-----> set -l fulldirs 0
12	12	-----> set -ql _flag_D
23	23	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
13	13	-----> set -q fish_prompt_pwd_full_dirs
69	2204	-----> for path in $argv...
232	282	------> set -l realhome (string escape --style=regex -- ~)
50	50	-------> string escape --style=regex -- ~
277	387	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
110	110	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
47	1466	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
52	52	-------> test "$fish_prompt_pwd_dir_length" -eq 0
23	23	-------> set -l full
38	897	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
31	31	--------> test $fish_prompt_pwd_full_dirs -gt 0
356	762	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
343	406	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
63	63	----------> math $fish_prompt_pwd_full_dirs - 1
43	43	--------> set tmp $all[1]
23	23	--------> set full $all[2..]
300	447	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
147	147	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
1250545581	1250545581	> nvim
48	186	> __fish_enable_bracketed_paste
138	138	-> printf "\e[?2004h"
31	194	> fish_mode_prompt
93	163	-> fish_default_mode_prompt
10	70	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
45	45	---> test "$fish_key_bindings" = fish_vi_key_bindings
15	15	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
91	235628	> fish_prompt
44	44	-> set -l last_status $status
157	249	-> set -l normal (set_color normal)
92	92	--> set_color normal
145	176	-> set -l status_color (set_color brgreen)
31	31	--> set_color brgreen
98	123	-> set -l cwd_color (set_color $fish_color_cwd)
25	25	--> set_color $fish_color_cwd
99	116	-> set -l vcs_color (set_color brpurple)
17	17	--> set_color brpurple
14	14	-> set -l prompt_status ""
10	10	-> set -q fish_prompt_pwd_dir_length
11	11	-> set -lx fish_prompt_pwd_dir_length 0
11	11	-> set -l suffix '❯'
7	571	-> if functions -q fish_is_root_user...
189	189	--> functions -q fish_is_root_user
80	375	--> fish_is_root_user
5	102	---> if test "$EUID" = 0 2>/dev/null...
97	97	----> test "$EUID" = 0 2>/dev/null
32	180	---> if contains -- $USER root toor Administrator...
148	148	----> contains -- $USER root toor Administrator
13	13	---> return 1
4	30	-> if test $last_status -ne 0...
26	26	--> test $last_status -ne 0
411	234171	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
194	1223	--> prompt_login
7	36	---> if not set -q __fish_machine...
29	29	----> not set -q __fish_machine
5	15	---> if set -q __fish_machine[1]...
10	10	----> set -q __fish_machine[1]
36	36	---> set -l color_host $fish_color_host
2	11	---> if set -q SSH_TTY...
9	9	----> set -q SSH_TTY
610	931	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
34	34	----> set_color $fish_color_user
64	64	----> set_color normal
32	32	----> set_color $color_host
111	166	----> prompt_hostname
55	55	-----> string replace -r -- "\..*" "" $hostname
25	25	----> set_color normal
142	768	--> prompt_pwd
25	25	---> set -l options h/help d/dir-length= D/full-length-dirs=
37	37	---> argparse -n prompt_pwd $options -- $argv
2	11	---> if set -q _flag_help...
9	9	----> set -q _flag_help
7	7	---> set -q argv[1]
12	12	---> set argv $PWD
6	6	---> set -ql _flag_d
6	6	---> set -q fish_prompt_pwd_dir_length
9	9	---> set -l fulldirs 0
5	5	---> set -ql _flag_D
6	6	---> set -q fish_prompt_pwd_full_dirs
8	8	---> set -l fish_prompt_pwd_full_dirs 1
55	494	---> for path in $argv...
109	131	----> set -l realhome (string escape --style=regex -- ~)
22	22	-----> string escape --style=regex -- ~
137	184	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
47	47	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
41	124	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
44	44	-----> test "$fish_prompt_pwd_dir_length" -eq 0
39	39	-----> echo $tmp
238	231769	--> fish_vcs_prompt
298	231531	---> fish_git_prompt $argv
12	58632	----> if not command -sq git...
58620	58620	-----> not command -sq git
6	81	----> if functions -q __fish_git_prompt_ready...
75	75	-----> functions -q __fish_git_prompt_ready
133	56776	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
56643	56643	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
18	18	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
59	57263	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
45	57204	-----> __fish_git_prompt_operation_branch_bare $repo_info
11	11	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
5	5	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
5	5	------> set -l branch
5	5	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
22	72	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	39	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
9	56977	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	56964	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
95	56960	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
56865	56865	---------> command git symbolic-ref HEAD 2>/dev/null
2	16	------> if test true = $inside_gitdir...
14	14	-------> test true = $inside_gitdir
11	11	------> echo $operation
7	7	------> echo $branch
4	4	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
7	7	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
19	19	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
5	5	----> set -l untracked
51788	57840	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6052	6052	-----> read -lz key value
8	43	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
7	19	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
9	74	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	45	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	10	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	16	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
5	5	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
22	53	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
107	123	----> set b (string replace refs/heads/ '' -- $b)
16	16	-----> string replace refs/heads/ '' -- $b
1	23	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
22	22	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	34	----> if test -n "$b"...
7	7	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
6	15	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
27	27	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
10	774	> fish_title
9	764	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
10	741	--> if set -q argv[1]...
3	3	---> set -q argv[1]
50	56	---> set -l command (status current-command)
6	6	----> status current-command
5	21	---> if test "$command" = fish...
10	10	----> test "$command" = fish
6	6	----> set command
154	651	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
8	8	----> string sub -l 20 -- $command
36	489	----> prompt_pwd -d 1 -D 1
11	11	-----> set -l options h/help d/dir-length= D/full-length-dirs=
27	27	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
3	3	-----> set -q argv[1]
8	8	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
2	2	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	370	-----> for path in $argv...
42	54	------> set -l realhome (string escape --style=regex -- ~)
12	12	-------> string escape --style=regex -- ~
40	69	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
29	29	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	232	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
6	148	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	125	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	86	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
44	44	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
45	64	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
297	708	> up-or-search
12	106	-> if commandline --search-mode...
94	94	--> commandline --search-mode
6	19	-> if commandline --paging-mode...
13	13	--> commandline --paging-mode
219	244	-> set -l lineno (commandline -L)
25	25	--> commandline -L
23	42	-> switch $lineno...
19	19	--> commandline -f history-search-backward
55	104	> __fish_disable_bracketed_paste nvim
49	49	-> printf "\e[?2004l"
31	1827	> fish_title nvim
21	1796	-> if not set -q INSIDE_EMACS...
24	24	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
10	10	--> set -q SSH_TTY
11	1724	--> if set -q argv[1]...
11	11	---> set -q argv[1]
293	1702	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
40	40	----> string sub -l 20 -- $argv[1]
87	1369	----> prompt_pwd -d 1 -D 1
32	32	-----> set -l options h/help d/dir-length= D/full-length-dirs=
66	66	-----> argparse -n prompt_pwd $options -- $argv
5	17	-----> if set -q _flag_help...
12	12	------> set -q _flag_help
10	10	-----> set -q argv[1]
19	19	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
15	15	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
8	8	-----> set -q fish_prompt_pwd_full_dirs
37	1056	-----> for path in $argv...
170	203	------> set -l realhome (string escape --style=regex -- ~)
33	33	-------> string escape --style=regex -- ~
142	208	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
66	66	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
19	608	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
29	29	-------> test "$fish_prompt_pwd_dir_length" -eq 0
13	13	-------> set -l full
29	358	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
123	278	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
119	155	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
36	36	----------> math $fish_prompt_pwd_full_dirs - 1
20	20	--------> set tmp $all[1]
15	15	--------> set full $all[2..]
133	189	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
56	56	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
73339088792	73339088792	> nvim
349	2737	> __fish_enable_bracketed_paste
2388	2388	-> printf "\e[?2004h"
108	3216	> fish_mode_prompt
825	3108	-> fish_default_mode_prompt
785	2283	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
1383	1383	---> test "$fish_key_bindings" = fish_vi_key_bindings
115	115	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
149	942586	> fish_prompt
62	62	-> set -l last_status $status
216	1840	-> set -l normal (set_color normal)
1624	1624	--> set_color normal
247	304	-> set -l status_color (set_color brgreen)
57	57	--> set_color brgreen
99	144	-> set -l cwd_color (set_color $fish_color_cwd)
45	45	--> set_color $fish_color_cwd
67	82	-> set -l vcs_color (set_color brpurple)
15	15	--> set_color brpurple
12	12	-> set -l prompt_status ""
7	7	-> set -q fish_prompt_pwd_dir_length
10	10	-> set -lx fish_prompt_pwd_dir_length 0
10	10	-> set -l suffix '❯'
21	1403	-> if functions -q fish_is_root_user...
928	928	--> functions -q fish_is_root_user
80	454	--> fish_is_root_user
4	148	---> if test "$EUID" = 0 2>/dev/null...
144	144	----> test "$EUID" = 0 2>/dev/null
26	158	---> if contains -- $USER root toor Administrator...
132	132	----> contains -- $USER root toor Administrator
68	68	---> return 1
3	22	-> if test $last_status -ne 0...
19	19	--> test $last_status -ne 0
518	938480	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
221	3686	--> prompt_login
19	77	---> if not set -q __fish_machine...
58	58	----> not set -q __fish_machine
2	32	---> if set -q __fish_machine[1]...
30	30	----> set -q __fish_machine[1]
23	23	---> set -l color_host $fish_color_host
18	27	---> if set -q SSH_TTY...
9	9	----> set -q SSH_TTY
1283	3306	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
195	195	----> set_color $fish_color_user
22	22	----> set_color normal
21	21	----> set_color $color_host
252	1742	----> prompt_hostname
1490	1490	-----> string replace -r -- "\..*" "" $hostname
43	43	----> set_color normal
232	1049	--> prompt_pwd
40	40	---> set -l options h/help d/dir-length= D/full-length-dirs=
62	62	---> argparse -n prompt_pwd $options -- $argv
13	21	---> if set -q _flag_help...
8	8	----> set -q _flag_help
7	7	---> set -q argv[1]
12	12	---> set argv $PWD
6	6	---> set -ql _flag_d
6	6	---> set -q fish_prompt_pwd_dir_length
9	9	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
7	7	---> set -q fish_prompt_pwd_full_dirs
8	8	---> set -l fish_prompt_pwd_full_dirs 1
76	633	---> for path in $argv...
159	183	----> set -l realhome (string escape --style=regex -- ~)
24	24	-----> string escape --style=regex -- ~
154	322	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
168	168	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	52	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
19	19	-----> test "$fish_prompt_pwd_dir_length" -eq 0
24	24	-----> echo $tmp
160	933227	--> fish_vcs_prompt
560	933067	---> fish_git_prompt $argv
14	131359	----> if not command -sq git...
131345	131345	-----> not command -sq git
20	118	----> if functions -q __fish_git_prompt_ready...
98	98	-----> functions -q __fish_git_prompt_ready
463	373363	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
372900	372900	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
149	149	----> test -n "$repo_info"
58	58	----> set -l git_dir $repo_info[1]
51	51	----> set -l inside_gitdir $repo_info[2]
21	21	----> set -l bare_repo $repo_info[3]
32	32	----> set -l inside_worktree $repo_info[4]
13	13	----> set -q repo_info[5]
61	61	----> set -l sha $repo_info[5]
386	202476	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
238	202090	-----> __fish_git_prompt_operation_branch_bare $repo_info
62	62	------> set -l git_dir $argv[1]
19	19	------> set -l inside_gitdir $argv[2]
17	17	------> set -l bare_repo $argv[3]
24	24	------> set -q argv[5]
18	18	------> set -l sha $argv[5]
12	12	------> set -l branch
12	12	------> set -l operation
12	12	------> set -l detached no
11	11	------> set -l bare
11	11	------> set -l step
32	32	------> set -l total
238	469	------> if test -d $git_dir/rebase-merge...
60	60	-------> test -d $git_dir/rebase-merge
32	171	-------> if test -d $git_dir/rebase-apply...
36	36	--------> test -d $git_dir/rebase-apply
35	35	--------> test -f $git_dir/MERGE_HEAD
28	28	--------> test -f $git_dir/CHERRY_PICK_HEAD
20	20	--------> test -f $git_dir/REVERT_HEAD
20	20	--------> test -f $git_dir/BISECT_LOG
4	29	------> if test -n "$step" -a -n "$total"...
25	25	-------> test -n "$step" -a -n "$total"
22	200989	------> if test -z "$branch"...
13	13	-------> test -z "$branch"
9	200954	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
374	200945	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
200571	200571	---------> command git symbolic-ref HEAD 2>/dev/null
6	55	------> if test true = $inside_gitdir...
49	49	-------> test true = $inside_gitdir
37	37	------> echo $operation
19	19	------> echo $branch
13	13	------> echo $detached
11	11	------> echo $bare
28	28	----> set -l r $rbc[1]
17	17	----> set -l b $rbc[2]
18	18	----> set -l detached $rbc[3]
11	11	----> set -l dirtystate
10	10	----> set -l stagedstate
11	11	----> set -l invalidstate
10	10	----> set -l stashstate
11	11	----> set -l untrackedfiles
16	16	----> set -l c $rbc[4]
11	11	----> set -l p
12	12	----> set -l informative_status
51	51	----> set -q __fish_git_prompt_status_order
15	62	----> if not set -q ___fish_git_prompt_init...
47	47	-----> not set -q ___fish_git_prompt_init
165	165	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
13	13	----> set -l informative
12	12	----> set -l dirty
12	12	----> set -l untracked
201658	220200	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
18542	18542	-----> read -lz key value
16	92	----> if not set -q dirty[1]...
36	36	-----> not set -q dirty[1]
40	40	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
137	137	----> contains dirtystate $__fish_git_prompt_status_order
39	79	----> if not set -q untracked[1]...
16	16	-----> not set -q untracked[1]
24	24	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
26	26	----> contains untrackedfiles $__fish_git_prompt_status_order
364	774	----> if test true = $inside_worktree...
20	20	-----> test true = $inside_worktree
41	331	-----> if test "$informative" = true...
70	70	------> test "$informative" = true
48	82	------> begin...
34	34	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
32	83	------> if not test "$dirty" = true...
16	16	-------> not test "$dirty" = true
13	13	-------> test "$untracked" = true
22	22	-------> test "$dirty" = true
5	55	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
50	50	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
24	59	-----> if set -q __fish_git_prompt_showupstream...
15	15	------> set -q __fish_git_prompt_showupstream
20	20	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
39	39	----> set -l branch_color $___fish_git_prompt_color_branch
23	23	----> set -l branch_done $___fish_git_prompt_color_branch_done
5	25	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
20	20	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
18	18	----> set -l f ""
74	175	----> for i in $__fish_git_prompt_status_order...
4	24	-----> if test -n "$$i"...
20	20	------> test -n "$$i"
3	25	-----> if test -n "$$i"...
22	22	------> test -n "$$i"
3	17	-----> if test -n "$$i"...
14	14	------> test -n "$$i"
4	19	-----> if test -n "$$i"...
15	15	------> test -n "$$i"
3	16	-----> if test -n "$$i"...
13	13	------> test -n "$$i"
250	309	----> set b (string replace refs/heads/ '' -- $b)
59	59	-----> string replace refs/heads/ '' -- $b
11	616	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
605	605	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
13	111	----> if test -n "$b"...
27	27	-----> test -n "$b"
22	22	-----> set b "$branch_color$b$branch_done"
18	49	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
15	15	------> test -z "$dirtystate$untrackedfiles$stagedstate"
16	16	------> test -n "$___fish_git_prompt_char_cleanstate"
2	14	----> if test -n "$c"...
12	12	-----> test -n "$c"
3	13	----> if test -n "$r"...
10	10	-----> test -n "$r"
2	13	----> if test -n "$p"...
11	11	-----> test -n "$p"
2	13	----> if test -n "$f"...
11	11	-----> test -n "$f"
24	24	----> set -l format $argv[1]
11	42	----> if test -z "$format"...
14	14	-----> test -z "$format"
17	17	-----> set format " (%s)"
1593	1593	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
61	61	-> echo -n -s $status_color $suffix ' ' $normal
67	3186	> fish_title
40	3119	-> if not set -q INSIDE_EMACS...
29	29	--> not set -q INSIDE_EMACS
29	29	--> set -l ssh
12	12	--> set -q SSH_TTY
33	3009	--> if set -q argv[1]...
10	10	---> set -q argv[1]
171	202	---> set -l command (status current-command)
31	31	----> status current-command
16	173	---> if test "$command" = fish...
133	133	----> test "$command" = fish
24	24	----> set command
337	2591	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
25	25	----> string sub -l 20 -- $command
140	2229	----> prompt_pwd -d 1 -D 1
24	24	-----> set -l options h/help d/dir-length= D/full-length-dirs=
73	73	-----> argparse -n prompt_pwd $options -- $argv
8	59	-----> if set -q _flag_help...
51	51	------> set -q _flag_help
20	20	-----> set -q argv[1]
22	22	-----> set argv $PWD
9	9	-----> set -ql _flag_d
20	20	-----> set -l fish_prompt_pwd_dir_length $_flag_d
10	10	-----> set -q fish_prompt_pwd_dir_length
12	12	-----> set -l fulldirs 0
18	18	-----> set -ql _flag_D
19	19	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
10	10	-----> set -q fish_prompt_pwd_full_dirs
64	1793	-----> for path in $argv...
315	371	------> set -l realhome (string escape --style=regex -- ~)
56	56	-------> string escape --style=regex -- ~
175	283	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
108	108	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
28	1075	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
28	28	-------> test "$fish_prompt_pwd_dir_length" -eq 0
14	14	-------> set -l full
24	742	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
16	16	--------> test $fish_prompt_pwd_full_dirs -gt 0
225	660	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
156	435	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
279	279	----------> math $fish_prompt_pwd_full_dirs - 1
26	26	--------> set tmp $all[1]
16	16	--------> set full $all[2..]
195	263	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
68	68	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4573	11074	> source /usr/local/Cellar/fish/3.7.1/share/fish/completions/ssh.fish
2054	5761	-> __fish_complete_ssh ssh
1479	1553	--> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_complete_ssh.fish
48	48	---> function __fish_complete_ssh -d "common completions for ssh commands" --argument-names command...
16	16	---> function __fish_ssh_ciphers -d "List of possible SSH cipher algorithms"...
10	10	---> function __fish_ssh_macs -d "List of possible SSH MAC algorithms"...
947	947	--> complete -c $command -s 4 -d "IPv4 only"
20	20	--> complete -c $command -s 6 -d "IPv6 only"
30	30	--> complete -c $command -s A -d "Enables forwarding of the authentication agent"
12	12	--> complete -c $command -s C -d "Compress all data"
55	55	--> complete -c $command -s c -d "Encryption algorithm" -xa "(__fish_complete_list , __fish_ssh_ciphers)"
18	18	--> complete -c $command -s F -d "Configuration file" -rF
16	16	--> complete -c $command -s i -d "Identity key file" -rF
34	34	--> complete -c $command -s J -d 'ProxyJump host' -xa "(__fish_complete_user_at_hosts)"
235	235	--> complete -c $command -s o -d Options -xa "
        AddKeysToAgent
        AddressFamily
        BatchMode
        BindAddress
        BindInterface
        CanonicalDomains
        CanonicalizeFallbackLocal
        CanonicalizeHostname
        CanonicalizeMaxDots
        CanonicalizePermittedCNAMEs
        CASignatureAlgorithms
        CertificateFile
        ChallengeResponseAuthentication
        CheckHostIP
        Ciphers
        ClearAllForwardings
        Compression
        ConnectionAttempts
        ConnectTimeout
        ControlMaster
        ControlPath
        ControlPersist
        DynamicForward
        EscapeChar
        ExitOnForwardFailure
        FingerprintHash
        ForwardAgent
        ForwardX11
        ForwardX11Timeout
        ForwardX11Trusted
        GatewayPorts
        GlobalKnownHostsFile
        GSSAPIAuthentication
        GSSAPIClientIdentity
        GSSAPIDelegateCredentials
        GSSAPIKexAlgorithms
        GSSAPIKeyExchange
        GSSAPIRenewalForcesRekey
        GSSAPIServerIdentity
        GSSAPITrustDns
        HashKnownHosts
        Host
        HostbasedAuthentication
        HostbasedKeyTypes
        HostKeyAlgorithms
        HostKeyAlias
        Hostname
        IdentitiesOnly
        IdentityAgent
        IdentityFile
        IPQoS
        KbdInteractiveAuthentication
        KbdInteractiveDevices
        KexAlgorithms
        LocalCommand
        LocalForward
        LogLevel
        MACs
        Match
        NoHostAuthenticationForLocalhost
        NumberOfPasswordPrompts
        PasswordAuthentication
        PermitLocalCommand
        PKCS11Provider
        Port
        PreferredAuthentications
        ProxyCommand
        ProxyJump
        ProxyUseFdpass
        PubkeyAcceptedKeyTypes
        PubkeyAuthentication
        RekeyLimit
        RemoteCommand
        RemoteForward
        RequestTTY
        SendEnv
        ServerAliveCountMax
        ServerAliveInterval
        SetEnv
        StreamLocalBindMask
        StreamLocalBindUnlink
        StrictHostKeyChecking
        TCPKeepAlive
        Tunnel
        TunnelDevice
        UpdateHostKeys
        User
        UserKnownHostsFile
        VerifyHostKeyDNS
        VisualHostKey
        XAuthLocation
    "
773	773	--> complete -c $command -s q -d "Quiet mode"
14	14	--> complete -c $command -s v -d "Verbose mode"
99	99	-> complete -c ssh -d Remote -xa "(__fish_complete_user_at_hosts)"
28	28	-> complete -c ssh -d Remote -k -fa '(__ssh_history_completions)'
52	52	-> complete -c ssh -n 'test (__fish_number_of_cmd_args_wo_opts) -ge 2' -d "Command to run" -xa '(__fish_complete_subcommand --fcs-skip=2)'
12	12	-> complete -c ssh -s a -d "Disables forwarding of the authentication agent"
25	25	-> complete -c ssh -s B -d "Bind to the address of that interface" -xa '(__fish_print_interfaces)'
38	38	-> complete -c ssh -s b -d "Local address to bind to" -xa '(__fish_print_addresses)'
11	11	-> complete -c ssh -s D -d "Specify dynamic port forwarding" -x
58	58	-> complete -c ssh -s E -d "Append debug logs to log_file" -rF
20	20	-> complete -c ssh -s e -d "Escape character" -xa "\^ none"
30	30	-> complete -c ssh -s f -d "Go to background"
20	20	-> complete -c ssh -s G -d "Print configuration after evaluating Host"
9	9	-> complete -c ssh -s g -d "Allow remote host to connect to local forwarded ports"
8	8	-> complete -c ssh -s I -d "Specify the PKCS#11 library" -r
8	8	-> complete -c ssh -s K -d "Enables GSSAPI-based authentication"
8	8	-> complete -c ssh -s k -d "Disables forwarding of GSSAPI credentials"
14	14	-> complete -c ssh -s L -d "Specify local port forwarding" -x
31	31	-> complete -c ssh -s l -x -a "(__fish_complete_users)" -d User
21	21	-> complete -c ssh -s M -d "Places the ssh client into master mode"
34	34	-> complete -c ssh -s m -d "MAC algorithm" -xa "(__fish_complete_list , __fish_ssh_macs)"
11	11	-> complete -c ssh -s N -d "Do not execute remote command"
9	9	-> complete -c ssh -s n -d "Prevent reading from stdin"
19	19	-> complete -c ssh -s O -d "Control an active connection multiplexing master process" -x
8	8	-> complete -c ssh -s p -d Port -x
40	40	-> complete -c ssh -s Q -d "List supported algorithms" -xa "(ssh -Q help)"
12	12	-> complete -c ssh -s R -d "Specify remote/reverse port forwarding" -x
19	19	-> complete -c ssh -s S -d "Location of a control socket for connection sharing" -r
8	8	-> complete -c ssh -s s -d Subsystem
20	20	-> complete -c ssh -s T -d "Disable pseudo-tty allocation"
8	8	-> complete -c ssh -s t -d "Force pseudo-tty allocation"
7	7	-> complete -c ssh -s V -d "Display version number"
8	8	-> complete -c ssh -s W -d "Forward stdin/stdout to host:port over secure channel" -x
9	9	-> complete -c ssh -s w -d "Requests tunnel device forwarding" -x
8	8	-> complete -c ssh -s X -d "Enable X11 forwarding"
8	8	-> complete -c ssh -s x -d "Disable X11 forwarding"
12	12	-> complete -c ssh -s Y -d "Enables trusted X11 forwarding"
8	8	-> complete -c ssh -s y -d "Send log information using syslog"
442	9551	> test (__fish_number_of_cmd_args_wo_opts) -ge 2
655	9109	-> __fish_number_of_cmd_args_wo_opts
1361	1376	--> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_number_of_cmd_args_wo_opts.fish
15	15	---> function __fish_number_of_cmd_args_wo_opts...
1906	7078	--> count (__fish_print_cmd_args_without_options)
202	5172	---> __fish_print_cmd_args_without_options
664	683	----> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_print_cmd_args_without_options.fish
19	19	-----> function __fish_print_cmd_args_without_options...
3567	4287	----> __fish_print_cmd_args | string match -re '^[^-]'
588	603	-----> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_print_cmd_args.fish
15	15	------> function __fish_print_cmd_args...
117	117	-----> commandline -poc
504	18674	> __ssh_history_completions
1934	1951	-> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__ssh_history_completions.fish
17	17	--> function __ssh_history_completions -d "Retrieve `user@host` entries from history"...
1575	16219	-> history --prefix ssh --max=100 | string replace -rf '.* ([A-Za-z0-9._:-]+@[A-Za-z0-9._:-]+).*' '$1'
2799	2852	--> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/history.fish
38	38	---> function __fish_unexpected_hist_args --no-scope-shadowing...
15	15	---> function history --description "display or manipulate interactive command history"...
48	48	--> set -l cmd history
24	24	--> set -l options --exclusive 'c,e,p' --exclusive 'S,D,M,V,X'
11	11	--> set -a options h/help c/contains e/exact p/prefix
14	14	--> set -a options C/case-sensitive R/reverse z/null 't/show-time=?' 'n#max'
11	11	--> set -a options S-search D-delete M-merge V-save X-clear
225	2476	--> argparse -n $cmd $options -- $argv
437	2251	---> _validate_int
1172	1185	----> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/_validate_int.fish
13	13	-----> function _validate_int --no-scope-shadowing...
25	25	----> set -l options 'm-min=' 'x-max='
20	20	----> argparse -n _argparse_validate_int $options -- $argv
7	535	----> if not string match -qr '^-?\d+$' -- $_flag_value...
528	528	-----> not string match -qr '^-?\d+$' -- $_flag_value
2	31	----> if set -q _flag_min...
29	29	-----> set -q _flag_min
6	12	----> if set -q _flag_max...
6	6	-----> set -q _flag_max
6	6	----> return 0
3	15	--> if set -q _flag_help...
12	12	---> set -q _flag_help
8	8	--> set -l hist_cmd
6	6	--> set -l show_time
6	6	--> set -l max_count
5	5	--> set -l search_mode
5	5	--> set -q _flag_max
12	12	--> set max_count -n$_flag_max
6	6	--> set -q _flag_with_time
17	29	--> if set -q _flag_show_time[1]...
6	6	---> set -q _flag_show_time[1]
6	6	---> set -q _flag_show_time
5	5	--> set -q _flag_prefix
8	8	--> set -l search_mode --prefix
5	5	--> set -q _flag_contains
6	6	--> set -q _flag_exact
9	40	--> if set -q _flag_delete...
5	5	---> set -q _flag_delete
5	5	---> set -q _flag_save
5	5	---> set -q _flag_clear
5	5	---> set -q _flag_search
5	5	---> set -q _flag_merge
6	6	---> set -q _flag_clear-session
11	189	--> if not set -q hist_cmd[1]...
6	6	---> not set -q hist_cmd[1]
5	5	---> set -q argv[1]
5	167	---> if contains $argv[1] search delete merge save clear clear-session...
162	162	----> contains $argv[1] search delete merge save clear clear-session
6	21	--> if not set -q hist_cmd[1]...
7	7	---> not set -q hist_cmd[1]
8	8	---> set hist_cmd search
39	8842	--> switch $hist_cmd...
13	13	---> test -z "$search_mode"
58	8790	---> if isatty stdout...
118	1194	----> isatty stdout
973	990	-----> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/isatty.fish
17	17	------> function isatty -d "Tests if a file descriptor is a tty"...
15	15	-----> set -l options h/help
19	19	-----> argparse -n isatty $options -- $argv
1	8	-----> if set -q _flag_help...
7	7	------> set -q _flag_help
3	8	-----> if set -q argv[2]...
5	5	------> set -q argv[2]
7	7	-----> set -l fd
12	18	-----> switch "$argv"...
6	6	------> set fd 1
11	11	-----> test -t "$fd"
7538	7538	----> builtin history search $search_mode $show_time $max_count $_flag_case_sensitive $_flag_reverse $_flag_null -- $argv
249	32365	> __fish_complete_user_at_hosts
556	570	-> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_complete_user_at_hosts.fish
14	14	--> function __fish_complete_user_at_hosts -d "Print list host-names with user@"...
1001	31546	-> for user_at in (commandline -ct | string match -r '.*@'; or echo "")(__fish_print_hostnames)...
140	140	--> commandline -ct | string match -r '.*@'
110	110	--> echo ""
911	29081	--> __fish_print_hostnames
3616	3639	---> source /usr/local/Cellar/fish/3.7.1/share/fish/functions/__fish_print_hostnames.fish
23	23	----> function __fish_print_hostnames -d "Print a list of known hostnames"...
2128	2387	---> begin
        test -r /etc/hosts && read -z </etc/hosts | string replace -r '#.*$' ''
        or type -q getent && getent hosts 2>/dev/null
    end |
        # Ignore own IP addresses (127.*, 0.0[.0[.0]], ::1), non-host IPs (fe00::*, ff00::*),
        # and leading/trailing whitespace. Split results on whitespace to handle multiple aliases for
        # one IP.
        string replace -irf '^\s*?(?!(?:0\.|127\.|ff0|fe0|::1))\S+\s*(.*?)\s*$' '$1' |
        string split ' '
84	84	----> test -r /etc/hosts
175	175	----> read -z </etc/hosts | string replace -r '#.*$' ''
268	1503	---> if test -r /etc/fstab...
74	74	----> test -r /etc/fstab
1161	1161	----> string match -r '^\s*[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3]:|^[a-zA-Z\.]*:' </etc/fstab |
            string replace -r ':.*' ''
118	118	---> set -l known_hosts ~/.ssh/known_hosts{,2} \
        {/data/data/com.termux/files/usr,/usr/local,}/etc/ssh/{,ssh_}known_hosts{,2}
18	18	---> set -l ssh_config ~/.ssh/config
4	107	---> if functions -q ssh...
103	103	----> functions -q ssh
8	8	---> function _ssh_include --argument-names ssh_config...
266	7483	---> set -l ssh_configs /etc/ssh/ssh_config (_ssh_include /etc/ssh/ssh_config) $ssh_config (_ssh_include $ssh_config)
828	3787	----> _ssh_include /etc/ssh/ssh_config
18	18	-----> set -l relative_path $HOME/.ssh
10	52	-----> if string match '/etc/ssh/*' -- $ssh_config...
33	33	------> string match '/etc/ssh/*' -- $ssh_config
9	9	------> set relative_path /etc/ssh
17	17	-----> function _recursive --no-scope-shadowing...
43	2872	-----> _recursive $ssh_config
16	16	------> set -l paths
15	1541	------> for config in $argv...
43	1526	-------> if test -r "$config" -a -f "$config"...
558	558	--------> test -r "$config" -a -f "$config"
207	925	--------> set paths $paths (
                    # Keep only Include lines and remove Include syntax
                    string replace -rfi '^\s*Include\s+' '' <$config \
                    # Normalize whitespace
                    | string trim | string replace -r -a '\s+' ' ')
718	718	---------> string replace -rfi '^\s*Include\s+' '' <$config \
                    # Normalize whitespace
                    | string trim | string replace -r -a '\s+' ' '
13	13	------> set -l new_paths
27	1241	------> for path in $paths...
9	9	-------> set -l expanded_path
12	509	-------> if string match -qrv '^[~/]' $path...
497	497	--------> string match -qrv '^[~/]' $path
43	681	-------> eval set expanded_path $path
638	638	--------> set expanded_path /etc/ssh/ssh_config.d/*
15	15	-------> for path in $expanded_path...
4	18	------> if test -n "$new_paths"...
14	14	-------> test -n "$new_paths"
48	3430	----> _ssh_include $ssh_config
18	18	-----> set -l relative_path $HOME/.ssh
3	21	-----> if string match '/etc/ssh/*' -- $ssh_config...
18	18	------> string match '/etc/ssh/*' -- $ssh_config
8	8	-----> function _recursive --no-scope-shadowing...
30	3335	-----> _recursive $ssh_config
8	8	------> set -l paths
16	3212	------> for config in $argv...
131	3196	-------> if test -r "$config" -a -f "$config"...
2310	2310	--------> test -r "$config" -a -f "$config"
277	755	--------> set paths $paths (
                    # Keep only Include lines and remove Include syntax
                    string replace -rfi '^\s*Include\s+' '' <$config \
                    # Normalize whitespace
                    | string trim | string replace -r -a '\s+' ' ')
478	478	---------> string replace -rfi '^\s*Include\s+' '' <$config \
                    # Normalize whitespace
                    | string trim | string replace -r -a '\s+' ' '
16	16	------> set -l new_paths
13	13	------> for path in $paths...
4	56	------> if test -n "$new_paths"...
52	52	-------> test -n "$new_paths"
39	5431	---> for file in $ssh_configs...
54	4129	----> if test -r $file...
73	73	-----> test -r $file
197	197	-----> read -alz -d \n contents <$file
2620	2620	-----> string replace -rfi '^\s*Host\s+(\S.*?)\s*$' '$1' -- $contents | string split " " | string match -rv '[\*\?]'
208	1185	-----> set known_hosts $known_hosts (string replace -rfi '.*KnownHostsFile\s*' '' -- $contents)
977	977	------> string replace -rfi '.*KnownHostsFile\s*' '' -- $contents
29	712	----> if test -r $file...
67	67	-----> test -r $file
139	139	-----> read -alz -d \n contents <$file
204	204	-----> string replace -rfi '^\s*Host\s+(\S.*?)\s*$' '$1' -- $contents | string split " " | string match -rv '[\*\?]'
136	273	-----> set known_hosts $known_hosts (string replace -rfi '.*KnownHostsFile\s*' '' -- $contents)
137	137	------> string replace -rfi '.*KnownHostsFile\s*' '' -- $contents
23	551	----> if test -r $file...
46	46	-----> test -r $file
76	76	-----> read -alz -d \n contents <$file
222	222	-----> string replace -rfi '^\s*Host\s+(\S.*?)\s*$' '$1' -- $contents | string split " " | string match -rv '[\*\?]'
140	184	-----> set known_hosts $known_hosts (string replace -rfi '.*KnownHostsFile\s*' '' -- $contents)
44	44	------> string replace -rfi '.*KnownHostsFile\s*' '' -- $contents
2119	7454	---> for file in $known_hosts
        if test -r $file
            read -z <$file
        end
    end |
        # Ignore hosts that are hashed, commented or @-marked and strip the key
        # Handle multiple comma-separated hostnames sharing a key, too.
        #
        # This one regex does everything we need, finding all matches including comma-separated
        # values, but fish does not let us print only a capturing group without the entire match,
        # and we can't use `string replace` instead (because CSV then fails).
        # string match -ar "(?:^|,)(?![@|*!])\[?([^ ,:\]]+)\]?"
        #
        # Instead, manually piece together the regular expressions
        string match -v -r '^\s*[!*|@#]' | string replace -rf '^\s*(\S+) .*' '$1' |
        string split ',' | string replace -r '\[?([^\]]+).*' '$1'
196	3929	----> if test -r $file...
88	88	-----> test -r $file
3645	3645	-----> read -z <$file
6	67	----> if test -r $file...
61	61	-----> test -r $file
3	25	----> if test -r $file...
22	22	-----> test -r $file
7	438	----> if test -r $file...
431	431	-----> test -r $file
4	60	----> if test -r $file...
56	56	-----> test -r $file
8	598	----> if test -r $file...
590	590	-----> test -r $file
2	48	----> if test -r $file...
46	46	-----> test -r $file
3	35	----> if test -r $file...
32	32	-----> test -r $file
1	13	----> if test -r $file...
12	12	-----> test -r $file
2	16	----> if test -r $file...
14	14	-----> test -r $file
3	24	----> if test -r $file...
21	21	-----> test -r $file
1	14	----> if test -r $file...
13	13	-----> test -r $file
1	19	----> if test -r $file...
18	18	-----> test -r $file
2	20	----> if test -r $file...
18	18	-----> test -r $file
2	17	----> if test -r $file...
15	15	-----> test -r $file
2	12	----> if test -r $file...
10	10	-----> test -r $file
22	22	---> return 0
27	27	--> echo $user_at
9	9	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
6	6	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
8	8	--> echo $user_at
10	10	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
6	6	--> echo $user_at
7	7	--> echo $user_at
6	6	--> echo $user_at
8	8	--> echo $user_at
8	8	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
8	8	--> echo $user_at
9	9	--> echo $user_at
8	8	--> echo $user_at
13	13	--> echo $user_at
8	8	--> echo $user_at
13	13	--> echo $user_at
8	8	--> echo $user_at
8	8	--> echo $user_at
9	9	--> echo $user_at
14	14	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
6	6	--> echo $user_at
6	6	--> echo $user_at
7	7	--> echo $user_at
6	6	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
38	38	--> echo $user_at
12	12	--> echo $user_at
8	8	--> echo $user_at
31	31	--> echo $user_at
16	16	--> echo $user_at
9	9	--> echo $user_at
35	35	--> echo $user_at
13	13	--> echo $user_at
13	13	--> echo $user_at
7	7	--> echo $user_at
43	43	--> echo $user_at
23	23	--> echo $user_at
143	143	--> echo $user_at
13	13	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
22	22	--> echo $user_at
9	9	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
12	12	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
11	11	--> echo $user_at
10	10	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
6	6	--> echo $user_at
6	6	--> echo $user_at
14	14	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
6	6	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
12	12	--> echo $user_at
11	11	--> echo $user_at
7	7	--> echo $user_at
9	9	--> echo $user_at
7	7	--> echo $user_at
8	8	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
7	7	--> echo $user_at
74	201	> __fish_disable_bracketed_paste 'ssh blueberry'
127	127	-> printf "\e[?2004l"
51	2022	> fish_title ssh\ blueberry
28	1971	-> if not set -q INSIDE_EMACS...
27	27	--> not set -q INSIDE_EMACS
17	17	--> set -l ssh
6	6	--> set -q SSH_TTY
8	1893	--> if set -q argv[1]...
6	6	---> set -q argv[1]
237	1879	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
17	17	----> string sub -l 20 -- $argv[1]
258	1625	----> prompt_pwd -d 1 -D 1
162	162	-----> set -l options h/help d/dir-length= D/full-length-dirs=
56	56	-----> argparse -n prompt_pwd $options -- $argv
1	9	-----> if set -q _flag_help...
8	8	------> set -q _flag_help
6	6	-----> set -q argv[1]
11	11	-----> set argv $PWD
5	5	-----> set -ql _flag_d
10	10	-----> set -l fish_prompt_pwd_dir_length $_flag_d
5	5	-----> set -q fish_prompt_pwd_dir_length
6	6	-----> set -l fulldirs 0
8	8	-----> set -ql _flag_D
11	11	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
6	6	-----> set -q fish_prompt_pwd_full_dirs
115	1072	-----> for path in $argv...
117	146	------> set -l realhome (string escape --style=regex -- ~)
29	29	-------> string escape --style=regex -- ~
72	115	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
43	43	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
18	696	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
22	22	-------> test "$fish_prompt_pwd_dir_length" -eq 0
20	20	-------> set -l full
13	473	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
10	10	--------> test $fish_prompt_pwd_full_dirs -gt 0
123	427	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
104	304	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
200	200	----------> math $fish_prompt_pwd_full_dirs - 1
14	14	--------> set tmp $all[1]
9	9	--------> set full $all[2..]
110	163	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
53	53	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
248539	248539	> ssh blueberry
50	170	> __fish_enable_bracketed_paste
120	120	-> printf "\e[?2004h"
61	382	> fish_mode_prompt
261	321	-> fish_default_mode_prompt
7	60	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
43	43	---> test "$fish_key_bindings" = fish_vi_key_bindings
10	10	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
184	502937	> fish_prompt
26	26	-> set -l last_status $status
157	254	-> set -l normal (set_color normal)
97	97	--> set_color normal
150	198	-> set -l status_color (set_color brgreen)
48	48	--> set_color brgreen
170	194	-> set -l cwd_color (set_color $fish_color_cwd)
24	24	--> set_color $fish_color_cwd
93	188	-> set -l vcs_color (set_color brpurple)
95	95	--> set_color brpurple
12	12	-> set -l prompt_status ""
6	6	-> set -q fish_prompt_pwd_dir_length
8	8	-> set -lx fish_prompt_pwd_dir_length 0
8	8	-> set -l suffix '❯'
43	511	-> if functions -q fish_is_root_user...
116	116	--> functions -q fish_is_root_user
39	352	--> fish_is_root_user
10	269	---> if test "$EUID" = 0 2>/dev/null...
259	259	----> test "$EUID" = 0 2>/dev/null
11	38	---> if contains -- $USER root toor Administrator...
27	27	----> contains -- $USER root toor Administrator
6	6	---> return 1
9	292	-> if test $last_status -ne 0...
14	14	--> test $last_status -ne 0
199	240	--> set status_color (set_color $fish_color_error)
41	41	---> set_color $fish_color_error
29	29	--> set prompt_status $status_color "[" $last_status "]" $normal
442	501026	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
618	1418	--> prompt_login
6	39	---> if not set -q __fish_machine...
33	33	----> not set -q __fish_machine
2	17	---> if set -q __fish_machine[1]...
15	15	----> set -q __fish_machine[1]
22	22	---> set -l color_host $fish_color_host
1	7	---> if set -q SSH_TTY...
6	6	----> set -q SSH_TTY
475	715	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
30	30	----> set_color $fish_color_user
21	21	----> set_color normal
26	26	----> set_color $color_host
99	148	----> prompt_hostname
49	49	-----> string replace -r -- "\..*" "" $hostname
15	15	----> set_color normal
52	695	--> prompt_pwd
24	24	---> set -l options h/help d/dir-length= D/full-length-dirs=
79	79	---> argparse -n prompt_pwd $options -- $argv
3	15	---> if set -q _flag_help...
12	12	----> set -q _flag_help
6	6	---> set -q argv[1]
14	14	---> set argv $PWD
5	5	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
8	8	---> set -l fulldirs 0
4	4	---> set -ql _flag_D
6	6	---> set -q fish_prompt_pwd_full_dirs
11	11	---> set -l fish_prompt_pwd_full_dirs 1
55	463	---> for path in $argv...
138	159	----> set -l realhome (string escape --style=regex -- ~)
21	21	-----> string escape --style=regex -- ~
106	195	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
89	89	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
13	54	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
25	25	-----> test "$fish_prompt_pwd_dir_length" -eq 0
16	16	-----> echo $tmp
193	498471	--> fish_vcs_prompt
355	498278	---> fish_git_prompt $argv
13	104063	----> if not command -sq git...
104050	104050	-----> not command -sq git
17	125	----> if functions -q __fish_git_prompt_ready...
108	108	-----> functions -q __fish_git_prompt_ready
349	143325	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
142976	142976	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
37	37	----> test -n "$repo_info"
15	15	----> set -l git_dir $repo_info[1]
19	19	----> set -l inside_gitdir $repo_info[2]
9	9	----> set -l bare_repo $repo_info[3]
11	11	----> set -l inside_worktree $repo_info[4]
6	6	----> set -q repo_info[5]
19	19	----> set -l sha $repo_info[5]
127	116302	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
147	116175	-----> __fish_git_prompt_operation_branch_bare $repo_info
24	24	------> set -l git_dir $argv[1]
18	18	------> set -l inside_gitdir $argv[2]
12	12	------> set -l bare_repo $argv[3]
13	13	------> set -q argv[5]
10	10	------> set -l sha $argv[5]
7	7	------> set -l branch
7	7	------> set -l operation
7	7	------> set -l detached no
6	6	------> set -l bare
6	6	------> set -l step
7	7	------> set -l total
142	1022	------> if test -d $git_dir/rebase-merge...
45	45	-------> test -d $git_dir/rebase-merge
24	835	-------> if test -d $git_dir/rebase-apply...
36	36	--------> test -d $git_dir/rebase-apply
23	23	--------> test -f $git_dir/MERGE_HEAD
79	79	--------> test -f $git_dir/CHERRY_PICK_HEAD
637	637	--------> test -f $git_dir/REVERT_HEAD
36	36	--------> test -f $git_dir/BISECT_LOG
2	19	------> if test -n "$step" -a -n "$total"...
17	17	-------> test -n "$step" -a -n "$total"
15	114786	------> if test -z "$branch"...
9	9	-------> test -z "$branch"
11	114762	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
181	114751	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
114570	114570	---------> command git symbolic-ref HEAD 2>/dev/null
3	35	------> if test true = $inside_gitdir...
32	32	-------> test true = $inside_gitdir
23	23	------> echo $operation
11	11	------> echo $branch
8	8	------> echo $detached
7	7	------> echo $bare
13	13	----> set -l r $rbc[1]
9	9	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
8	8	----> set -l dirtystate
5	5	----> set -l stagedstate
45	45	----> set -l invalidstate
11	11	----> set -l stashstate
7	7	----> set -l untrackedfiles
14	14	----> set -l c $rbc[4]
5	5	----> set -l p
11	11	----> set -l informative_status
18	18	----> set -q __fish_git_prompt_status_order
3	23	----> if not set -q ___fish_git_prompt_init...
20	20	-----> not set -q ___fish_git_prompt_init
43	43	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
6	6	----> set -l informative
6	6	----> set -l dirty
7	7	----> set -l untracked
116267	132749	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
16482	16482	-----> read -lz key value
11	67	----> if not set -q dirty[1]...
31	31	-----> not set -q dirty[1]
25	25	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
48	48	----> contains dirtystate $__fish_git_prompt_status_order
21	48	----> if not set -q untracked[1]...
9	9	-----> not set -q untracked[1]
18	18	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
14	14	----> contains untrackedfiles $__fish_git_prompt_status_order
35	143	----> if test true = $inside_worktree...
11	11	-----> test true = $inside_worktree
13	75	-----> if test "$informative" = true...
8	8	------> test "$informative" = true
5	19	------> begin...
14	14	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
4	24	------> if not test "$dirty" = true...
8	8	-------> not test "$dirty" = true
6	6	-------> test "$untracked" = true
6	6	-------> test "$dirty" = true
1	11	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
10	10	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
6	22	-----> if set -q __fish_git_prompt_showupstream...
6	6	------> set -q __fish_git_prompt_showupstream
10	10	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
23	23	----> set -l branch_color $___fish_git_prompt_color_branch
11	11	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	12	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
11	11	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
6	6	----> set -l f ""
61	171	----> for i in $__fish_git_prompt_status_order...
9	33	-----> if test -n "$$i"...
24	24	------> test -n "$$i"
3	11	-----> if test -n "$$i"...
8	8	------> test -n "$$i"
1	7	-----> if test -n "$$i"...
6	6	------> test -n "$$i"
25	32	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
3	27	-----> if test -n "$$i"...
24	24	------> test -n "$$i"
127	165	----> set b (string replace refs/heads/ '' -- $b)
38	38	-----> string replace refs/heads/ '' -- $b
3	39	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
36	36	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
7	58	----> if test -n "$b"...
10	10	-----> test -n "$b"
13	13	-----> set b "$branch_color$b$branch_done"
5	28	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
12	12	------> test -z "$dirtystate$untrackedfiles$stagedstate"
11	11	------> test -n "$___fish_git_prompt_char_cleanstate"
2	8	----> if test -n "$c"...
6	6	-----> test -n "$c"
1	7	----> if test -n "$r"...
6	6	-----> test -n "$r"
1	7	----> if test -n "$p"...
6	6	-----> test -n "$p"
2	8	----> if test -n "$f"...
6	6	-----> test -n "$f"
11	11	----> set -l format $argv[1]
4	24	----> if test -z "$format"...
6	6	-----> test -z "$format"
14	14	-----> set format " (%s)"
134	134	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
30	30	-> echo -n -s $status_color $suffix ' ' $normal
20	1609	> fish_title
13	1589	-> if not set -q INSIDE_EMACS...
18	18	--> not set -q INSIDE_EMACS
8	8	--> set -l ssh
6	6	--> set -q SSH_TTY
18	1544	--> if set -q argv[1]...
6	6	---> set -q argv[1]
91	140	---> set -l command (status current-command)
49	49	----> status current-command
4	25	---> if test "$command" = fish...
13	13	----> test "$command" = fish
8	8	----> set command
332	1355	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
16	16	----> string sub -l 20 -- $command
53	1007	----> prompt_pwd -d 1 -D 1
17	17	-----> set -l options h/help d/dir-length= D/full-length-dirs=
53	53	-----> argparse -n prompt_pwd $options -- $argv
3	10	-----> if set -q _flag_help...
7	7	------> set -q _flag_help
6	6	-----> set -q argv[1]
9	9	-----> set argv $PWD
4	4	-----> set -ql _flag_d
15	15	-----> set -l fish_prompt_pwd_dir_length $_flag_d
5	5	-----> set -q fish_prompt_pwd_dir_length
7	7	-----> set -l fulldirs 0
4	4	-----> set -ql _flag_D
8	8	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
4	4	-----> set -q fish_prompt_pwd_full_dirs
35	812	-----> for path in $argv...
79	96	------> set -l realhome (string escape --style=regex -- ~)
17	17	-------> string escape --style=regex -- ~
111	160	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
49	49	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
16	521	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
15	15	-------> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-------> set -l full
13	305	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
8	8	--------> test $fish_prompt_pwd_full_dirs -gt 0
97	262	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
135	165	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
30	30	----------> math $fish_prompt_pwd_full_dirs - 1
14	14	--------> set tmp $all[1]
8	8	--------> set full $all[2..]
133	178	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
45	45	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
38	67	> __fish_disable_bracketed_paste 'ssh 192.168.0.198'
29	29	-> printf "\e[?2004l"
21	1063	> fish_title ssh\ 192.168.0.198
14	1042	-> if not set -q INSIDE_EMACS...
14	14	--> not set -q INSIDE_EMACS
10	10	--> set -l ssh
6	6	--> set -q SSH_TTY
7	998	--> if set -q argv[1]...
6	6	---> set -q argv[1]
147	985	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
23	23	----> string sub -l 20 -- $argv[1]
60	815	----> prompt_pwd -d 1 -D 1
16	16	-----> set -l options h/help d/dir-length= D/full-length-dirs=
45	45	-----> argparse -n prompt_pwd $options -- $argv
3	10	-----> if set -q _flag_help...
7	7	------> set -q _flag_help
6	6	-----> set -q argv[1]
10	10	-----> set argv $PWD
5	5	-----> set -ql _flag_d
10	10	-----> set -l fish_prompt_pwd_dir_length $_flag_d
5	5	-----> set -q fish_prompt_pwd_dir_length
7	7	-----> set -l fulldirs 0
5	5	-----> set -ql _flag_D
10	10	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
6	6	-----> set -q fish_prompt_pwd_full_dirs
25	620	-----> for path in $argv...
82	99	------> set -l realhome (string escape --style=regex -- ~)
17	17	-------> string escape --style=regex -- ~
76	124	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
48	48	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
14	372	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
18	18	-------> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-------> set -l full
13	213	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
10	10	--------> test $fish_prompt_pwd_full_dirs -gt 0
70	169	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
76	99	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
23	23	----------> math $fish_prompt_pwd_full_dirs - 1
13	13	--------> set tmp $all[1]
8	8	--------> set full $all[2..]
79	119	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
40	40	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
41791496	41791496	> ssh 192.168.0.198
56	164	> __fish_enable_bracketed_paste
108	108	-> printf "\e[?2004h"
13	88	> fish_mode_prompt
45	75	-> fish_default_mode_prompt
4	30	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
20	20	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
55	249935	> fish_prompt
18	18	-> set -l last_status $status
56	89	-> set -l normal (set_color normal)
33	33	--> set_color normal
137	147	-> set -l status_color (set_color brgreen)
10	10	--> set_color brgreen
111	134	-> set -l cwd_color (set_color $fish_color_cwd)
23	23	--> set_color $fish_color_cwd
51	61	-> set -l vcs_color (set_color brpurple)
10	10	--> set_color brpurple
6	6	-> set -l prompt_status ""
9	9	-> set -q fish_prompt_pwd_dir_length
12	12	-> set -lx fish_prompt_pwd_dir_length 0
5	5	-> set -l suffix '❯'
3	201	-> if functions -q fish_is_root_user...
88	88	--> functions -q fish_is_root_user
16	110	--> fish_is_root_user
2	53	---> if test "$EUID" = 0 2>/dev/null...
51	51	----> test "$EUID" = 0 2>/dev/null
3	37	---> if contains -- $USER root toor Administrator...
34	34	----> contains -- $USER root toor Administrator
4	4	---> return 1
5	82	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
45	56	--> set status_color (set_color $fish_color_error)
11	11	---> set_color $fish_color_error
13	13	--> set prompt_status $status_color "[" $last_status "]" $normal
232	249102	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
79	903	--> prompt_login
2	8	---> if not set -q __fish_machine...
6	6	----> not set -q __fish_machine
1	6	---> if set -q __fish_machine[1]...
5	5	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	4	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
610	798	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
25	25	----> set_color normal
19	19	----> set_color $color_host
88	120	----> prompt_hostname
32	32	-----> string replace -r -- "\..*" "" $hostname
13	13	----> set_color normal
72	552	--> prompt_pwd
11	11	---> set -l options h/help d/dir-length= D/full-length-dirs=
43	43	---> argparse -n prompt_pwd $options -- $argv
2	9	---> if set -q _flag_help...
7	7	----> set -q _flag_help
4	4	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
31	31	---> set -q fish_prompt_pwd_dir_length
6	6	---> set -l fulldirs 0
35	35	---> set -ql _flag_D
45	45	---> set -q fish_prompt_pwd_full_dirs
20	20	---> set -l fish_prompt_pwd_full_dirs 1
21	267	---> for path in $argv...
77	90	----> set -l realhome (string escape --style=regex -- ~)
13	13	-----> string escape --style=regex -- ~
65	129	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
64	64	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
5	27	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
15	15	-----> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-----> echo $tmp
52	247415	--> fish_vcs_prompt
125	247363	---> fish_git_prompt $argv
10	58072	----> if not command -sq git...
58062	58062	-----> not command -sq git
3	67	----> if functions -q __fish_git_prompt_ready...
64	64	-----> functions -q __fish_git_prompt_ready
165	63213	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
63048	63048	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
75	62683	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
49	62608	-----> __fish_git_prompt_operation_branch_bare $repo_info
10	10	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
12	12	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
24	74	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	38	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
9	62366	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
4	62353	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
136	62349	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
62213	62213	---------> command git symbolic-ref HEAD 2>/dev/null
3	21	------> if test true = $inside_gitdir...
18	18	-------> test true = $inside_gitdir
13	13	------> echo $operation
7	7	------> echo $branch
5	5	------> echo $detached
3	3	------> echo $bare
11	11	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
16	16	----> set -q __fish_git_prompt_status_order
1	7	----> if not set -q ___fish_git_prompt_init...
6	6	-----> not set -q ___fish_git_prompt_init
19	19	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
5	5	----> set -l informative
5	5	----> set -l dirty
4	4	----> set -l untracked
56509	62562	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6053	6053	-----> read -lz key value
8	42	----> if not set -q dirty[1]...
18	18	-----> not set -q dirty[1]
16	16	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
2	17	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
10	10	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
8	83	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	54	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
2	10	------> begin...
8	8	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
11	17	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	13	-----> if set -q __fish_git_prompt_showupstream...
5	5	------> set -q __fish_git_prompt_showupstream
6	6	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
0	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
7	7	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
2	6	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
81	94	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
8	38	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
8	8	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
2	5	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
40	40	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
14	14	-> echo -n -s $status_color $suffix ' ' $normal
10	732	> fish_title
8	722	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
5	699	--> if set -q argv[1]...
3	3	---> set -q argv[1]
38	44	---> set -l command (status current-command)
6	6	----> status current-command
2	12	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
76	635	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
29	552	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
21	21	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
23	454	-----> for path in $argv...
45	56	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
57	88	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
31	31	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	287	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
16	16	-------> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-------> set -l full
7	187	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
72	162	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
46	90	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
44	44	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
47	70	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
23	23	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
2572	2845	> up-or-search
7	93	-> if commandline --search-mode...
86	86	--> commandline --search-mode
2	16	-> if commandline --paging-mode...
14	14	--> commandline --paging-mode
118	134	-> set -l lineno (commandline -L)
16	16	--> commandline -L
21	30	-> switch $lineno...
9	9	--> commandline -f history-search-backward
33	52	> __fish_disable_bracketed_paste 'ssh maxi@192.168.0.198'
19	19	-> printf "\e[?2004l"
15	829	> fish_title ssh\ maxi@192.168.0.198
9	814	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
4	4	--> set -q SSH_TTY
4	785	--> if set -q argv[1]...
4	4	---> set -q argv[1]
115	777	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
15	15	----> string sub -l 20 -- $argv[1]
37	647	----> prompt_pwd -d 1 -D 1
11	11	-----> set -l options h/help d/dir-length= D/full-length-dirs=
27	27	-----> argparse -n prompt_pwd $options -- $argv
1	6	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
8	8	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
18	525	-----> for path in $argv...
102	128	------> set -l realhome (string escape --style=regex -- ~)
26	26	-------> string escape --style=regex -- ~
57	112	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
55	55	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
12	267	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
14	14	-------> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-------> set -l full
9	152	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
7	7	--------> test $fish_prompt_pwd_full_dirs -gt 0
49	122	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
57	73	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
62	83	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
27906198	27906198	> ssh maxi@192.168.0.198
93	352	> __fish_enable_bracketed_paste
259	259	-> printf "\e[?2004h"
189	578	> fish_mode_prompt
290	389	-> fish_default_mode_prompt
13	99	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
56	56	---> test "$fish_key_bindings" = fish_vi_key_bindings
30	30	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
85	251068	> fish_prompt
38	38	-> set -l last_status $status
117	198	-> set -l normal (set_color normal)
81	81	--> set_color normal
187	209	-> set -l status_color (set_color brgreen)
22	22	--> set_color brgreen
176	213	-> set -l cwd_color (set_color $fish_color_cwd)
37	37	--> set_color $fish_color_cwd
145	166	-> set -l vcs_color (set_color brpurple)
21	21	--> set_color brpurple
19	19	-> set -l prompt_status ""
19	19	-> set -q fish_prompt_pwd_dir_length
12	12	-> set -lx fish_prompt_pwd_dir_length 0
12	12	-> set -l suffix '❯'
7	876	-> if functions -q fish_is_root_user...
161	161	--> functions -q fish_is_root_user
50	708	--> fish_is_root_user
10	400	---> if test "$EUID" = 0 2>/dev/null...
390	390	----> test "$EUID" = 0 2>/dev/null
8	247	---> if contains -- $USER root toor Administrator...
239	239	----> contains -- $USER root toor Administrator
11	11	---> return 1
3	21	-> if test $last_status -ne 0...
18	18	--> test $last_status -ne 0
512	249189	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
189	1671	--> prompt_login
3	17	---> if not set -q __fish_machine...
14	14	----> not set -q __fish_machine
2	11	---> if set -q __fish_machine[1]...
9	9	----> set -q __fish_machine[1]
20	20	---> set -l color_host $fish_color_host
3	11	---> if set -q SSH_TTY...
8	8	----> set -q SSH_TTY
950	1423	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
29	29	----> set_color $fish_color_user
35	35	----> set_color normal
183	183	----> set_color $color_host
147	205	----> prompt_hostname
58	58	-----> string replace -r -- "\..*" "" $hostname
21	21	----> set_color normal
229	1148	--> prompt_pwd
36	36	---> set -l options h/help d/dir-length= D/full-length-dirs=
45	45	---> argparse -n prompt_pwd $options -- $argv
5	16	---> if set -q _flag_help...
11	11	----> set -q _flag_help
13	13	---> set -q argv[1]
15	15	---> set argv $PWD
6	6	---> set -ql _flag_d
7	7	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
7	7	---> set -ql _flag_D
9	9	---> set -q fish_prompt_pwd_full_dirs
11	11	---> set -l fish_prompt_pwd_full_dirs 1
98	743	---> for path in $argv...
202	239	----> set -l realhome (string escape --style=regex -- ~)
37	37	-----> string escape --style=regex -- ~
242	343	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
101	101	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
12	63	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
32	32	-----> test "$fish_prompt_pwd_dir_length" -eq 0
19	19	-----> echo $tmp
108	245858	--> fish_vcs_prompt
144	245750	---> fish_git_prompt $argv
10	62952	----> if not command -sq git...
62942	62942	-----> not command -sq git
6	75	----> if functions -q __fish_git_prompt_ready...
69	69	-----> functions -q __fish_git_prompt_ready
130	58989	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58859	58859	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
5	5	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
61	63133	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
68	63072	-----> __fish_git_prompt_operation_branch_bare $repo_info
26	26	------> set -l git_dir $argv[1]
9	9	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
3	3	------> set -l total
25	94	------> if test -d $git_dir/rebase-merge...
17	17	-------> test -d $git_dir/rebase-merge
11	52	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
8	8	--------> test -f $git_dir/MERGE_HEAD
13	13	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	9	------> if test -n "$step" -a -n "$total"...
8	8	-------> test -n "$step" -a -n "$total"
9	62790	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	62777	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
97	62774	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
62677	62677	---------> command git symbolic-ref HEAD 2>/dev/null
3	15	------> if test true = $inside_gitdir...
12	12	-------> test true = $inside_gitdir
10	10	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
53987	59862	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5875	5875	-----> read -lz key value
8	45	----> if not set -q dirty[1]...
16	16	-----> not set -q dirty[1]
21	21	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
18	18	----> contains dirtystate $__fish_git_prompt_status_order
3	16	----> if not set -q untracked[1]...
5	5	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
9	79	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	51	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
3	12	------> begin...
9	9	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	21	------> if not test "$dirty" = true...
10	10	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
9	9	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	47	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
63	78	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
2	27	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
25	25	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
6	33	----> if test -n "$b"...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
1	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	4	----> if test -n "$f"...
3	3	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
28	28	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
11	11	-> echo -n -s $status_color $suffix ' ' $normal
9	702	> fish_title
9	693	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
3	3	--> set -q SSH_TTY
6	670	--> if set -q argv[1]...
3	3	---> set -q argv[1]
37	42	---> set -l command (status current-command)
5	5	----> status current-command
2	13	---> if test "$command" = fish...
7	7	----> test "$command" = fish
4	4	----> set command
68	606	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
32	531	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
46	46	-----> argparse -n prompt_pwd $options -- $argv
1	11	-----> if set -q _flag_help...
10	10	------> set -q _flag_help
4	4	-----> set -q argv[1]
8	8	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	394	-----> for path in $argv...
67	81	------> set -l realhome (string escape --style=regex -- ~)
14	14	-------> string escape --style=regex -- ~
41	64	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
23	23	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	234	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
5	151	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
6	6	--------> test $fish_prompt_pwd_full_dirs -gt 0
39	128	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
47	89	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
42	42	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
43	62	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
205	522	> up-or-search
19	109	-> if commandline --search-mode...
90	90	--> commandline --search-mode
4	25	-> if commandline --paging-mode...
21	21	--> commandline --paging-mode
138	152	-> set -l lineno (commandline -L)
14	14	--> commandline -L
16	31	-> switch $lineno...
15	15	--> commandline -f history-search-backward
49	80	> __fish_disable_bracketed_paste 'ssh maxi@192.168.0.199'
31	31	-> printf "\e[?2004l"
24	1180	> fish_title ssh\ maxi@192.168.0.199
15	1156	-> if not set -q INSIDE_EMACS...
17	17	--> not set -q INSIDE_EMACS
12	12	--> set -l ssh
7	7	--> set -q SSH_TTY
7	1105	--> if set -q argv[1]...
7	7	---> set -q argv[1]
192	1091	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
22	22	----> string sub -l 20 -- $argv[1]
53	877	----> prompt_pwd -d 1 -D 1
19	19	-----> set -l options h/help d/dir-length= D/full-length-dirs=
50	50	-----> argparse -n prompt_pwd $options -- $argv
7	15	-----> if set -q _flag_help...
8	8	------> set -q _flag_help
7	7	-----> set -q argv[1]
12	12	-----> set argv $PWD
6	6	-----> set -ql _flag_d
13	13	-----> set -l fish_prompt_pwd_dir_length $_flag_d
6	6	-----> set -q fish_prompt_pwd_dir_length
8	8	-----> set -l fulldirs 0
5	5	-----> set -ql _flag_D
10	10	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
6	6	-----> set -q fish_prompt_pwd_full_dirs
27	667	-----> for path in $argv...
90	112	------> set -l realhome (string escape --style=regex -- ~)
22	22	-------> string escape --style=regex -- ~
82	127	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
45	45	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
13	401	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
19	19	-------> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-------> set -l full
11	239	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
11	11	--------> test $fish_prompt_pwd_full_dirs -gt 0
85	194	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
85	109	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
24	24	----------> math $fish_prompt_pwd_full_dirs - 1
13	13	--------> set tmp $all[1]
10	10	--------> set full $all[2..]
85	122	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
37	37	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
331360	331360	> ssh maxi@192.168.0.199
172	288	> __fish_enable_bracketed_paste
116	116	-> printf "\e[?2004h"
35	171	> fish_mode_prompt
41	136	-> fish_default_mode_prompt
10	95	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
52	52	---> test "$fish_key_bindings" = fish_vi_key_bindings
33	33	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
97	256104	> fish_prompt
36	36	-> set -l last_status $status
234	275	-> set -l normal (set_color normal)
41	41	--> set_color normal
274	358	-> set -l status_color (set_color brgreen)
84	84	--> set_color brgreen
143	196	-> set -l cwd_color (set_color $fish_color_cwd)
53	53	--> set_color $fish_color_cwd
155	182	-> set -l vcs_color (set_color brpurple)
27	27	--> set_color brpurple
20	20	-> set -l prompt_status ""
13	13	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
15	15	-> set -l suffix '❯'
10	263	-> if functions -q fish_is_root_user...
34	34	--> functions -q fish_is_root_user
40	219	--> fish_is_root_user
5	138	---> if test "$EUID" = 0 2>/dev/null...
133	133	----> test "$EUID" = 0 2>/dev/null
4	30	---> if contains -- $USER root toor Administrator...
26	26	----> contains -- $USER root toor Administrator
11	11	---> return 1
27	293	-> if test $last_status -ne 0...
20	20	--> test $last_status -ne 0
160	189	--> set status_color (set_color $fish_color_error)
29	29	---> set_color $fish_color_error
57	57	--> set prompt_status $status_color "[" $last_status "]" $normal
437	254327	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
52	1278	--> prompt_login
6	21	---> if not set -q __fish_machine...
15	15	----> not set -q __fish_machine
3	14	---> if set -q __fish_machine[1]...
11	11	----> set -q __fish_machine[1]
23	23	---> set -l color_host $fish_color_host
2	12	---> if set -q SSH_TTY...
10	10	----> set -q SSH_TTY
861	1156	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
34	34	----> set_color $fish_color_user
21	21	----> set_color normal
50	50	----> set_color $color_host
65	148	----> prompt_hostname
83	83	-----> string replace -r -- "\..*" "" $hostname
42	42	----> set_color normal
80	854	--> prompt_pwd
37	37	---> set -l options h/help d/dir-length= D/full-length-dirs=
47	47	---> argparse -n prompt_pwd $options -- $argv
4	16	---> if set -q _flag_help...
12	12	----> set -q _flag_help
27	27	---> set -q argv[1]
19	19	---> set argv $PWD
10	10	---> set -ql _flag_d
10	10	---> set -q fish_prompt_pwd_dir_length
13	13	---> set -l fulldirs 0
8	8	---> set -ql _flag_D
10	10	---> set -q fish_prompt_pwd_full_dirs
13	13	---> set -l fish_prompt_pwd_full_dirs 1
49	564	---> for path in $argv...
141	176	----> set -l realhome (string escape --style=regex -- ~)
35	35	-----> string escape --style=regex -- ~
192	254	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
62	62	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
20	85	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
40	40	-----> test "$fish_prompt_pwd_dir_length" -eq 0
25	25	-----> echo $tmp
38	251758	--> fish_vcs_prompt
101	251720	---> fish_git_prompt $argv
12	70449	----> if not command -sq git...
70437	70437	-----> not command -sq git
3	31	----> if functions -q __fish_git_prompt_ready...
28	28	-----> functions -q __fish_git_prompt_ready
143	59896	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
59753	59753	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
16	16	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
6	6	----> set -l inside_gitdir $repo_info[2]
7	7	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
62	61278	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
41	61216	-----> __fish_git_prompt_operation_branch_bare $repo_info
12	12	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
23	100	------> if test -d $git_dir/rebase-merge...
13	13	-------> test -d $git_dir/rebase-merge
6	64	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
31	31	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	12	------> if test -n "$step" -a -n "$total"...
11	11	-------> test -n "$step" -a -n "$total"
11	60964	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	60949	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
96	60946	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
60850	60850	---------> command git symbolic-ref HEAD 2>/dev/null
1	17	------> if test true = $inside_gitdir...
16	16	-------> test true = $inside_gitdir
10	10	------> echo $operation
7	7	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
5	5	----> set -l dirtystate
3	3	----> set -l stagedstate
5	5	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
3	3	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
15	15	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
5	5	----> set -l informative
5	5	----> set -l dirty
4	4	----> set -l untracked
53382	59350	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5968	5968	-----> read -lz key value
9	65	----> if not set -q dirty[1]...
20	20	-----> not set -q dirty[1]
36	36	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
18	18	----> contains dirtystate $__fish_git_prompt_status_order
4	18	----> if not set -q untracked[1]...
6	6	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
7	75	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	48	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
8	14	------> begin...
6	6	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
3	15	------> if not test "$dirty" = true...
4	4	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
18	46	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
66	79	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	34	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
3	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
2	5	----> if test -n "$c"...
3	3	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
2	5	----> if test -n "$p"...
3	3	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
33	33	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
15	15	-> echo -n -s $status_color $suffix ' ' $normal
9	650	> fish_title
8	641	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
5	618	--> if set -q argv[1]...
4	4	---> set -q argv[1]
35	41	---> set -l command (status current-command)
6	6	----> status current-command
4	14	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
68	554	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
27	479	----> prompt_pwd -d 1 -D 1
7	7	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
5	5	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	381	-----> for path in $argv...
45	56	------> set -l realhome (string escape --style=regex -- ~)
11	11	-------> string escape --style=regex -- ~
52	85	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
33	33	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	225	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
8	134	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
51	109	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
42	58	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
16	16	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
49	69	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
20	20	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
171	619	> up-or-search
13	60	-> if commandline --search-mode...
47	47	--> commandline --search-mode
6	27	-> if commandline --paging-mode...
21	21	--> commandline --paging-mode
269	298	-> set -l lineno (commandline -L)
29	29	--> commandline -L
27	63	-> switch $lineno...
36	36	--> commandline -f history-search-backward
43	89	> __fish_disable_bracketed_paste 'ssh max@192.168.0.199'
46	46	-> printf "\e[?2004l"
20	986	> fish_title ssh\ max@192.168.0.199
9	966	-> if not set -q INSIDE_EMACS...
10	10	--> not set -q INSIDE_EMACS
6	6	--> set -l ssh
3	3	--> set -q SSH_TTY
6	938	--> if set -q argv[1]...
4	4	---> set -q argv[1]
116	928	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
15	15	----> string sub -l 20 -- $argv[1]
31	797	----> prompt_pwd -d 1 -D 1
13	13	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
7	7	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
33	684	-----> for path in $argv...
64	85	------> set -l realhome (string escape --style=regex -- ~)
21	21	-------> string escape --style=regex -- ~
160	190	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
30	30	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
12	376	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
32	32	-------> test "$fish_prompt_pwd_dir_length" -eq 0
7	7	-------> set -l full
10	226	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
7	7	--------> test $fish_prompt_pwd_full_dirs -gt 0
75	189	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
65	114	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
49	49	----------> math $fish_prompt_pwd_full_dirs - 1
12	12	--------> set tmp $all[1]
8	8	--------> set full $all[2..]
70	99	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
29	29	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
526071372	526071372	> ssh max@192.168.0.199
64	218	> __fish_enable_bracketed_paste
154	154	-> printf "\e[?2004h"
47	299	> fish_mode_prompt
146	252	-> fish_default_mode_prompt
10	106	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
79	79	---> test "$fish_key_bindings" = fish_vi_key_bindings
17	17	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
92	244727	> fish_prompt
38	38	-> set -l last_status $status
210	322	-> set -l normal (set_color normal)
112	112	--> set_color normal
164	199	-> set -l status_color (set_color brgreen)
35	35	--> set_color brgreen
145	181	-> set -l cwd_color (set_color $fish_color_cwd)
36	36	--> set_color $fish_color_cwd
201	230	-> set -l vcs_color (set_color brpurple)
29	29	--> set_color brpurple
19	19	-> set -l prompt_status ""
13	13	-> set -q fish_prompt_pwd_dir_length
14	14	-> set -lx fish_prompt_pwd_dir_length 0
15	15	-> set -l suffix '❯'
11	767	-> if functions -q fish_is_root_user...
191	191	--> functions -q fish_is_root_user
55	565	--> fish_is_root_user
8	222	---> if test "$EUID" = 0 2>/dev/null...
214	214	----> test "$EUID" = 0 2>/dev/null
20	262	---> if contains -- $USER root toor Administrator...
242	242	----> contains -- $USER root toor Administrator
26	26	---> return 1
19	414	-> if test $last_status -ne 0...
27	27	--> test $last_status -ne 0
268	314	--> set status_color (set_color $fish_color_error)
46	46	---> set_color $fish_color_error
54	54	--> set prompt_status $status_color "[" $last_status "]" $normal
507	242411	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
139	1322	--> prompt_login
6	46	---> if not set -q __fish_machine...
40	40	----> not set -q __fish_machine
3	13	---> if set -q __fish_machine[1]...
10	10	----> set -q __fish_machine[1]
23	23	---> set -l color_host $fish_color_host
2	10	---> if set -q SSH_TTY...
8	8	----> set -q SSH_TTY
705	1091	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
39	39	----> set_color $fish_color_user
21	21	----> set_color normal
53	53	----> set_color $color_host
152	248	----> prompt_hostname
96	96	-----> string replace -r -- "\..*" "" $hostname
25	25	----> set_color normal
171	1070	--> prompt_pwd
33	33	---> set -l options h/help d/dir-length= D/full-length-dirs=
35	35	---> argparse -n prompt_pwd $options -- $argv
4	14	---> if set -q _flag_help...
10	10	----> set -q _flag_help
39	39	---> set -q argv[1]
16	16	---> set argv $PWD
7	7	---> set -ql _flag_d
8	8	---> set -q fish_prompt_pwd_dir_length
11	11	---> set -l fulldirs 0
6	6	---> set -ql _flag_D
14	14	---> set -q fish_prompt_pwd_full_dirs
10	10	---> set -l fish_prompt_pwd_full_dirs 1
44	706	---> for path in $argv...
366	404	----> set -l realhome (string escape --style=regex -- ~)
38	38	-----> string escape --style=regex -- ~
153	207	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
54	54	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
11	51	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
22	22	-----> test "$fish_prompt_pwd_dir_length" -eq 0
18	18	-----> echo $tmp
111	239512	--> fish_vcs_prompt
157	239401	---> fish_git_prompt $argv
11	64016	----> if not command -sq git...
64005	64005	-----> not command -sq git
3	71	----> if functions -q __fish_git_prompt_ready...
68	68	-----> functions -q __fish_git_prompt_ready
128	57879	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
57751	57751	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
27	27	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
7	7	----> set -l sha $repo_info[5]
73	58445	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
46	58372	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
3	3	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
31	82	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
5	40	-------> if test -d $git_dir/rebase-apply...
9	9	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
7	58140	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	58129	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
98	58126	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58028	58028	---------> command git symbolic-ref HEAD 2>/dev/null
1	16	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
12	12	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
11	11	----> set -l r $rbc[1]
7	7	----> set -l b $rbc[2]
7	7	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
4	4	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
8	8	----> set -q __fish_git_prompt_status_order
2	7	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
18	18	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
52356	58250	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5894	5894	-----> read -lz key value
6	40	----> if not set -q dirty[1]...
17	17	-----> not set -q dirty[1]
17	17	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
12	12	----> contains dirtystate $__fish_git_prompt_status_order
4	15	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
7	7	----> contains untrackedfiles $__fish_git_prompt_status_order
10	70	----> if test true = $inside_worktree...
7	7	-----> test true = $inside_worktree
6	42	-----> if test "$informative" = true...
5	5	------> test "$informative" = true
2	9	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
2	11	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
17	45	----> for i in $__fish_git_prompt_status_order...
0	7	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
60	75	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
3	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	32	----> if test -n "$b"...
6	6	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
2	15	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
6	6	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	4	----> if test -n "$c"...
3	3	-----> test -n "$c"
0	4	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
6	6	----> set -l format $argv[1]
4	12	----> if test -z "$format"...
4	4	-----> test -z "$format"
4	4	-----> set format " (%s)"
31	31	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
10	686	> fish_title
7	676	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
4	4	--> set -l ssh
4	4	--> set -q SSH_TTY
6	655	--> if set -q argv[1]...
4	4	---> set -q argv[1]
36	41	---> set -l command (status current-command)
5	5	----> status current-command
3	13	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
72	591	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
7	7	----> string sub -l 20 -- $command
24	512	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
24	24	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
6	6	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
18	416	-----> for path in $argv...
50	60	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
57	91	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
34	34	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
8	247	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	155	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
48	131	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
40	83	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
43	43	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
50	69	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
19	19	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
25	48	> __fish_disable_bracketed_paste clear
23	23	-> printf "\e[?2004l"
21	831	> fish_title clear
10	810	-> if not set -q INSIDE_EMACS...
12	12	--> not set -q INSIDE_EMACS
8	8	--> set -l ssh
5	5	--> set -q SSH_TTY
6	775	--> if set -q argv[1]...
5	5	---> set -q argv[1]
158	764	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
16	16	----> string sub -l 20 -- $argv[1]
48	590	----> prompt_pwd -d 1 -D 1
14	14	-----> set -l options h/help d/dir-length= D/full-length-dirs=
34	34	-----> argparse -n prompt_pwd $options -- $argv
3	8	-----> if set -q _flag_help...
5	5	------> set -q _flag_help
4	4	-----> set -q argv[1]
9	9	-----> set argv $PWD
3	3	-----> set -ql _flag_d
9	9	-----> set -l fish_prompt_pwd_dir_length $_flag_d
4	4	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
4	4	-----> set -ql _flag_D
7	7	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
17	438	-----> for path in $argv...
54	68	------> set -l realhome (string escape --style=regex -- ~)
14	14	-------> string escape --style=regex -- ~
52	87	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
35	35	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
14	266	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
12	12	-------> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-------> set -l full
7	149	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
7	7	--------> test $fish_prompt_pwd_full_dirs -gt 0
53	121	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
51	68	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
17	17	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
6	6	--------> set full $all[2..]
59	85	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
26	26	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
63071	63071	> clear
33	63	> __fish_enable_bracketed_paste
30	30	-> printf "\e[?2004h"
11	55	> fish_mode_prompt
13	44	-> fish_default_mode_prompt
5	31	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
19	19	---> test "$fish_key_bindings" = fish_vi_key_bindings
7	7	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
52	254451	> fish_prompt
13	13	-> set -l last_status $status
44	56	-> set -l normal (set_color normal)
12	12	--> set_color normal
39	48	-> set -l status_color (set_color brgreen)
9	9	--> set_color brgreen
56	66	-> set -l cwd_color (set_color $fish_color_cwd)
10	10	--> set_color $fish_color_cwd
66	80	-> set -l vcs_color (set_color brpurple)
14	14	--> set_color brpurple
8	8	-> set -l prompt_status ""
6	6	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
5	85	-> if functions -q fish_is_root_user...
10	10	--> functions -q fish_is_root_user
13	70	--> fish_is_root_user
2	41	---> if test "$EUID" = 0 2>/dev/null...
39	39	----> test "$EUID" = 0 2>/dev/null
1	12	---> if contains -- $USER root toor Administrator...
11	11	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	8	-> if test $last_status -ne 0...
7	7	--> test $last_status -ne 0
135	253998	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
16	293	--> prompt_login
2	10	---> if not set -q __fish_machine...
8	8	----> not set -q __fish_machine
0	4	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
2	5	---> if set -q SSH_TTY...
3	3	----> set -q SSH_TTY
168	250	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
8	8	----> set_color normal
8	8	----> set_color $color_host
16	48	----> prompt_hostname
32	32	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
24	226	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
1	5	---> if set -q _flag_help...
4	4	----> set -q _flag_help
3	3	---> set -q argv[1]
6	6	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
4	4	---> set -l fulldirs 0
3	3	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
19	147	---> for path in $argv...
40	51	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
39	59	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
20	20	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
4	18	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
8	8	-----> test "$fish_prompt_pwd_dir_length" -eq 0
6	6	-----> echo $tmp
11	253344	--> fish_vcs_prompt
112	253333	---> fish_git_prompt $argv
11	53350	----> if not command -sq git...
53339	53339	-----> not command -sq git
1	35	----> if functions -q __fish_git_prompt_ready...
34	34	-----> functions -q __fish_git_prompt_ready
143	62770	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
62627	62627	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
20	20	----> test -n "$repo_info"
10	10	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
3	3	----> set -q repo_info[5]
8	8	----> set -l sha $repo_info[5]
71	63854	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
42	63783	-----> __fish_git_prompt_operation_branch_bare $repo_info
12	12	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
5	5	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
3	3	------> set -l step
4	4	------> set -l total
23	73	------> if test -d $git_dir/rebase-merge...
12	12	-------> test -d $git_dir/rebase-merge
5	38	-------> if test -d $git_dir/rebase-apply...
7	7	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
7	7	--------> test -f $git_dir/CHERRY_PICK_HEAD
6	6	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
8	63558	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
3	63546	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
147	63543	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
63396	63396	---------> command git symbolic-ref HEAD 2>/dev/null
4	19	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
7	7	------> echo $branch
5	5	------> echo $detached
3	3	------> echo $bare
7	7	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
3	3	----> set -l untrackedfiles
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
11	11	----> set -l informative_status
6	6	----> set -q __fish_git_prompt_status_order
1	6	----> if not set -q ___fish_git_prompt_init...
5	5	-----> not set -q ___fish_git_prompt_init
16	16	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
4	4	----> set -l informative
4	4	----> set -l dirty
4	4	----> set -l untracked
65944	72601	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
6657	6657	-----> read -lz key value
8	48	----> if not set -q dirty[1]...
21	21	-----> not set -q dirty[1]
19	19	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
13	13	----> contains dirtystate $__fish_git_prompt_status_order
5	17	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
8	8	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
10	81	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
7	51	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
3	16	------> begin...
13	13	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	15	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
4	4	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
1	7	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
3	12	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
7	7	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
19	48	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
1	6	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
70	85	----> set b (string replace refs/heads/ '' -- $b)
15	15	-----> string replace refs/heads/ '' -- $b
2	25	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
4	34	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	4	----> if test -n "$r"...
3	3	-----> test -n "$r"
1	4	----> if test -n "$p"...
3	3	-----> test -n "$p"
0	4	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
3	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
6	6	-----> set format " (%s)"
30	30	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
20	20	-> echo -n -s $status_color $suffix ' ' $normal
31	884	> fish_title
11	853	-> if not set -q INSIDE_EMACS...
15	15	--> not set -q INSIDE_EMACS
25	25	--> set -l ssh
6	6	--> set -q SSH_TTY
15	796	--> if set -q argv[1]...
4	4	---> set -q argv[1]
119	133	---> set -l command (status current-command)
14	14	----> status current-command
6	25	---> if test "$command" = fish...
12	12	----> test "$command" = fish
7	7	----> set command
110	619	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
12	12	----> string sub -l 20 -- $command
30	497	----> prompt_pwd -d 1 -D 1
9	9	-----> set -l options h/help d/dir-length= D/full-length-dirs=
27	27	-----> argparse -n prompt_pwd $options -- $argv
1	5	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
4	4	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
5	5	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
15	388	-----> for path in $argv...
49	62	------> set -l realhome (string escape --style=regex -- ~)
13	13	-------> string escape --style=regex -- ~
47	74	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
7	237	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
10	10	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
8	144	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
45	118	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
54	73	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
19	19	----------> math $fish_prompt_pwd_full_dirs - 1
8	8	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
50	71	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
27	53	> __fish_disable_bracketed_paste ls
26	26	-> printf "\e[?2004l"
12	747	> fish_title ls
8	735	-> if not set -q INSIDE_EMACS...
9	9	--> not set -q INSIDE_EMACS
7	7	--> set -l ssh
4	4	--> set -q SSH_TTY
4	707	--> if set -q argv[1]...
4	4	---> set -q argv[1]
119	699	---> echo -- $ssh (string sub -l 20 -- $argv[1]) (prompt_pwd -d 1 -D 1)
12	12	----> string sub -l 20 -- $argv[1]
30	568	----> prompt_pwd -d 1 -D 1
13	13	-----> set -l options h/help d/dir-length= D/full-length-dirs=
34	34	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
3	3	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
5	5	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
20	446	-----> for path in $argv...
54	68	------> set -l realhome (string escape --style=regex -- ~)
14	14	-------> string escape --style=regex -- ~
64	91	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
27	27	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	267	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-------> test "$fish_prompt_pwd_dir_length" -eq 0
5	5	-------> set -l full
7	177	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
81	153	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
52	72	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
20	20	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
5	5	--------> set full $all[2..]
44	65	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
21	21	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
71	91848	> ls
91777	91777	-> eza -lha $argv
31	67	> __fish_enable_bracketed_paste
36	36	-> printf "\e[?2004h"
11	59	> fish_mode_prompt
13	48	-> fish_default_mode_prompt
4	35	--> if test "$fish_key_bindings" = fish_vi_key_bindings...
25	25	---> test "$fish_key_bindings" = fish_vi_key_bindings
6	6	---> test "$fish_key_bindings" = fish_hybrid_key_bindings
55	232427	> fish_prompt
142	142	-> set -l last_status $status
131	153	-> set -l normal (set_color normal)
22	22	--> set_color normal
141	174	-> set -l status_color (set_color brgreen)
33	33	--> set_color brgreen
78	98	-> set -l cwd_color (set_color $fish_color_cwd)
20	20	--> set_color $fish_color_cwd
54	64	-> set -l vcs_color (set_color brpurple)
10	10	--> set_color brpurple
7	7	-> set -l prompt_status ""
5	5	-> set -q fish_prompt_pwd_dir_length
5	5	-> set -lx fish_prompt_pwd_dir_length 0
6	6	-> set -l suffix '❯'
2	105	-> if functions -q fish_is_root_user...
15	15	--> functions -q fish_is_root_user
17	88	--> fish_is_root_user
2	45	---> if test "$EUID" = 0 2>/dev/null...
43	43	----> test "$EUID" = 0 2>/dev/null
11	22	---> if contains -- $USER root toor Administrator...
11	11	----> contains -- $USER root toor Administrator
4	4	---> return 1
1	9	-> if test $last_status -ne 0...
8	8	--> test $last_status -ne 0
186	231592	-> echo -s (prompt_login) ' ' $cwd_color (prompt_pwd) $vcs_color (fish_vcs_prompt) $normal ' ' $prompt_status
14	407	--> prompt_login
1	6	---> if not set -q __fish_machine...
5	5	----> not set -q __fish_machine
0	4	---> if set -q __fish_machine[1]...
4	4	----> set -q __fish_machine[1]
8	8	---> set -l color_host $fish_color_host
1	5	---> if set -q SSH_TTY...
4	4	----> set -q SSH_TTY
287	370	---> echo -n -s (set_color $fish_color_user) "$USER" (set_color normal) @ (set_color $color_host) (prompt_hostname) (set_color normal)
11	11	----> set_color $fish_color_user
13	13	----> set_color normal
12	12	----> set_color $color_host
11	40	----> prompt_hostname
29	29	-----> string replace -r -- "\..*" "" $hostname
7	7	----> set_color normal
26	304	--> prompt_pwd
7	7	---> set -l options h/help d/dir-length= D/full-length-dirs=
14	14	---> argparse -n prompt_pwd $options -- $argv
4	8	---> if set -q _flag_help...
4	4	----> set -q _flag_help
4	4	---> set -q argv[1]
8	8	---> set argv $PWD
3	3	---> set -ql _flag_d
3	3	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fulldirs 0
2	2	---> set -ql _flag_D
3	3	---> set -q fish_prompt_pwd_full_dirs
4	4	---> set -l fish_prompt_pwd_full_dirs 1
18	217	---> for path in $argv...
55	66	----> set -l realhome (string escape --style=regex -- ~)
11	11	-----> string escape --style=regex -- ~
73	105	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
32	32	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $path
9	28	----> if test "$fish_prompt_pwd_dir_length" -eq 0...
11	11	-----> test "$fish_prompt_pwd_dir_length" -eq 0
8	8	-----> echo $tmp
12	230695	--> fish_vcs_prompt
98	230683	---> fish_git_prompt $argv
10	53947	----> if not command -sq git...
53937	53937	-----> not command -sq git
2	27	----> if functions -q __fish_git_prompt_ready...
25	25	-----> functions -q __fish_git_prompt_ready
161	58547	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
58386	58386	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
21	21	----> test -n "$repo_info"
9	9	----> set -l git_dir $repo_info[1]
7	7	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
7	7	----> set -l inside_worktree $repo_info[4]
4	4	----> set -q repo_info[5]
12	12	----> set -l sha $repo_info[5]
69	58716	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
43	58647	-----> __fish_git_prompt_operation_branch_bare $repo_info
9	9	------> set -l git_dir $argv[1]
5	5	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
3	3	------> set -q argv[5]
6	6	------> set -l sha $argv[5]
4	4	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
28	78	------> if test -d $git_dir/rebase-merge...
11	11	-------> test -d $git_dir/rebase-merge
3	39	-------> if test -d $git_dir/rebase-apply...
8	8	--------> test -d $git_dir/rebase-apply
7	7	--------> test -f $git_dir/MERGE_HEAD
8	8	--------> test -f $git_dir/CHERRY_PICK_HEAD
7	7	--------> test -f $git_dir/REVERT_HEAD
6	6	--------> test -f $git_dir/BISECT_LOG
1	10	------> if test -n "$step" -a -n "$total"...
9	9	-------> test -n "$step" -a -n "$total"
11	58417	------> if test -z "$branch"...
4	4	-------> test -z "$branch"
8	58402	-------> if not set branch (command git symbolic-ref HEAD 2>/dev/null)...
101	58394	--------> not set branch (command git symbolic-ref HEAD 2>/dev/null)
58293	58293	---------> command git symbolic-ref HEAD 2>/dev/null
5	20	------> if test true = $inside_gitdir...
15	15	-------> test true = $inside_gitdir
11	11	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
8	8	----> set -l r $rbc[1]
5	5	----> set -l b $rbc[2]
8	8	----> set -l detached $rbc[3]
4	4	----> set -l dirtystate
4	4	----> set -l stagedstate
4	4	----> set -l invalidstate
3	3	----> set -l stashstate
4	4	----> set -l untrackedfiles
4	4	----> set -l c $rbc[4]
4	4	----> set -l p
4	4	----> set -l informative_status
7	7	----> set -q __fish_git_prompt_status_order
6	23	----> if not set -q ___fish_git_prompt_init...
17	17	-----> not set -q ___fish_git_prompt_init
32	32	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
5	5	----> set -l informative
5	5	----> set -l dirty
5	5	----> set -l untracked
52844	58691	----> command git config -z --get-regexp 'bash\.(showInformativeStatus|showDirtyState|showUntrackedFiles)' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showinformativestatus
                set informative $value
            case bash.showdirtystate
                set dirty $value
            case bash.showuntrackedfiles
                set untracked $value
        end
    end
5847	5847	-----> read -lz key value
8	46	----> if not set -q dirty[1]...
19	19	-----> not set -q dirty[1]
19	19	-----> contains -- "$__fish_git_prompt_showdirtystate" yes true 1
14	14	----> contains dirtystate $__fish_git_prompt_status_order
5	16	----> if not set -q untracked[1]...
4	4	-----> not set -q untracked[1]
7	7	-----> contains -- "$__fish_git_prompt_showuntrackedfiles" yes true 1
8	8	----> contains untrackedfiles $__fish_git_prompt_status_order
8	78	----> if test true = $inside_worktree...
8	8	-----> test true = $inside_worktree
6	48	-----> if test "$informative" = true...
6	6	------> test "$informative" = true
5	12	------> begin...
7	7	-------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
2	16	------> if not test "$dirty" = true...
5	5	-------> not test "$dirty" = true
5	5	-------> test "$untracked" = true
4	4	-------> test "$dirty" = true
2	8	------> if contains -- "$__fish_git_prompt_showstashstate" yes true 1...
6	6	-------> contains -- "$__fish_git_prompt_showstashstate" yes true 1
5	14	-----> if set -q __fish_git_prompt_showupstream...
4	4	------> set -q __fish_git_prompt_showupstream
5	5	------> contains -- "$__fish_git_prompt_show_informative_status" yes true 1
10	10	----> set -l branch_color $___fish_git_prompt_color_branch
8	8	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	7	----> if contains -- "$__fish_git_prompt_showcolorhints" yes true 1...
6	6	-----> contains -- "$__fish_git_prompt_showcolorhints" yes true 1
5	5	----> set -l f ""
21	49	----> for i in $__fish_git_prompt_status_order...
1	8	-----> if test -n "$$i"...
7	7	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
0	5	-----> if test -n "$$i"...
5	5	------> test -n "$$i"
1	5	-----> if test -n "$$i"...
4	4	------> test -n "$$i"
62	75	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
3	26	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"...
23	23	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
5	35	----> if test -n "$b"...
6	6	-----> test -n "$b"
8	8	-----> set b "$branch_color$b$branch_done"
2	16	-----> if test -z "$dirtystate$untrackedfiles$stagedstate"...
7	7	------> test -z "$dirtystate$untrackedfiles$stagedstate"
7	7	------> test -n "$___fish_git_prompt_char_cleanstate"
1	5	----> if test -n "$c"...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"...
4	4	-----> test -n "$r"
1	5	----> if test -n "$p"...
4	4	-----> test -n "$p"
1	5	----> if test -n "$f"...
4	4	-----> test -n "$f"
7	7	----> set -l format $argv[1]
4	13	----> if test -z "$format"...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
45	45	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
12	12	-> echo -n -s $status_color $suffix ' ' $normal
9	583	> fish_title
6	574	-> if not set -q INSIDE_EMACS...
6	6	--> not set -q INSIDE_EMACS
5	5	--> set -l ssh
4	4	--> set -q SSH_TTY
5	553	--> if set -q argv[1]...
3	3	---> set -q argv[1]
39	45	---> set -l command (status current-command)
6	6	----> status current-command
4	14	---> if test "$command" = fish...
6	6	----> test "$command" = fish
4	4	----> set command
65	486	---> echo -- $ssh (string sub -l 20 -- $command) (prompt_pwd -d 1 -D 1)
13	13	----> string sub -l 20 -- $command
21	408	----> prompt_pwd -d 1 -D 1
6	6	-----> set -l options h/help d/dir-length= D/full-length-dirs=
25	25	-----> argparse -n prompt_pwd $options -- $argv
2	6	-----> if set -q _flag_help...
4	4	------> set -q _flag_help
3	3	-----> set -q argv[1]
6	6	-----> set argv $PWD
4	4	-----> set -ql _flag_d
7	7	-----> set -l fish_prompt_pwd_dir_length $_flag_d
3	3	-----> set -q fish_prompt_pwd_dir_length
4	4	-----> set -l fulldirs 0
3	3	-----> set -ql _flag_D
6	6	-----> set -l fish_prompt_pwd_full_dirs $_flag_D
3	3	-----> set -q fish_prompt_pwd_full_dirs
12	311	-----> for path in $argv...
41	51	------> set -l realhome (string escape --style=regex -- ~)
10	10	-------> string escape --style=regex -- ~
38	59	------> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $path)
21	21	-------> string replace -r '^'"$realhome"'($|/)' '~$1' $path
6	189	------> if test "$fish_prompt_pwd_dir_length" -eq 0...
9	9	-------> test "$fish_prompt_pwd_dir_length" -eq 0
4	4	-------> set -l full
7	112	-------> if test $fish_prompt_pwd_full_dirs -gt 0...
5	5	--------> test $fish_prompt_pwd_full_dirs -gt 0
37	89	--------> set -l all (string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp)
37	52	---------> string split -m (math $fish_prompt_pwd_full_dirs - 1) -r / $tmp
15	15	----------> math $fish_prompt_pwd_full_dirs - 1
7	7	--------> set tmp $all[1]
4	4	--------> set full $all[2..]
40	58	-------> string join / -- (string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp) $full
18	18	--------> string replace -ar -- '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
40	4437	> __fish_disable_bracketed_paste
4397	4397	-> printf "\e[?2004l"
